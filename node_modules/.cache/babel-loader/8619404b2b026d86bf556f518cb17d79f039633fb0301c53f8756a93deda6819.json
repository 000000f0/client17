{"ast":null,"code":"'use strict';\n\nconst Busboy = require('busboy');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody\n} = require('./util');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  kState\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  DOMException,\n  structuredClone\n} = require('./constants');\nconst {\n  Blob,\n  File: NativeFile\n} = require('buffer');\nconst {\n  kBodyUsed\n} = require('../core/symbols');\nconst assert = require('assert');\nconst {\n  isErrored\n} = require('../core/util');\nconst {\n  isUint8Array,\n  isArrayBuffer\n} = require('util/types');\nconst {\n  File: UndiciFile\n} = require('./file');\nconst {\n  parseMIMEType,\n  serializeAMimeType\n} = require('./dataURL');\nlet ReadableStream = globalThis.ReadableStream;\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile;\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  // 1. Let stream be null.\n  let stream = null;\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object;\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream();\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new ReadableStream({\n      async pull(controller) {\n        controller.enqueue(typeof source === 'string' ? new TextEncoder().encode(source) : source);\n        queueMicrotask(() => readableStreamClose(controller));\n      },\n      start() {},\n      type: undefined\n    });\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream));\n\n  // 6. Let action be null.\n  let action = null;\n\n  // 7. Let source be null.\n  let source = null;\n\n  // 8. Let length be null.\n  let length = null;\n\n  // 9. Let type be null.\n  let type = null;\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object;\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8';\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString();\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-${Math.random()}`.replace('.', '').slice(0, 32);\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n');\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const enc = new TextEncoder();\n    const blobParts = [];\n    const rn = new Uint8Array([13, 10]); // '\\r\\n'\n    length = 0;\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n      } else {\n        const chunk = enc.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n        blobParts.push(chunk, value, rn);\n        length += chunk.byteLength + value.size + rn.byteLength;\n      }\n    }\n    const chunk = enc.encode(`--${boundary}--`);\n    blobParts.push(chunk);\n    length += chunk.byteLength;\n\n    // Set source to object.\n    source = object;\n    action = async function* () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield* part.stream();\n        } else {\n          yield part;\n        }\n      }\n    };\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = 'multipart/form-data; boundary=' + boundary;\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object;\n\n    // Set length to object’s size.\n    length = object.size;\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value));\n          }\n        }\n        return controller.desiredSize > 0;\n      },\n      async cancel(reason) {\n        await iterator.return();\n      },\n      type: undefined\n    });\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = {\n    stream,\n    source,\n    length\n  };\n\n  // 14. Return (body, type).\n  return [body, type];\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.');\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.');\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee();\n  const out2Clone = structuredClone(out2, {\n    transfer: [out2]\n  });\n  // This, for whatever reasons, unrefs out2Clone which allows\n  // the process to exit by itself.\n  const [, finalClone] = out2Clone.tee();\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1;\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: finalClone,\n    length: body.length,\n    source: body.source\n  };\n}\nasync function* consumeBody(body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body;\n    } else {\n      const stream = body.stream;\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.');\n      }\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.');\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true;\n      yield* stream;\n    }\n  }\n}\nfunction throwIfAborted(state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError');\n  }\n}\nfunction bodyMixinMethods(instance) {\n  const methods = {\n    blob() {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return specConsumeBody(this, bytes => {\n        let mimeType = bodyMimeType(this);\n        if (mimeType === 'failure') {\n          mimeType = '';\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType);\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], {\n          type: mimeType\n        });\n      }, instance);\n    },\n    arrayBuffer() {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return specConsumeBody(this, bytes => {\n        return new Uint8Array(bytes).buffer;\n      }, instance);\n    },\n    text() {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return specConsumeBody(this, utf8DecodeBytes, instance);\n    },\n    json() {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return specConsumeBody(this, parseJSONFromBytes, instance);\n    },\n    async formData() {\n      webidl.brandCheck(this, instance);\n      throwIfAborted(this[kState]);\n      const contentType = this.headers.get('Content-Type');\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {};\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;\n        const responseFormData = new FormData();\n        let busboy;\n        try {\n          busboy = Busboy({\n            headers,\n            defParamCharset: 'utf8'\n          });\n        } catch (err) {\n          throw new DOMException(`${err}`, 'AbortError');\n        }\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value);\n        });\n        busboy.on('file', (name, value, info) => {\n          const {\n            filename,\n            encoding,\n            mimeType\n          } = info;\n          const chunks = [];\n          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n            let base64chunk = '';\n            value.on('data', chunk => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '');\n              const end = base64chunk.length - base64chunk.length % 4;\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));\n              base64chunk = base64chunk.slice(end);\n            });\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'));\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          } else {\n            value.on('data', chunk => {\n              chunks.push(chunk);\n            });\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          }\n        });\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve);\n          busboy.on('error', err => reject(new TypeError(err)));\n        });\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);\n        busboy.end();\n        await busboyResolve;\n        return responseFormData;\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries;\n        try {\n          let text = '';\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', {\n            ignoreBOM: true\n          });\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk');\n            }\n            text += textDecoder.decode(chunk, {\n              stream: true\n            });\n          }\n          text += textDecoder.decode();\n          entries = new URLSearchParams(text);\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData();\n        for (const [name, value] of entries) {\n          formData.append(name, value);\n        }\n        return formData;\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve();\n        throwIfAborted(this[kState]);\n\n        // Otherwise, throw a TypeError.\n        throw webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        });\n      }\n    }\n  };\n  return methods;\n}\nfunction mixinBody(prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function specConsumeBody(object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance);\n  throwIfAborted(object[kState]);\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable');\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise();\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = error => promise.reject(error);\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = data => {\n    try {\n      promise.resolve(convertBytesToJSValue(data));\n    } catch (e) {\n      errorSteps(e);\n    }\n  };\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(new Uint8Array());\n    return promise.promise;\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  fullyReadBody(object[kState].body, successSteps, errorSteps);\n\n  // 7. Return promise.\n  return promise.promise;\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes(buffer) {\n  if (buffer.length === 0) {\n    return '';\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3);\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = new TextDecoder().decode(buffer);\n\n  // 4. Return output.\n  return output;\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes(bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes));\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */\nfunction bodyMimeType(object) {\n  const {\n    headersList\n  } = object[kState];\n  const contentType = headersList.get('content-type');\n  if (contentType === null) {\n    return 'failure';\n  }\n  return parseMIMEType(contentType);\n}\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n};","map":{"version":3,"names":["Busboy","require","util","ReadableStreamFrom","isBlobLike","isReadableStreamLike","readableStreamClose","createDeferredPromise","fullyReadBody","FormData","kState","webidl","DOMException","structuredClone","Blob","File","NativeFile","kBodyUsed","assert","isErrored","isUint8Array","isArrayBuffer","UndiciFile","parseMIMEType","serializeAMimeType","ReadableStream","globalThis","extractBody","object","keepalive","arguments","length","undefined","stream","pull","controller","enqueue","source","TextEncoder","encode","queueMicrotask","start","type","action","URLSearchParams","toString","Uint8Array","slice","ArrayBuffer","isView","buffer","byteOffset","byteLength","isFormDataLike","boundary","Math","random","replace","prefix","escape","str","normalizeLinefeeds","value","enc","blobParts","rn","name","chunk","push","size","part","Symbol","asyncIterator","TypeError","isDisturbed","locked","isBuffer","Buffer","iterator","done","next","close","desiredSize","cancel","reason","return","body","safelyExtractBody","cloneBody","out1","out2","tee","out2Clone","transfer","finalClone","consumeBody","throwIfAborted","state","aborted","bodyMixinMethods","instance","methods","blob","specConsumeBody","bytes","mimeType","bodyMimeType","arrayBuffer","text","utf8DecodeBytes","json","parseJSONFromBytes","formData","brandCheck","contentType","headers","get","test","key","toLowerCase","responseFormData","busboy","defParamCharset","err","on","append","info","filename","encoding","chunks","base64chunk","end","from","busboyResolve","Promise","resolve","reject","write","entries","textDecoder","TextDecoder","ignoreBOM","decode","Object","assign","cause","errors","exception","header","message","mixinBody","prototype","convertBytesToJSValue","bodyUnusable","promise","errorSteps","error","successSteps","data","e","subarray","output","JSON","parse","headersList","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/undici/lib/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst Busboy = require('busboy')\nconst util = require('../core/util')\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody\n} = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { DOMException, structuredClone } = require('./constants')\nconst { Blob, File: NativeFile } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array, isArrayBuffer } = require('util/types')\nconst { File: UndiciFile } = require('./file')\nconst { parseMIMEType, serializeAMimeType } = require('./dataURL')\n\nlet ReadableStream = globalThis.ReadableStream\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: undefined\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-${Math.random()}`.replace('.', '').slice(0, 32)\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const enc = new TextEncoder()\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = enc.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = enc.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        length += chunk.byteLength + value.size + rn.byteLength\n      }\n    }\n\n    const chunk = enc.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: undefined\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n  const out2Clone = structuredClone(out2, { transfer: [out2] })\n  // This, for whatever reasons, unrefs out2Clone which allows\n  // the process to exit by itself.\n  const [, finalClone] = out2Clone.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: finalClone,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return specConsumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === 'failure') {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return specConsumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return specConsumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return specConsumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    async formData () {\n      webidl.brandCheck(this, instance)\n\n      throwIfAborted(this[kState])\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {}\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value\n\n        const responseFormData = new FormData()\n\n        let busboy\n\n        try {\n          busboy = Busboy({\n            headers,\n            defParamCharset: 'utf8'\n          })\n        } catch (err) {\n          throw new DOMException(`${err}`, 'AbortError')\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value)\n        })\n        busboy.on('file', (name, value, info) => {\n          const { filename, encoding, mimeType } = info\n          const chunks = []\n\n          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n            let base64chunk = ''\n\n            value.on('data', (chunk) => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '')\n\n              const end = base64chunk.length - base64chunk.length % 4\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))\n\n              base64chunk = base64chunk.slice(end)\n            })\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'))\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          } else {\n            value.on('data', (chunk) => {\n              chunks.push(chunk)\n            })\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          }\n        })\n\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve)\n          busboy.on('error', (err) => reject(new TypeError(err)))\n        })\n\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk)\n        busboy.end()\n        await busboyResolve\n\n        return responseFormData\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += textDecoder.decode(chunk, { stream: true })\n          }\n          text += textDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve()\n\n        throwIfAborted(this[kState])\n\n        // Otherwise, throw a TypeError.\n        throw webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function specConsumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  throwIfAborted(object[kState])\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable')\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(new Uint8Array())\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = new TextDecoder().decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */\nfunction bodyMimeType (object) {\n  const { headersList } = object[kState]\n  const contentType = headersList.get('content-type')\n\n  if (contentType === null) {\n    return 'failure'\n  }\n\n  return parseMIMEType(contentType)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}