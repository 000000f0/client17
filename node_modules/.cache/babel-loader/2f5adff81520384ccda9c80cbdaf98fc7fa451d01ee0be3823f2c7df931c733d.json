{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst process = require('node:process');\nconst {\n  setImmediate\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  WebSocketManager: WSWebSocketManager,\n  WebSocketShardEvents: WSWebSocketShardEvents,\n  CompressionMethod,\n  CloseCodes\n} = require('@discordjs/ws');\nconst {\n  GatewayCloseCodes,\n  GatewayDispatchEvents\n} = require('discord-api-types/v10');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../../errors');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\nlet zlib;\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\nconst BeforeReadyWhitelist = [GatewayDispatchEvents.Ready, GatewayDispatchEvents.Resumed, GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete, GatewayDispatchEvents.GuildMembersChunk, GatewayDispatchEvents.GuildMemberAdd, GatewayDispatchEvents.GuildMemberRemove];\nconst WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];\nconst UNRESUMABLE_CLOSE_CODES = [CloseCodes.Normal, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];\nconst reasonIsDeprecated = 'the reason property is deprecated, use the code property to determine the reason';\nlet deprecationEmittedForInvalidSessionEvent = false;\nlet deprecationEmittedForDestroyedEvent = false;\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends {EventEmitter}\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * The internal WebSocketManager from `@discordjs/ws`.\n     * @type {WSWebSocketManager}\n     * @private\n     */\n    this._ws = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?number} [shardId] The id of the shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shardId) {\n    this.client.emit(Events.Debug, `[WS => ${typeof shardId === 'number' ? `Shard ${shardId}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);\n    const {\n      shards,\n      shardCount,\n      intents,\n      ws\n    } = this.client.options;\n    if (this._ws && this._ws.options.token !== this.client.token) {\n      await this._ws.destroy({\n        code: CloseCodes.Normal,\n        reason: 'Login with differing token requested'\n      });\n      this._ws = null;\n    }\n    if (!this._ws) {\n      const wsOptions = {\n        intents: intents.bitfield,\n        rest: this.client.rest,\n        token: this.client.token,\n        largeThreshold: ws.large_threshold,\n        version: ws.version,\n        shardIds: shards === 'auto' ? null : shards,\n        shardCount: shards === 'auto' ? null : shardCount,\n        initialPresence: ws.presence,\n        retrieveSessionInfo: shardId => this.shards.get(shardId).sessionInfo,\n        updateSessionInfo: (shardId, sessionInfo) => {\n          this.shards.get(shardId).sessionInfo = sessionInfo;\n        },\n        compression: zlib ? CompressionMethod.ZlibStream : null\n      };\n      if (ws.buildStrategy) wsOptions.buildStrategy = ws.buildStrategy;\n      this._ws = new WSWebSocketManager(wsOptions);\n      this.attachEvents();\n    }\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this._ws.fetchGatewayInformation().catch(error => {\n      throw error.status === 401 ? invalidToken : error;\n    });\n    const {\n      total,\n      remaining\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    this.client.options.shardCount = await this._ws.getShardCount();\n    this.client.options.shards = await this._ws.getShardIds();\n    this.totalShards = this.client.options.shards.length;\n    for (const id of this.client.options.shards) {\n      if (!this.shards.has(id)) {\n        const shard = new WebSocketShard(this, id);\n        this.shards.set(id, shard);\n        shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {\n          /**\n           * Emitted when a shard turns ready.\n           * @event Client#shardReady\n           * @param {number} id The shard id that turned ready\n           * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n           */\n          this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);\n          this.checkShardsReady();\n        });\n        shard.status = Status.Connecting;\n      }\n    }\n    await this._ws.connect();\n    this.shards.forEach(shard => {\n      if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {\n        process.emitWarning('The WebSocketShard#invalidSession event is deprecated and will never emit.', 'DeprecationWarning');\n        deprecationEmittedForInvalidSessionEvent = true;\n      }\n      if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {\n        process.emitWarning('The WebSocketShard#destroyed event is deprecated and will never emit.', 'DeprecationWarning');\n        deprecationEmittedForDestroyedEvent = true;\n      }\n    });\n  }\n\n  /**\n   * Attaches event handlers to the internal WebSocketShardManager from `@discordjs/ws`.\n   * @private\n   */\n  attachEvents() {\n    this._ws.on(WSWebSocketShardEvents.Debug, _ref => {\n      let {\n        message,\n        shardId\n      } = _ref;\n      return this.debug(message, shardId);\n    });\n    this._ws.on(WSWebSocketShardEvents.Dispatch, _ref2 => {\n      let {\n        data,\n        shardId\n      } = _ref2;\n      this.client.emit(Events.Raw, data, shardId);\n      this.emit(data.t, data.d, shardId);\n      const shard = this.shards.get(shardId);\n      this.handlePacket(data, shard);\n      if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {\n        shard.gotGuild(data.d.id);\n      }\n    });\n    this._ws.on(WSWebSocketShardEvents.Ready, _ref3 => {\n      let {\n        data,\n        shardId\n      } = _ref3;\n      this.shards.get(shardId).onReadyPacket(data);\n    });\n    this._ws.on(WSWebSocketShardEvents.Closed, _ref4 => {\n      let {\n        code,\n        shardId\n      } = _ref4;\n      const shard = this.shards.get(shardId);\n      shard.emit(WebSocketShardEvents.Close, {\n        code,\n        reason: reasonIsDeprecated,\n        wasClean: true\n      });\n      if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {\n        shard.status = Status.Disconnected;\n        /**\n         * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n         * @event Client#shardDisconnect\n         * @param {CloseEvent} event The WebSocket close event\n         * @param {number} id The shard id that disconnected\n         */\n        this.client.emit(Events.ShardDisconnect, {\n          code,\n          reason: reasonIsDeprecated,\n          wasClean: true\n        }, shardId);\n        this.debug(GatewayCloseCodes[code], shardId);\n        return;\n      }\n      this.shards.get(shardId).status = Status.Connecting;\n      /**\n       * Emitted when a shard is attempting to reconnect or re-identify.\n       * @event Client#shardReconnecting\n       * @param {number} id The shard id that is attempting to reconnect\n       */\n      this.client.emit(Events.ShardReconnecting, shardId);\n    });\n    this._ws.on(WSWebSocketShardEvents.Hello, _ref5 => {\n      let {\n        shardId\n      } = _ref5;\n      const shard = this.shards.get(shardId);\n      if (shard.sessionInfo) {\n        shard.closeSequence = shard.sessionInfo.sequence;\n        shard.status = Status.Resuming;\n      } else {\n        shard.status = Status.Identifying;\n      }\n    });\n    this._ws.on(WSWebSocketShardEvents.Resumed, _ref6 => {\n      let {\n        shardId\n      } = _ref6;\n      const shard = this.shards.get(shardId);\n      shard.status = Status.Ready;\n      /**\n       * Emitted when the shard resumes successfully\n       * @event WebSocketShard#resumed\n       */\n      shard.emit(WebSocketShardEvents.Resumed);\n    });\n    this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, _ref7 => {\n      let {\n        heartbeatAt,\n        latency,\n        shardId\n      } = _ref7;\n      this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);\n      const shard = this.shards.get(shardId);\n      shard.lastPingTimestamp = heartbeatAt;\n      shard.ping = latency;\n    });\n    this._ws.on(WSWebSocketShardEvents.Error, _ref8 => {\n      let {\n        error,\n        shardId\n      } = _ref8;\n      /**\n       * Emitted whenever a shard's WebSocket encounters a connection error.\n       * @event Client#shardError\n       * @param {Error} error The encountered error\n       * @param {number} shardId The shard that encountered this error\n       */\n      this.client.emit(Events.ShardError, error, shardId);\n    });\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shardId of this.shards.keys()) this._ws.send(shardId, packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    // TODO: Make a util for getting a stack\n    this.debug(`Manager was destroyed. Called by:\\n${new Error().stack}`);\n    this.destroyed = true;\n    this._ws.destroy({\n      code: CloseCodes.Normal\n    });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.Ready) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.Ready) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.Ready)) {\n      return;\n    }\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.Ready;\n    this.client.readyTimestamp = Date.now();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.ClientReady, this.client);\n    this.handlePacket();\n  }\n}\nmodule.exports = WebSocketManager;","map":{"version":3,"names":["EventEmitter","require","process","setImmediate","Collection","WebSocketManager","WSWebSocketManager","WebSocketShardEvents","WSWebSocketShardEvents","CompressionMethod","CloseCodes","GatewayCloseCodes","GatewayDispatchEvents","WebSocketShard","PacketHandlers","DiscordjsError","ErrorCodes","Events","Status","zlib","BeforeReadyWhitelist","Ready","Resumed","GuildCreate","GuildDelete","GuildMembersChunk","GuildMemberAdd","GuildMemberRemove","WaitingForGuildEvents","UNRESUMABLE_CLOSE_CODES","Normal","AlreadyAuthenticated","InvalidSeq","reasonIsDeprecated","deprecationEmittedForInvalidSessionEvent","deprecationEmittedForDestroyedEvent","constructor","client","Object","defineProperty","value","gateway","shards","status","Idle","destroyed","_ws","ping","sum","reduce","a","b","size","debug","message","shardId","emit","Debug","connect","invalidToken","TokenInvalid","shardCount","intents","ws","options","token","destroy","code","reason","wsOptions","bitfield","rest","largeThreshold","large_threshold","version","shardIds","initialPresence","presence","retrieveSessionInfo","get","sessionInfo","updateSessionInfo","compression","ZlibStream","buildStrategy","attachEvents","url","gatewayURL","recommendedShards","session_start_limit","sessionStartLimit","fetchGatewayInformation","catch","error","total","remaining","getShardCount","getShardIds","totalShards","length","id","has","shard","set","on","AllReady","unavailableGuilds","ShardReady","checkShardsReady","Connecting","forEach","listenerCount","InvalidSession","emitWarning","Destroyed","_ref","Dispatch","_ref2","data","Raw","t","d","handlePacket","WaitingForGuilds","includes","gotGuild","_ref3","onReadyPacket","Closed","_ref4","Close","wasClean","Disconnected","ShardDisconnect","ShardReconnecting","Hello","_ref5","closeSequence","sequence","Resuming","Identifying","_ref6","HeartbeatComplete","_ref7","heartbeatAt","latency","lastPingTimestamp","Error","_ref8","ShardError","broadcast","packet","keys","send","stack","packetQueue","push","item","shift","unref","some","s","triggerClientReady","readyTimestamp","Date","now","ClientReady","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/client/websocket/WebSocketManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst process = require('node:process');\nconst { setImmediate } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst {\n  WebSocketManager: WSWebSocketManager,\n  WebSocketShardEvents: WSWebSocketShardEvents,\n  CompressionMethod,\n  CloseCodes,\n} = require('@discordjs/ws');\nconst { GatewayCloseCodes, GatewayDispatchEvents } = require('discord-api-types/v10');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst { DiscordjsError, ErrorCodes } = require('../../errors');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\n\nlet zlib;\n\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\nconst BeforeReadyWhitelist = [\n  GatewayDispatchEvents.Ready,\n  GatewayDispatchEvents.Resumed,\n  GatewayDispatchEvents.GuildCreate,\n  GatewayDispatchEvents.GuildDelete,\n  GatewayDispatchEvents.GuildMembersChunk,\n  GatewayDispatchEvents.GuildMemberAdd,\n  GatewayDispatchEvents.GuildMemberRemove,\n];\n\nconst WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];\n\nconst UNRESUMABLE_CLOSE_CODES = [\n  CloseCodes.Normal,\n  GatewayCloseCodes.AlreadyAuthenticated,\n  GatewayCloseCodes.InvalidSeq,\n];\n\nconst reasonIsDeprecated = 'the reason property is deprecated, use the code property to determine the reason';\nlet deprecationEmittedForInvalidSessionEvent = false;\nlet deprecationEmittedForDestroyedEvent = false;\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends {EventEmitter}\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', { value: [] });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * The internal WebSocketManager from `@discordjs/ws`.\n     * @type {WSWebSocketManager}\n     * @private\n     */\n    this._ws = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?number} [shardId] The id of the shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shardId) {\n    this.client.emit(\n      Events.Debug,\n      `[WS => ${typeof shardId === 'number' ? `Shard ${shardId}` : 'Manager'}] ${message}`,\n    );\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);\n    const { shards, shardCount, intents, ws } = this.client.options;\n    if (this._ws && this._ws.options.token !== this.client.token) {\n      await this._ws.destroy({ code: CloseCodes.Normal, reason: 'Login with differing token requested' });\n      this._ws = null;\n    }\n    if (!this._ws) {\n      const wsOptions = {\n        intents: intents.bitfield,\n        rest: this.client.rest,\n        token: this.client.token,\n        largeThreshold: ws.large_threshold,\n        version: ws.version,\n        shardIds: shards === 'auto' ? null : shards,\n        shardCount: shards === 'auto' ? null : shardCount,\n        initialPresence: ws.presence,\n        retrieveSessionInfo: shardId => this.shards.get(shardId).sessionInfo,\n        updateSessionInfo: (shardId, sessionInfo) => {\n          this.shards.get(shardId).sessionInfo = sessionInfo;\n        },\n        compression: zlib ? CompressionMethod.ZlibStream : null,\n      };\n      if (ws.buildStrategy) wsOptions.buildStrategy = ws.buildStrategy;\n      this._ws = new WSWebSocketManager(wsOptions);\n      this.attachEvents();\n    }\n\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit,\n    } = await this._ws.fetchGatewayInformation().catch(error => {\n      throw error.status === 401 ? invalidToken : error;\n    });\n\n    const { total, remaining } = sessionStartLimit;\n\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n\n    this.gateway = `${gatewayURL}/`;\n\n    this.client.options.shardCount = await this._ws.getShardCount();\n    this.client.options.shards = await this._ws.getShardIds();\n    this.totalShards = this.client.options.shards.length;\n    for (const id of this.client.options.shards) {\n      if (!this.shards.has(id)) {\n        const shard = new WebSocketShard(this, id);\n        this.shards.set(id, shard);\n\n        shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {\n          /**\n           * Emitted when a shard turns ready.\n           * @event Client#shardReady\n           * @param {number} id The shard id that turned ready\n           * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n           */\n          this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);\n\n          this.checkShardsReady();\n        });\n        shard.status = Status.Connecting;\n      }\n    }\n\n    await this._ws.connect();\n\n    this.shards.forEach(shard => {\n      if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {\n        process.emitWarning(\n          'The WebSocketShard#invalidSession event is deprecated and will never emit.',\n          'DeprecationWarning',\n        );\n\n        deprecationEmittedForInvalidSessionEvent = true;\n      }\n      if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {\n        process.emitWarning(\n          'The WebSocketShard#destroyed event is deprecated and will never emit.',\n          'DeprecationWarning',\n        );\n\n        deprecationEmittedForDestroyedEvent = true;\n      }\n    });\n  }\n\n  /**\n   * Attaches event handlers to the internal WebSocketShardManager from `@discordjs/ws`.\n   * @private\n   */\n  attachEvents() {\n    this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug(message, shardId));\n    this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {\n      this.client.emit(Events.Raw, data, shardId);\n      this.emit(data.t, data.d, shardId);\n      const shard = this.shards.get(shardId);\n      this.handlePacket(data, shard);\n      if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {\n        shard.gotGuild(data.d.id);\n      }\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {\n      this.shards.get(shardId).onReadyPacket(data);\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {\n      const shard = this.shards.get(shardId);\n      shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });\n      if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {\n        shard.status = Status.Disconnected;\n        /**\n         * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n         * @event Client#shardDisconnect\n         * @param {CloseEvent} event The WebSocket close event\n         * @param {number} id The shard id that disconnected\n         */\n        this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);\n        this.debug(GatewayCloseCodes[code], shardId);\n        return;\n      }\n\n      this.shards.get(shardId).status = Status.Connecting;\n      /**\n       * Emitted when a shard is attempting to reconnect or re-identify.\n       * @event Client#shardReconnecting\n       * @param {number} id The shard id that is attempting to reconnect\n       */\n      this.client.emit(Events.ShardReconnecting, shardId);\n    });\n    this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {\n      const shard = this.shards.get(shardId);\n      if (shard.sessionInfo) {\n        shard.closeSequence = shard.sessionInfo.sequence;\n        shard.status = Status.Resuming;\n      } else {\n        shard.status = Status.Identifying;\n      }\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {\n      const shard = this.shards.get(shardId);\n      shard.status = Status.Ready;\n      /**\n       * Emitted when the shard resumes successfully\n       * @event WebSocketShard#resumed\n       */\n      shard.emit(WebSocketShardEvents.Resumed);\n    });\n\n    this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {\n      this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);\n      const shard = this.shards.get(shardId);\n      shard.lastPingTimestamp = heartbeatAt;\n      shard.ping = latency;\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {\n      /**\n       * Emitted whenever a shard's WebSocket encounters a connection error.\n       * @event Client#shardError\n       * @param {Error} error The encountered error\n       * @param {number} shardId The shard that encountered this error\n       */\n      this.client.emit(Events.ShardError, error, shardId);\n    });\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shardId of this.shards.keys()) this._ws.send(shardId, packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    // TODO: Make a util for getting a stack\n    this.debug(`Manager was destroyed. Called by:\\n${new Error().stack}`);\n    this.destroyed = true;\n    this._ws.destroy({ code: CloseCodes.Normal });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.Ready) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({ packet, shard });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.Ready) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.Ready)) {\n      return;\n    }\n\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.Ready;\n\n    this.client.readyTimestamp = Date.now();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.ClientReady, this.client);\n\n    this.handlePacket();\n  }\n}\n\nmodule.exports = WebSocketManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}