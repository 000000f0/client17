{"ast":null,"code":"'use strict';\n\nvar get = require('lodash/get.js');\nvar util = require('util');\nvar fastDeepEqual = require('fast-deep-equal/es6/index.js');\nvar uniqWith = require('lodash/uniqWith.js');\nfunction _interopDefault(e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n}\nvar get__default = /*#__PURE__*/_interopDefault(get);\nvar fastDeepEqual__default = /*#__PURE__*/_interopDefault(fastDeepEqual);\nvar uniqWith__default = /*#__PURE__*/_interopDefault(uniqWith);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// src/lib/configs.ts\nvar validationEnabled = true;\nfunction setGlobalValidationEnabled(enabled) {\n  validationEnabled = enabled;\n}\n__name(setGlobalValidationEnabled, \"setGlobalValidationEnabled\");\nfunction getGlobalValidationEnabled() {\n  return validationEnabled;\n}\n__name(getGlobalValidationEnabled, \"getGlobalValidationEnabled\");\n\n// src/lib/Result.ts\nvar Result = class {\n  constructor(success, value, error) {\n    this.success = success;\n    if (success) {\n      this.value = value;\n    } else {\n      this.error = error;\n    }\n  }\n  isOk() {\n    return this.success;\n  }\n  isErr() {\n    return !this.success;\n  }\n  unwrap() {\n    if (this.isOk()) return this.value;\n    throw this.error;\n  }\n  static ok(value) {\n    return new Result(true, value);\n  }\n  static err(error) {\n    return new Result(false, void 0, error);\n  }\n};\n__name(Result, \"Result\");\n\n// src/validators/util/getValue.ts\nfunction getValue(valueOrFn) {\n  return typeof valueOrFn === \"function\" ? valueOrFn() : valueOrFn;\n}\n__name(getValue, \"getValue\");\n\n// src/lib/errors/BaseError.ts\nvar customInspectSymbol = Symbol.for(\"nodejs.util.inspect.custom\");\nvar customInspectSymbolStackLess = Symbol.for(\"nodejs.util.inspect.custom.stack-less\");\nvar BaseError = class extends Error {\n  [customInspectSymbol](depth, options) {\n    return `${this[customInspectSymbolStackLess](depth, options)}\n${this.stack.slice(this.stack.indexOf(\"\\n\"))}`;\n  }\n};\n__name(BaseError, \"BaseError\");\n\n// src/lib/errors/BaseConstraintError.ts\nvar BaseConstraintError = class extends BaseError {\n  constructor(constraint, message, given) {\n    super(message);\n    this.constraint = constraint;\n    this.given = given;\n  }\n};\n__name(BaseConstraintError, \"BaseConstraintError\");\n\n// src/lib/errors/ExpectedConstraintError.ts\nvar ExpectedConstraintError = class extends BaseConstraintError {\n  constructor(constraint, message, given, expected) {\n    super(constraint, message, given);\n    this.expected = expected;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      constraint: this.constraint,\n      given: this.given,\n      expected: this.expected\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const constraint = options.stylize(this.constraint, \"string\");\n    if (depth < 0) {\n      return options.stylize(`[ExpectedConstraintError: ${constraint}]`, \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1\n    };\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const given = util.inspect(this.given, newOptions).replace(/\\n/g, padding);\n    const header = `${options.stylize(\"ExpectedConstraintError\", \"special\")} > ${constraint}`;\n    const message = options.stylize(this.message, \"regexp\");\n    const expectedBlock = `\n  ${options.stylize(\"Expected: \", \"string\")}${options.stylize(this.expected, \"boolean\")}`;\n    const givenBlock = `\n  ${options.stylize(\"Received:\", \"regexp\")}${padding}${given}`;\n    return `${header}\n  ${message}\n${expectedBlock}\n${givenBlock}`;\n  }\n};\n__name(ExpectedConstraintError, \"ExpectedConstraintError\");\n\n// src/constraints/ObjectConstrains.ts\nfunction whenConstraint(key, options, validator) {\n  return {\n    run(input, parent) {\n      if (!parent) {\n        return Result.err(new ExpectedConstraintError(\"s.object(T.when)\", \"Validator has no parent\", parent, \"Validator to have a parent\"));\n      }\n      const isKeyArray = Array.isArray(key);\n      const value = isKeyArray ? key.map(k => get__default.default(parent, k)) : get__default.default(parent, key);\n      const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;\n      if (predicate) {\n        return predicate(validator).run(input);\n      }\n      return Result.ok(input);\n    }\n  };\n}\n__name(whenConstraint, \"whenConstraint\");\nfunction resolveBooleanIs(options, value, isKeyArray) {\n  if (options.is === void 0) {\n    return isKeyArray ? !value.some(val => !val) : Boolean(value);\n  }\n  if (typeof options.is === \"function\") {\n    return options.is(value);\n  }\n  return value === options.is;\n}\n__name(resolveBooleanIs, \"resolveBooleanIs\");\n\n// src/validators/BaseValidator.ts\nvar BaseValidator = class {\n  constructor() {\n    let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.constraints = [];\n    this.isValidationEnabled = null;\n    this.constraints = constraints;\n  }\n  setParent(parent) {\n    this.parent = parent;\n    return this;\n  }\n  get optional() {\n    return new UnionValidator([new LiteralValidator(void 0), this.clone()]);\n  }\n  get nullable() {\n    return new UnionValidator([new LiteralValidator(null), this.clone()]);\n  }\n  get nullish() {\n    return new UnionValidator([new NullishValidator(), this.clone()]);\n  }\n  get array() {\n    return new ArrayValidator(this.clone());\n  }\n  get set() {\n    return new SetValidator(this.clone());\n  }\n  or() {\n    for (var _len = arguments.length, predicates = new Array(_len), _key = 0; _key < _len; _key++) {\n      predicates[_key] = arguments[_key];\n    }\n    return new UnionValidator([this.clone(), ...predicates]);\n  }\n  transform(cb) {\n    return this.addConstraint({\n      run: input => Result.ok(cb(input))\n    });\n  }\n  reshape(cb) {\n    return this.addConstraint({\n      run: cb\n    });\n  }\n  default(value) {\n    return new DefaultValidator(this.clone(), value);\n  }\n  when(key, options) {\n    return this.addConstraint(whenConstraint(key, options, this));\n  }\n  run(value) {\n    let result = this.handle(value);\n    if (result.isErr()) return result;\n    for (const constraint of this.constraints) {\n      result = constraint.run(result.value, this.parent);\n      if (result.isErr()) break;\n    }\n    return result;\n  }\n  parse(value) {\n    if (!this.shouldRunConstraints) {\n      return this.handle(value).unwrap();\n    }\n    return this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());\n  }\n  is(value) {\n    return this.run(value).isOk();\n  }\n  /**\n   * Sets if the validator should also run constraints or just do basic checks.\n   * @param isValidationEnabled Whether this validator should be enabled or disabled. You can pass boolean or a function returning boolean which will be called just before parsing.\n   * Set to `null` to go off of the global configuration.\n   */\n  setValidationEnabled(isValidationEnabled) {\n    const clone = this.clone();\n    clone.isValidationEnabled = isValidationEnabled;\n    return clone;\n  }\n  getValidationEnabled() {\n    return getValue(this.isValidationEnabled);\n  }\n  get shouldRunConstraints() {\n    return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();\n  }\n  clone() {\n    const clone = Reflect.construct(this.constructor, [this.constraints]);\n    clone.isValidationEnabled = this.isValidationEnabled;\n    return clone;\n  }\n  addConstraint(constraint) {\n    const clone = this.clone();\n    clone.constraints = clone.constraints.concat(constraint);\n    return clone;\n  }\n};\n__name(BaseValidator, \"BaseValidator\");\nfunction isUnique(input) {\n  if (input.length < 2) return true;\n  const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);\n  return uniqueArray2.length === input.length;\n}\n__name(isUnique, \"isUnique\");\n\n// src/constraints/util/operators.ts\nfunction lessThan(a, b) {\n  return a < b;\n}\n__name(lessThan, \"lessThan\");\nfunction lessThanOrEqual(a, b) {\n  return a <= b;\n}\n__name(lessThanOrEqual, \"lessThanOrEqual\");\nfunction greaterThan(a, b) {\n  return a > b;\n}\n__name(greaterThan, \"greaterThan\");\nfunction greaterThanOrEqual(a, b) {\n  return a >= b;\n}\n__name(greaterThanOrEqual, \"greaterThanOrEqual\");\nfunction equal(a, b) {\n  return a === b;\n}\n__name(equal, \"equal\");\nfunction notEqual(a, b) {\n  return a !== b;\n}\n__name(notEqual, \"notEqual\");\n\n// src/constraints/ArrayConstraints.ts\nfunction arrayLengthComparator(comparator, name, expected, length) {\n  return {\n    run(input) {\n      return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid Array length\", input, expected));\n    }\n  };\n}\n__name(arrayLengthComparator, \"arrayLengthComparator\");\nfunction arrayLengthLessThan(value) {\n  const expected = `expected.length < ${value}`;\n  return arrayLengthComparator(lessThan, \"s.array(T).lengthLessThan\", expected, value);\n}\n__name(arrayLengthLessThan, \"arrayLengthLessThan\");\nfunction arrayLengthLessThanOrEqual(value) {\n  const expected = `expected.length <= ${value}`;\n  return arrayLengthComparator(lessThanOrEqual, \"s.array(T).lengthLessThanOrEqual\", expected, value);\n}\n__name(arrayLengthLessThanOrEqual, \"arrayLengthLessThanOrEqual\");\nfunction arrayLengthGreaterThan(value) {\n  const expected = `expected.length > ${value}`;\n  return arrayLengthComparator(greaterThan, \"s.array(T).lengthGreaterThan\", expected, value);\n}\n__name(arrayLengthGreaterThan, \"arrayLengthGreaterThan\");\nfunction arrayLengthGreaterThanOrEqual(value) {\n  const expected = `expected.length >= ${value}`;\n  return arrayLengthComparator(greaterThanOrEqual, \"s.array(T).lengthGreaterThanOrEqual\", expected, value);\n}\n__name(arrayLengthGreaterThanOrEqual, \"arrayLengthGreaterThanOrEqual\");\nfunction arrayLengthEqual(value) {\n  const expected = `expected.length === ${value}`;\n  return arrayLengthComparator(equal, \"s.array(T).lengthEqual\", expected, value);\n}\n__name(arrayLengthEqual, \"arrayLengthEqual\");\nfunction arrayLengthNotEqual(value) {\n  const expected = `expected.length !== ${value}`;\n  return arrayLengthComparator(notEqual, \"s.array(T).lengthNotEqual\", expected, value);\n}\n__name(arrayLengthNotEqual, \"arrayLengthNotEqual\");\nfunction arrayLengthRange(start, endBefore) {\n  const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;\n  return {\n    run(input) {\n      return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.array(T).lengthRange\", \"Invalid Array length\", input, expected));\n    }\n  };\n}\n__name(arrayLengthRange, \"arrayLengthRange\");\nfunction arrayLengthRangeInclusive(start, end) {\n  const expected = `expected.length >= ${start} && expected.length <= ${end}`;\n  return {\n    run(input) {\n      return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.array(T).lengthRangeInclusive\", \"Invalid Array length\", input, expected));\n    }\n  };\n}\n__name(arrayLengthRangeInclusive, \"arrayLengthRangeInclusive\");\nfunction arrayLengthRangeExclusive(startAfter, endBefore) {\n  const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;\n  return {\n    run(input) {\n      return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.array(T).lengthRangeExclusive\", \"Invalid Array length\", input, expected));\n    }\n  };\n}\n__name(arrayLengthRangeExclusive, \"arrayLengthRangeExclusive\");\nvar uniqueArray = {\n  run(input) {\n    return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.array(T).unique\", \"Array values are not unique\", input, \"Expected all values to be unique\"));\n  }\n};\n\n// src/lib/errors/CombinedPropertyError.ts\nvar CombinedPropertyError = class extends BaseError {\n  constructor(errors) {\n    super(\"Received one or more errors\");\n    this.errors = errors;\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    if (depth < 0) {\n      return options.stylize(\"[CombinedPropertyError]\", \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1,\n      compact: true\n    };\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const header = `${options.stylize(\"CombinedPropertyError\", \"special\")} (${options.stylize(this.errors.length.toString(), \"number\")})`;\n    const message = options.stylize(this.message, \"regexp\");\n    const errors = this.errors.map(_ref => {\n      let [key, error] = _ref;\n      const property = CombinedPropertyError.formatProperty(key, options);\n      const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\\n/g, padding);\n      return `  input${property}${padding}${body}`;\n    }).join(\"\\n\\n\");\n    return `${header}\n  ${message}\n\n${errors}`;\n  }\n  static formatProperty(key, options) {\n    if (typeof key === \"string\") return options.stylize(`.${key}`, \"symbol\");\n    if (typeof key === \"number\") return `[${options.stylize(key.toString(), \"number\")}]`;\n    return `[${options.stylize(\"Symbol\", \"symbol\")}(${key.description})]`;\n  }\n};\n__name(CombinedPropertyError, \"CombinedPropertyError\");\nvar ValidationError = class extends BaseError {\n  constructor(validator, message, given) {\n    super(message);\n    this.validator = validator;\n    this.given = given;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      validator: this.validator,\n      given: this.given\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const validator = options.stylize(this.validator, \"string\");\n    if (depth < 0) {\n      return options.stylize(`[ValidationError: ${validator}]`, \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1,\n      compact: true\n    };\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const given = util.inspect(this.given, newOptions).replace(/\\n/g, padding);\n    const header = `${options.stylize(\"ValidationError\", \"special\")} > ${validator}`;\n    const message = options.stylize(this.message, \"regexp\");\n    const givenBlock = `\n  ${options.stylize(\"Received:\", \"regexp\")}${padding}${given}`;\n    return `${header}\n  ${message}\n${givenBlock}`;\n  }\n};\n__name(ValidationError, \"ValidationError\");\n\n// src/validators/ArrayValidator.ts\nvar ArrayValidator = class extends BaseValidator {\n  constructor(validator) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.validator = validator;\n  }\n  lengthLessThan(length) {\n    return this.addConstraint(arrayLengthLessThan(length));\n  }\n  lengthLessThanOrEqual(length) {\n    return this.addConstraint(arrayLengthLessThanOrEqual(length));\n  }\n  lengthGreaterThan(length) {\n    return this.addConstraint(arrayLengthGreaterThan(length));\n  }\n  lengthGreaterThanOrEqual(length) {\n    return this.addConstraint(arrayLengthGreaterThanOrEqual(length));\n  }\n  lengthEqual(length) {\n    return this.addConstraint(arrayLengthEqual(length));\n  }\n  lengthNotEqual(length) {\n    return this.addConstraint(arrayLengthNotEqual(length));\n  }\n  lengthRange(start, endBefore) {\n    return this.addConstraint(arrayLengthRange(start, endBefore));\n  }\n  lengthRangeInclusive(startAt, endAt) {\n    return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));\n  }\n  lengthRangeExclusive(startAfter, endBefore) {\n    return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));\n  }\n  get unique() {\n    return this.addConstraint(uniqueArray);\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validator, this.constraints]);\n  }\n  handle(values) {\n    if (!Array.isArray(values)) {\n      return Result.err(new ValidationError(\"s.array(T)\", \"Expected an array\", values));\n    }\n    if (!this.shouldRunConstraints) {\n      return Result.ok(values);\n    }\n    const errors = [];\n    const transformed = [];\n    for (let i = 0; i < values.length; i++) {\n      const result = this.validator.run(values[i]);\n      if (result.isOk()) transformed.push(result.value);else errors.push([i, result.error]);\n    }\n    return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));\n  }\n};\n__name(ArrayValidator, \"ArrayValidator\");\n\n// src/constraints/BigIntConstraints.ts\nfunction bigintComparator(comparator, name, expected, number) {\n  return {\n    run(input) {\n      return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid bigint value\", input, expected));\n    }\n  };\n}\n__name(bigintComparator, \"bigintComparator\");\nfunction bigintLessThan(value) {\n  const expected = `expected < ${value}n`;\n  return bigintComparator(lessThan, \"s.bigint.lessThan\", expected, value);\n}\n__name(bigintLessThan, \"bigintLessThan\");\nfunction bigintLessThanOrEqual(value) {\n  const expected = `expected <= ${value}n`;\n  return bigintComparator(lessThanOrEqual, \"s.bigint.lessThanOrEqual\", expected, value);\n}\n__name(bigintLessThanOrEqual, \"bigintLessThanOrEqual\");\nfunction bigintGreaterThan(value) {\n  const expected = `expected > ${value}n`;\n  return bigintComparator(greaterThan, \"s.bigint.greaterThan\", expected, value);\n}\n__name(bigintGreaterThan, \"bigintGreaterThan\");\nfunction bigintGreaterThanOrEqual(value) {\n  const expected = `expected >= ${value}n`;\n  return bigintComparator(greaterThanOrEqual, \"s.bigint.greaterThanOrEqual\", expected, value);\n}\n__name(bigintGreaterThanOrEqual, \"bigintGreaterThanOrEqual\");\nfunction bigintEqual(value) {\n  const expected = `expected === ${value}n`;\n  return bigintComparator(equal, \"s.bigint.equal\", expected, value);\n}\n__name(bigintEqual, \"bigintEqual\");\nfunction bigintNotEqual(value) {\n  const expected = `expected !== ${value}n`;\n  return bigintComparator(notEqual, \"s.bigint.notEqual\", expected, value);\n}\n__name(bigintNotEqual, \"bigintNotEqual\");\nfunction bigintDivisibleBy(divider) {\n  const expected = `expected % ${divider}n === 0n`;\n  return {\n    run(input) {\n      return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.bigint.divisibleBy\", \"BigInt is not divisible\", input, expected));\n    }\n  };\n}\n__name(bigintDivisibleBy, \"bigintDivisibleBy\");\n\n// src/validators/BigIntValidator.ts\nvar BigIntValidator = class extends BaseValidator {\n  lessThan(number) {\n    return this.addConstraint(bigintLessThan(number));\n  }\n  lessThanOrEqual(number) {\n    return this.addConstraint(bigintLessThanOrEqual(number));\n  }\n  greaterThan(number) {\n    return this.addConstraint(bigintGreaterThan(number));\n  }\n  greaterThanOrEqual(number) {\n    return this.addConstraint(bigintGreaterThanOrEqual(number));\n  }\n  equal(number) {\n    return this.addConstraint(bigintEqual(number));\n  }\n  notEqual(number) {\n    return this.addConstraint(bigintNotEqual(number));\n  }\n  get positive() {\n    return this.greaterThanOrEqual(0n);\n  }\n  get negative() {\n    return this.lessThan(0n);\n  }\n  divisibleBy(number) {\n    return this.addConstraint(bigintDivisibleBy(number));\n  }\n  get abs() {\n    return this.transform(value => value < 0 ? -value : value);\n  }\n  intN(bits) {\n    return this.transform(value => BigInt.asIntN(bits, value));\n  }\n  uintN(bits) {\n    return this.transform(value => BigInt.asUintN(bits, value));\n  }\n  handle(value) {\n    return typeof value === \"bigint\" ? Result.ok(value) : Result.err(new ValidationError(\"s.bigint\", \"Expected a bigint primitive\", value));\n  }\n};\n__name(BigIntValidator, \"BigIntValidator\");\n\n// src/constraints/BooleanConstraints.ts\nvar booleanTrue = {\n  run(input) {\n    return input ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.boolean.true\", \"Invalid boolean value\", input, \"true\"));\n  }\n};\nvar booleanFalse = {\n  run(input) {\n    return input ? Result.err(new ExpectedConstraintError(\"s.boolean.false\", \"Invalid boolean value\", input, \"false\")) : Result.ok(input);\n  }\n};\n\n// src/validators/BooleanValidator.ts\nvar BooleanValidator = class extends BaseValidator {\n  get true() {\n    return this.addConstraint(booleanTrue);\n  }\n  get false() {\n    return this.addConstraint(booleanFalse);\n  }\n  equal(value) {\n    return value ? this.true : this.false;\n  }\n  notEqual(value) {\n    return value ? this.false : this.true;\n  }\n  handle(value) {\n    return typeof value === \"boolean\" ? Result.ok(value) : Result.err(new ValidationError(\"s.boolean\", \"Expected a boolean primitive\", value));\n  }\n};\n__name(BooleanValidator, \"BooleanValidator\");\n\n// src/constraints/DateConstraints.ts\nfunction dateComparator(comparator, name, expected, number) {\n  return {\n    run(input) {\n      return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid Date value\", input, expected));\n    }\n  };\n}\n__name(dateComparator, \"dateComparator\");\nfunction dateLessThan(value) {\n  const expected = `expected < ${value.toISOString()}`;\n  return dateComparator(lessThan, \"s.date.lessThan\", expected, value.getTime());\n}\n__name(dateLessThan, \"dateLessThan\");\nfunction dateLessThanOrEqual(value) {\n  const expected = `expected <= ${value.toISOString()}`;\n  return dateComparator(lessThanOrEqual, \"s.date.lessThanOrEqual\", expected, value.getTime());\n}\n__name(dateLessThanOrEqual, \"dateLessThanOrEqual\");\nfunction dateGreaterThan(value) {\n  const expected = `expected > ${value.toISOString()}`;\n  return dateComparator(greaterThan, \"s.date.greaterThan\", expected, value.getTime());\n}\n__name(dateGreaterThan, \"dateGreaterThan\");\nfunction dateGreaterThanOrEqual(value) {\n  const expected = `expected >= ${value.toISOString()}`;\n  return dateComparator(greaterThanOrEqual, \"s.date.greaterThanOrEqual\", expected, value.getTime());\n}\n__name(dateGreaterThanOrEqual, \"dateGreaterThanOrEqual\");\nfunction dateEqual(value) {\n  const expected = `expected === ${value.toISOString()}`;\n  return dateComparator(equal, \"s.date.equal\", expected, value.getTime());\n}\n__name(dateEqual, \"dateEqual\");\nfunction dateNotEqual(value) {\n  const expected = `expected !== ${value.toISOString()}`;\n  return dateComparator(notEqual, \"s.date.notEqual\", expected, value.getTime());\n}\n__name(dateNotEqual, \"dateNotEqual\");\nvar dateInvalid = {\n  run(input) {\n    return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.date.invalid\", \"Invalid Date value\", input, \"expected === NaN\"));\n  }\n};\nvar dateValid = {\n  run(input) {\n    return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError(\"s.date.valid\", \"Invalid Date value\", input, \"expected !== NaN\")) : Result.ok(input);\n  }\n};\n\n// src/validators/DateValidator.ts\nvar DateValidator = class extends BaseValidator {\n  lessThan(date) {\n    return this.addConstraint(dateLessThan(new Date(date)));\n  }\n  lessThanOrEqual(date) {\n    return this.addConstraint(dateLessThanOrEqual(new Date(date)));\n  }\n  greaterThan(date) {\n    return this.addConstraint(dateGreaterThan(new Date(date)));\n  }\n  greaterThanOrEqual(date) {\n    return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));\n  }\n  equal(date) {\n    const resolved = new Date(date);\n    return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));\n  }\n  notEqual(date) {\n    const resolved = new Date(date);\n    return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));\n  }\n  get valid() {\n    return this.addConstraint(dateValid);\n  }\n  get invalid() {\n    return this.addConstraint(dateInvalid);\n  }\n  handle(value) {\n    return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError(\"s.date\", \"Expected a Date\", value));\n  }\n};\n__name(DateValidator, \"DateValidator\");\nvar ExpectedValidationError = class extends ValidationError {\n  constructor(validator, message, given, expected) {\n    super(validator, message, given);\n    this.expected = expected;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      validator: this.validator,\n      given: this.given,\n      expected: this.expected\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const validator = options.stylize(this.validator, \"string\");\n    if (depth < 0) {\n      return options.stylize(`[ExpectedValidationError: ${validator}]`, \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1\n    };\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const expected = util.inspect(this.expected, newOptions).replace(/\\n/g, padding);\n    const given = util.inspect(this.given, newOptions).replace(/\\n/g, padding);\n    const header = `${options.stylize(\"ExpectedValidationError\", \"special\")} > ${validator}`;\n    const message = options.stylize(this.message, \"regexp\");\n    const expectedBlock = `\n  ${options.stylize(\"Expected:\", \"string\")}${padding}${expected}`;\n    const givenBlock = `\n  ${options.stylize(\"Received:\", \"regexp\")}${padding}${given}`;\n    return `${header}\n  ${message}\n${expectedBlock}\n${givenBlock}`;\n  }\n};\n__name(ExpectedValidationError, \"ExpectedValidationError\");\n\n// src/validators/InstanceValidator.ts\nvar InstanceValidator = class extends BaseValidator {\n  constructor(expected) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.expected = expected;\n  }\n  handle(value) {\n    return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError(\"s.instance(V)\", \"Expected\", value, this.expected));\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.expected, this.constraints]);\n  }\n};\n__name(InstanceValidator, \"InstanceValidator\");\n\n// src/validators/LiteralValidator.ts\nvar LiteralValidator = class extends BaseValidator {\n  constructor(literal) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.expected = literal;\n  }\n  handle(value) {\n    return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError(\"s.literal(V)\", \"Expected values to be equals\", value, this.expected));\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.expected, this.constraints]);\n  }\n};\n__name(LiteralValidator, \"LiteralValidator\");\n\n// src/validators/NeverValidator.ts\nvar NeverValidator = class extends BaseValidator {\n  handle(value) {\n    return Result.err(new ValidationError(\"s.never\", \"Expected a value to not be passed\", value));\n  }\n};\n__name(NeverValidator, \"NeverValidator\");\n\n// src/validators/NullishValidator.ts\nvar NullishValidator = class extends BaseValidator {\n  handle(value) {\n    return value === void 0 || value === null ? Result.ok(value) : Result.err(new ValidationError(\"s.nullish\", \"Expected undefined or null\", value));\n  }\n};\n__name(NullishValidator, \"NullishValidator\");\n\n// src/constraints/NumberConstraints.ts\nfunction numberComparator(comparator, name, expected, number) {\n  return {\n    run(input) {\n      return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid number value\", input, expected));\n    }\n  };\n}\n__name(numberComparator, \"numberComparator\");\nfunction numberLessThan(value) {\n  const expected = `expected < ${value}`;\n  return numberComparator(lessThan, \"s.number.lessThan\", expected, value);\n}\n__name(numberLessThan, \"numberLessThan\");\nfunction numberLessThanOrEqual(value) {\n  const expected = `expected <= ${value}`;\n  return numberComparator(lessThanOrEqual, \"s.number.lessThanOrEqual\", expected, value);\n}\n__name(numberLessThanOrEqual, \"numberLessThanOrEqual\");\nfunction numberGreaterThan(value) {\n  const expected = `expected > ${value}`;\n  return numberComparator(greaterThan, \"s.number.greaterThan\", expected, value);\n}\n__name(numberGreaterThan, \"numberGreaterThan\");\nfunction numberGreaterThanOrEqual(value) {\n  const expected = `expected >= ${value}`;\n  return numberComparator(greaterThanOrEqual, \"s.number.greaterThanOrEqual\", expected, value);\n}\n__name(numberGreaterThanOrEqual, \"numberGreaterThanOrEqual\");\nfunction numberEqual(value) {\n  const expected = `expected === ${value}`;\n  return numberComparator(equal, \"s.number.equal\", expected, value);\n}\n__name(numberEqual, \"numberEqual\");\nfunction numberNotEqual(value) {\n  const expected = `expected !== ${value}`;\n  return numberComparator(notEqual, \"s.number.notEqual\", expected, value);\n}\n__name(numberNotEqual, \"numberNotEqual\");\nvar numberInt = {\n  run(input) {\n    return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.number.int\", \"Given value is not an integer\", input, \"Number.isInteger(expected) to be true\"));\n  }\n};\nvar numberSafeInt = {\n  run(input) {\n    return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.number.safeInt\", \"Given value is not a safe integer\", input, \"Number.isSafeInteger(expected) to be true\"));\n  }\n};\nvar numberFinite = {\n  run(input) {\n    return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.number.finite\", \"Given value is not finite\", input, \"Number.isFinite(expected) to be true\"));\n  }\n};\nvar numberNaN = {\n  run(input) {\n    return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.number.equal(NaN)\", \"Invalid number value\", input, \"expected === NaN\"));\n  }\n};\nvar numberNotNaN = {\n  run(input) {\n    return Number.isNaN(input) ? Result.err(new ExpectedConstraintError(\"s.number.notEqual(NaN)\", \"Invalid number value\", input, \"expected !== NaN\")) : Result.ok(input);\n  }\n};\nfunction numberDivisibleBy(divider) {\n  const expected = `expected % ${divider} === 0`;\n  return {\n    run(input) {\n      return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.number.divisibleBy\", \"Number is not divisible\", input, expected));\n    }\n  };\n}\n__name(numberDivisibleBy, \"numberDivisibleBy\");\n\n// src/validators/NumberValidator.ts\nvar NumberValidator = class extends BaseValidator {\n  lessThan(number) {\n    return this.addConstraint(numberLessThan(number));\n  }\n  lessThanOrEqual(number) {\n    return this.addConstraint(numberLessThanOrEqual(number));\n  }\n  greaterThan(number) {\n    return this.addConstraint(numberGreaterThan(number));\n  }\n  greaterThanOrEqual(number) {\n    return this.addConstraint(numberGreaterThanOrEqual(number));\n  }\n  equal(number) {\n    return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));\n  }\n  notEqual(number) {\n    return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));\n  }\n  get int() {\n    return this.addConstraint(numberInt);\n  }\n  get safeInt() {\n    return this.addConstraint(numberSafeInt);\n  }\n  get finite() {\n    return this.addConstraint(numberFinite);\n  }\n  get positive() {\n    return this.greaterThanOrEqual(0);\n  }\n  get negative() {\n    return this.lessThan(0);\n  }\n  divisibleBy(divider) {\n    return this.addConstraint(numberDivisibleBy(divider));\n  }\n  get abs() {\n    return this.transform(Math.abs);\n  }\n  get sign() {\n    return this.transform(Math.sign);\n  }\n  get trunc() {\n    return this.transform(Math.trunc);\n  }\n  get floor() {\n    return this.transform(Math.floor);\n  }\n  get fround() {\n    return this.transform(Math.fround);\n  }\n  get round() {\n    return this.transform(Math.round);\n  }\n  get ceil() {\n    return this.transform(Math.ceil);\n  }\n  handle(value) {\n    return typeof value === \"number\" ? Result.ok(value) : Result.err(new ValidationError(\"s.number\", \"Expected a number primitive\", value));\n  }\n};\n__name(NumberValidator, \"NumberValidator\");\n\n// src/lib/errors/MissingPropertyError.ts\nvar MissingPropertyError = class extends BaseError {\n  constructor(property) {\n    super(\"A required property is missing\");\n    this.property = property;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      property: this.property\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const property = options.stylize(this.property.toString(), \"string\");\n    if (depth < 0) {\n      return options.stylize(`[MissingPropertyError: ${property}]`, \"special\");\n    }\n    const header = `${options.stylize(\"MissingPropertyError\", \"special\")} > ${property}`;\n    const message = options.stylize(this.message, \"regexp\");\n    return `${header}\n  ${message}`;\n  }\n};\n__name(MissingPropertyError, \"MissingPropertyError\");\nvar UnknownPropertyError = class extends BaseError {\n  constructor(property, value) {\n    super(\"Received unexpected property\");\n    this.property = property;\n    this.value = value;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      property: this.property,\n      value: this.value\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const property = options.stylize(this.property.toString(), \"string\");\n    if (depth < 0) {\n      return options.stylize(`[UnknownPropertyError: ${property}]`, \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1,\n      compact: true\n    };\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const given = util.inspect(this.value, newOptions).replace(/\\n/g, padding);\n    const header = `${options.stylize(\"UnknownPropertyError\", \"special\")} > ${property}`;\n    const message = options.stylize(this.message, \"regexp\");\n    const givenBlock = `\n  ${options.stylize(\"Received:\", \"regexp\")}${padding}${given}`;\n    return `${header}\n  ${message}\n${givenBlock}`;\n  }\n};\n__name(UnknownPropertyError, \"UnknownPropertyError\");\n\n// src/validators/DefaultValidator.ts\nvar DefaultValidator = class extends BaseValidator {\n  constructor(validator, value) {\n    let constraints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(constraints);\n    this.validator = validator;\n    this.defaultValue = value;\n  }\n  default(value) {\n    const clone = this.clone();\n    clone.defaultValue = value;\n    return clone;\n  }\n  handle(value) {\n    return typeof value === \"undefined\" ? Result.ok(getValue(this.defaultValue)) : this.validator[\"handle\"](value);\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);\n  }\n};\n__name(DefaultValidator, \"DefaultValidator\");\n\n// src/lib/errors/CombinedError.ts\nvar CombinedError = class extends BaseError {\n  constructor(errors) {\n    super(\"Received one or more errors\");\n    this.errors = errors;\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    if (depth < 0) {\n      return options.stylize(\"[CombinedError]\", \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1,\n      compact: true\n    };\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const header = `${options.stylize(\"CombinedError\", \"special\")} (${options.stylize(this.errors.length.toString(), \"number\")})`;\n    const message = options.stylize(this.message, \"regexp\");\n    const errors = this.errors.map((error, i) => {\n      const index = options.stylize((i + 1).toString(), \"number\");\n      const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\\n/g, padding);\n      return `  ${index} ${body}`;\n    }).join(\"\\n\\n\");\n    return `${header}\n  ${message}\n\n${errors}`;\n  }\n};\n__name(CombinedError, \"CombinedError\");\n\n// src/validators/UnionValidator.ts\nvar UnionValidator = class extends BaseValidator {\n  constructor(validators) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.validators = validators;\n  }\n  get optional() {\n    if (this.validators.length === 0) return new UnionValidator([new LiteralValidator(void 0)], this.constraints);\n    const [validator] = this.validators;\n    if (validator instanceof LiteralValidator) {\n      if (validator.expected === void 0) return this.clone();\n      if (validator.expected === null) {\n        return new UnionValidator([new NullishValidator(), ...this.validators.slice(1)], this.constraints);\n      }\n    } else if (validator instanceof NullishValidator) {\n      return this.clone();\n    }\n    return new UnionValidator([new LiteralValidator(void 0), ...this.validators]);\n  }\n  get required() {\n    if (this.validators.length === 0) return this.clone();\n    const [validator] = this.validators;\n    if (validator instanceof LiteralValidator) {\n      if (validator.expected === void 0) return new UnionValidator(this.validators.slice(1), this.constraints);\n    } else if (validator instanceof NullishValidator) {\n      return new UnionValidator([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);\n    }\n    return this.clone();\n  }\n  get nullable() {\n    if (this.validators.length === 0) return new UnionValidator([new LiteralValidator(null)], this.constraints);\n    const [validator] = this.validators;\n    if (validator instanceof LiteralValidator) {\n      if (validator.expected === null) return this.clone();\n      if (validator.expected === void 0) {\n        return new UnionValidator([new NullishValidator(), ...this.validators.slice(1)], this.constraints);\n      }\n    } else if (validator instanceof NullishValidator) {\n      return this.clone();\n    }\n    return new UnionValidator([new LiteralValidator(null), ...this.validators]);\n  }\n  get nullish() {\n    if (this.validators.length === 0) return new UnionValidator([new NullishValidator()], this.constraints);\n    const [validator] = this.validators;\n    if (validator instanceof LiteralValidator) {\n      if (validator.expected === null || validator.expected === void 0) {\n        return new UnionValidator([new NullishValidator(), ...this.validators.slice(1)], this.constraints);\n      }\n    } else if (validator instanceof NullishValidator) {\n      return this.clone();\n    }\n    return new UnionValidator([new NullishValidator(), ...this.validators]);\n  }\n  or() {\n    for (var _len2 = arguments.length, predicates = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      predicates[_key2] = arguments[_key2];\n    }\n    return new UnionValidator([...this.validators, ...predicates]);\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validators, this.constraints]);\n  }\n  handle(value) {\n    const errors = [];\n    for (const validator of this.validators) {\n      const result = validator.run(value);\n      if (result.isOk()) return result;\n      errors.push(result.error);\n    }\n    return Result.err(new CombinedError(errors));\n  }\n};\n__name(UnionValidator, \"UnionValidator\");\n\n// src/validators/ObjectValidator.ts\nvar ObjectValidator = class extends BaseValidator {\n  constructor(shape) {\n    let strategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let constraints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(constraints);\n    this.keys = [];\n    this.requiredKeys = /* @__PURE__ */new Map();\n    this.possiblyUndefinedKeys = /* @__PURE__ */new Map();\n    this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */new Map();\n    this.shape = shape;\n    this.strategy = strategy;\n    switch (this.strategy) {\n      case 0 /* Ignore */:\n        this.handleStrategy = value => this.handleIgnoreStrategy(value);\n        break;\n      case 1 /* Strict */:\n        {\n          this.handleStrategy = value => this.handleStrictStrategy(value);\n          break;\n        }\n      case 2 /* Passthrough */:\n        this.handleStrategy = value => this.handlePassthroughStrategy(value);\n        break;\n    }\n    const shapeEntries = Object.entries(shape);\n    this.keys = shapeEntries.map(_ref2 => {\n      let [key] = _ref2;\n      return key;\n    });\n    for (const [key, validator] of shapeEntries) {\n      if (validator instanceof UnionValidator) {\n        const [possiblyLiteralOrNullishPredicate] = validator[\"validators\"];\n        if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {\n          this.possiblyUndefinedKeys.set(key, validator);\n        } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {\n          if (possiblyLiteralOrNullishPredicate.expected === void 0) {\n            this.possiblyUndefinedKeys.set(key, validator);\n          } else {\n            this.requiredKeys.set(key, validator);\n          }\n        } else if (validator instanceof DefaultValidator) {\n          this.possiblyUndefinedKeysWithDefaults.set(key, validator);\n        } else {\n          this.requiredKeys.set(key, validator);\n        }\n      } else if (validator instanceof NullishValidator) {\n        this.possiblyUndefinedKeys.set(key, validator);\n      } else if (validator instanceof LiteralValidator) {\n        if (validator.expected === void 0) {\n          this.possiblyUndefinedKeys.set(key, validator);\n        } else {\n          this.requiredKeys.set(key, validator);\n        }\n      } else if (validator instanceof DefaultValidator) {\n        this.possiblyUndefinedKeysWithDefaults.set(key, validator);\n      } else {\n        this.requiredKeys.set(key, validator);\n      }\n    }\n  }\n  get strict() {\n    return Reflect.construct(this.constructor, [this.shape, 1 /* Strict */, this.constraints]);\n  }\n  get ignore() {\n    return Reflect.construct(this.constructor, [this.shape, 0 /* Ignore */, this.constraints]);\n  }\n  get passthrough() {\n    return Reflect.construct(this.constructor, [this.shape, 2 /* Passthrough */, this.constraints]);\n  }\n  get partial() {\n    const shape = Object.fromEntries(this.keys.map(key => [key, this.shape[key].optional]));\n    return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n  }\n  get required() {\n    const shape = Object.fromEntries(this.keys.map(key => {\n      let validator = this.shape[key];\n      if (validator instanceof UnionValidator) validator = validator.required;\n      return [key, validator];\n    }));\n    return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n  }\n  extend(schema) {\n    const shape = {\n      ...this.shape,\n      ...(schema instanceof ObjectValidator ? schema.shape : schema)\n    };\n    return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n  }\n  pick(keys) {\n    const shape = Object.fromEntries(keys.filter(key => this.keys.includes(key)).map(key => [key, this.shape[key]]));\n    return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n  }\n  omit(keys) {\n    const shape = Object.fromEntries(this.keys.filter(key => !keys.includes(key)).map(key => [key, this.shape[key]]));\n    return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n  }\n  handle(value) {\n    const typeOfValue = typeof value;\n    if (typeOfValue !== \"object\") {\n      return Result.err(new ValidationError(\"s.object(T)\", `Expected the value to be an object, but received ${typeOfValue} instead`, value));\n    }\n    if (value === null) {\n      return Result.err(new ValidationError(\"s.object(T)\", \"Expected the value to not be null\", value));\n    }\n    if (Array.isArray(value)) {\n      return Result.err(new ValidationError(\"s.object(T)\", \"Expected the value to not be an array\", value));\n    }\n    if (!this.shouldRunConstraints) {\n      return Result.ok(value);\n    }\n    for (const predicate of Object.values(this.shape)) {\n      predicate.setParent(this.parent ?? value);\n    }\n    return this.handleStrategy(value);\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);\n  }\n  handleIgnoreStrategy(value) {\n    const errors = [];\n    const finalObject = {};\n    const inputEntries = new Map(Object.entries(value));\n    const runPredicate = /* @__PURE__ */__name((key, predicate) => {\n      const result = predicate.run(value[key]);\n      if (result.isOk()) {\n        finalObject[key] = result.value;\n      } else {\n        const error = result.error;\n        errors.push([key, error]);\n      }\n    }, \"runPredicate\");\n    for (const [key, predicate] of this.requiredKeys) {\n      if (inputEntries.delete(key)) {\n        runPredicate(key, predicate);\n      } else {\n        errors.push([key, new MissingPropertyError(key)]);\n      }\n    }\n    for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {\n      inputEntries.delete(key);\n      runPredicate(key, validator);\n    }\n    if (inputEntries.size === 0) {\n      return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));\n    }\n    const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;\n    if (checkInputEntriesInsteadOfSchemaKeys) {\n      for (const [key] of inputEntries) {\n        const predicate = this.possiblyUndefinedKeys.get(key);\n        if (predicate) {\n          runPredicate(key, predicate);\n        }\n      }\n    } else {\n      for (const [key, predicate] of this.possiblyUndefinedKeys) {\n        if (inputEntries.delete(key)) {\n          runPredicate(key, predicate);\n        }\n      }\n    }\n    return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));\n  }\n  handleStrictStrategy(value) {\n    const errors = [];\n    const finalResult = {};\n    const inputEntries = new Map(Object.entries(value));\n    const runPredicate = /* @__PURE__ */__name((key, predicate) => {\n      const result = predicate.run(value[key]);\n      if (result.isOk()) {\n        finalResult[key] = result.value;\n      } else {\n        const error = result.error;\n        errors.push([key, error]);\n      }\n    }, \"runPredicate\");\n    for (const [key, predicate] of this.requiredKeys) {\n      if (inputEntries.delete(key)) {\n        runPredicate(key, predicate);\n      } else {\n        errors.push([key, new MissingPropertyError(key)]);\n      }\n    }\n    for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {\n      inputEntries.delete(key);\n      runPredicate(key, validator);\n    }\n    for (const [key, predicate] of this.possiblyUndefinedKeys) {\n      if (inputEntries.size === 0) {\n        break;\n      }\n      if (inputEntries.delete(key)) {\n        runPredicate(key, predicate);\n      }\n    }\n    if (inputEntries.size !== 0) {\n      for (const [key, value2] of inputEntries.entries()) {\n        errors.push([key, new UnknownPropertyError(key, value2)]);\n      }\n    }\n    return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors));\n  }\n  handlePassthroughStrategy(value) {\n    const result = this.handleIgnoreStrategy(value);\n    return result.isErr() ? result : Result.ok({\n      ...value,\n      ...result.value\n    });\n  }\n};\n__name(ObjectValidator, \"ObjectValidator\");\n\n// src/validators/PassthroughValidator.ts\nvar PassthroughValidator = class extends BaseValidator {\n  handle(value) {\n    return Result.ok(value);\n  }\n};\n__name(PassthroughValidator, \"PassthroughValidator\");\n\n// src/validators/RecordValidator.ts\nvar RecordValidator = class extends BaseValidator {\n  constructor(validator) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.validator = validator;\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validator, this.constraints]);\n  }\n  handle(value) {\n    if (typeof value !== \"object\") {\n      return Result.err(new ValidationError(\"s.record(T)\", \"Expected an object\", value));\n    }\n    if (value === null) {\n      return Result.err(new ValidationError(\"s.record(T)\", \"Expected the value to not be null\", value));\n    }\n    if (Array.isArray(value)) {\n      return Result.err(new ValidationError(\"s.record(T)\", \"Expected the value to not be an array\", value));\n    }\n    if (!this.shouldRunConstraints) {\n      return Result.ok(value);\n    }\n    const errors = [];\n    const transformed = {};\n    for (const [key, val] of Object.entries(value)) {\n      const result = this.validator.run(val);\n      if (result.isOk()) transformed[key] = result.value;else errors.push([key, result.error]);\n    }\n    return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));\n  }\n};\n__name(RecordValidator, \"RecordValidator\");\n\n// src/validators/SetValidator.ts\nvar SetValidator = class extends BaseValidator {\n  constructor(validator) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.validator = validator;\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validator, this.constraints]);\n  }\n  handle(values) {\n    if (!(values instanceof Set)) {\n      return Result.err(new ValidationError(\"s.set(T)\", \"Expected a set\", values));\n    }\n    if (!this.shouldRunConstraints) {\n      return Result.ok(values);\n    }\n    const errors = [];\n    const transformed = /* @__PURE__ */new Set();\n    for (const value of values) {\n      const result = this.validator.run(value);\n      if (result.isOk()) transformed.add(result.value);else errors.push(result.error);\n    }\n    return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors));\n  }\n};\n__name(SetValidator, \"SetValidator\");\n\n// src/constraints/util/emailValidator.ts\nvar accountRegex = /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")$/;\nfunction validateEmail(email) {\n  if (!email) return false;\n  const atIndex = email.indexOf(\"@\");\n  if (atIndex === -1) return false;\n  if (atIndex > 64) return false;\n  const domainIndex = atIndex + 1;\n  if (email.includes(\"@\", domainIndex)) return false;\n  if (email.length - domainIndex > 255) return false;\n  let dotIndex = email.indexOf(\".\", domainIndex);\n  if (dotIndex === -1) return false;\n  let lastDotIndex = domainIndex;\n  do {\n    if (dotIndex - lastDotIndex > 63) return false;\n    lastDotIndex = dotIndex + 1;\n  } while ((dotIndex = email.indexOf(\".\", lastDotIndex)) !== -1);\n  if (email.length - lastDotIndex > 63) return false;\n  return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));\n}\n__name(validateEmail, \"validateEmail\");\nfunction validateEmailDomain(domain) {\n  try {\n    return new URL(`http://${domain}`).hostname === domain;\n  } catch {\n    return false;\n  }\n}\n__name(validateEmailDomain, \"validateEmailDomain\");\n\n// src/constraints/util/net.ts\nvar v4Seg = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nvar v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nvar IPv4Reg = new RegExp(`^${v4Str}$`);\nvar v6Seg = \"(?:[0-9a-fA-F]{1,4})\";\nvar IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);\nfunction isIPv4(s2) {\n  return IPv4Reg.test(s2);\n}\n__name(isIPv4, \"isIPv4\");\nfunction isIPv6(s2) {\n  return IPv6Reg.test(s2);\n}\n__name(isIPv6, \"isIPv6\");\nfunction isIP(s2) {\n  if (isIPv4(s2)) return 4;\n  if (isIPv6(s2)) return 6;\n  return 0;\n}\n__name(isIP, \"isIP\");\n\n// src/constraints/util/phoneValidator.ts\nvar phoneNumberRegex = /^((?:\\+|0{0,2})\\d{1,2}\\s?)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}$/;\nfunction validatePhoneNumber(input) {\n  return phoneNumberRegex.test(input);\n}\n__name(validatePhoneNumber, \"validatePhoneNumber\");\nvar MultiplePossibilitiesConstraintError = class extends BaseConstraintError {\n  constructor(constraint, message, given, expected) {\n    super(constraint, message, given);\n    this.expected = expected;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      constraint: this.constraint,\n      given: this.given,\n      expected: this.expected\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const constraint = options.stylize(this.constraint, \"string\");\n    if (depth < 0) {\n      return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, \"special\");\n    }\n    const newOptions = {\n      ...options,\n      depth: options.depth === null ? null : options.depth - 1\n    };\n    const verticalLine = options.stylize(\"|\", \"undefined\");\n    const padding = `\n  ${verticalLine} `;\n    const given = util.inspect(this.given, newOptions).replace(/\\n/g, padding);\n    const header = `${options.stylize(\"MultiplePossibilitiesConstraintError\", \"special\")} > ${constraint}`;\n    const message = options.stylize(this.message, \"regexp\");\n    const expectedPadding = `\n  ${verticalLine} - `;\n    const expectedBlock = `\n  ${options.stylize(\"Expected any of the following:\", \"string\")}${expectedPadding}${this.expected.map(possible => options.stylize(possible, \"boolean\")).join(expectedPadding)}`;\n    const givenBlock = `\n  ${options.stylize(\"Received:\", \"regexp\")}${padding}${given}`;\n    return `${header}\n  ${message}\n${expectedBlock}\n${givenBlock}`;\n  }\n};\n__name(MultiplePossibilitiesConstraintError, \"MultiplePossibilitiesConstraintError\");\n\n// src/constraints/util/common/combinedResultFn.ts\nfunction combinedErrorFn() {\n  for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    fns[_key3] = arguments[_key3];\n  }\n  switch (fns.length) {\n    case 0:\n      return () => null;\n    case 1:\n      return fns[0];\n    case 2:\n      {\n        const [fn0, fn1] = fns;\n        return function () {\n          return fn0(...arguments) || fn1(...arguments);\n        };\n      }\n    default:\n      {\n        return function () {\n          for (const fn of fns) {\n            const result = fn(...arguments);\n            if (result) return result;\n          }\n          return null;\n        };\n      }\n  }\n}\n__name(combinedErrorFn, \"combinedErrorFn\");\n\n// src/constraints/util/urlValidators.ts\nfunction createUrlValidators(options) {\n  const fns = [];\n  if (options?.allowedProtocols?.length) fns.push(allowedProtocolsFn(options.allowedProtocols));\n  if (options?.allowedDomains?.length) fns.push(allowedDomainsFn(options.allowedDomains));\n  return combinedErrorFn(...fns);\n}\n__name(createUrlValidators, \"createUrlValidators\");\nfunction allowedProtocolsFn(allowedProtocols) {\n  return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError(\"s.string.url\", \"Invalid URL protocol\", input, allowedProtocols);\n}\n__name(allowedProtocolsFn, \"allowedProtocolsFn\");\nfunction allowedDomainsFn(allowedDomains) {\n  return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError(\"s.string.url\", \"Invalid URL domain\", input, allowedDomains);\n}\n__name(allowedDomainsFn, \"allowedDomainsFn\");\n\n// src/constraints/StringConstraints.ts\nfunction stringLengthComparator(comparator, name, expected, length) {\n  return {\n    run(input) {\n      return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid string length\", input, expected));\n    }\n  };\n}\n__name(stringLengthComparator, \"stringLengthComparator\");\nfunction stringLengthLessThan(length) {\n  const expected = `expected.length < ${length}`;\n  return stringLengthComparator(lessThan, \"s.string.lengthLessThan\", expected, length);\n}\n__name(stringLengthLessThan, \"stringLengthLessThan\");\nfunction stringLengthLessThanOrEqual(length) {\n  const expected = `expected.length <= ${length}`;\n  return stringLengthComparator(lessThanOrEqual, \"s.string.lengthLessThanOrEqual\", expected, length);\n}\n__name(stringLengthLessThanOrEqual, \"stringLengthLessThanOrEqual\");\nfunction stringLengthGreaterThan(length) {\n  const expected = `expected.length > ${length}`;\n  return stringLengthComparator(greaterThan, \"s.string.lengthGreaterThan\", expected, length);\n}\n__name(stringLengthGreaterThan, \"stringLengthGreaterThan\");\nfunction stringLengthGreaterThanOrEqual(length) {\n  const expected = `expected.length >= ${length}`;\n  return stringLengthComparator(greaterThanOrEqual, \"s.string.lengthGreaterThanOrEqual\", expected, length);\n}\n__name(stringLengthGreaterThanOrEqual, \"stringLengthGreaterThanOrEqual\");\nfunction stringLengthEqual(length) {\n  const expected = `expected.length === ${length}`;\n  return stringLengthComparator(equal, \"s.string.lengthEqual\", expected, length);\n}\n__name(stringLengthEqual, \"stringLengthEqual\");\nfunction stringLengthNotEqual(length) {\n  const expected = `expected.length !== ${length}`;\n  return stringLengthComparator(notEqual, \"s.string.lengthNotEqual\", expected, length);\n}\n__name(stringLengthNotEqual, \"stringLengthNotEqual\");\nfunction stringEmail() {\n  return {\n    run(input) {\n      return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.string.email\", \"Invalid email address\", input, \"expected to be an email address\"));\n    }\n  };\n}\n__name(stringEmail, \"stringEmail\");\nfunction stringRegexValidator(type, expected, regex) {\n  return {\n    run(input) {\n      return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, \"Invalid string format\", input, expected));\n    }\n  };\n}\n__name(stringRegexValidator, \"stringRegexValidator\");\nfunction stringUrl(options) {\n  const validatorFn = createUrlValidators(options);\n  return {\n    run(input) {\n      let url;\n      try {\n        url = new URL(input);\n      } catch {\n        return Result.err(new ExpectedConstraintError(\"s.string.url\", \"Invalid URL\", input, \"expected to match an URL\"));\n      }\n      const validatorFnResult = validatorFn(input, url);\n      if (validatorFnResult === null) return Result.ok(input);\n      return Result.err(validatorFnResult);\n    }\n  };\n}\n__name(stringUrl, \"stringUrl\");\nfunction stringIp(version) {\n  const ipVersion = version ? `v${version}` : \"\";\n  const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;\n  const name = `s.string.ip${ipVersion}`;\n  const message = `Invalid IP${ipVersion} address`;\n  const expected = `expected to be an IP${ipVersion} address`;\n  return {\n    run(input) {\n      return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));\n    }\n  };\n}\n__name(stringIp, \"stringIp\");\nfunction stringRegex(regex) {\n  return stringRegexValidator(\"s.string.regex\", `expected ${regex}.test(expected) to be true`, regex);\n}\n__name(stringRegex, \"stringRegex\");\nfunction stringUuid() {\n  let {\n    version = 4,\n    nullable = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  version ?? (version = \"1-5\");\n  const regex = new RegExp(`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? \"|00000000-0000-0000-0000-000000000000\" : \"\"})$`, \"i\");\n  const expected = `expected to match UUID${typeof version === \"number\" ? `v${version}` : ` in range of ${version}`}`;\n  return stringRegexValidator(\"s.string.uuid\", expected, regex);\n}\n__name(stringUuid, \"stringUuid\");\nfunction stringDate() {\n  return {\n    run(input) {\n      const time = Date.parse(input);\n      return Number.isNaN(time) ? Result.err(new ExpectedConstraintError(\"s.string.date\", \"Invalid date string\", input, \"expected to be a valid date string (in the ISO 8601 or ECMA-262 format)\")) : Result.ok(input);\n    }\n  };\n}\n__name(stringDate, \"stringDate\");\nfunction stringPhone() {\n  return {\n    run(input) {\n      return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.string.phone\", \"Invalid phone number\", input, \"expected to be a phone number\"));\n    }\n  };\n}\n__name(stringPhone, \"stringPhone\");\n\n// src/validators/StringValidator.ts\nvar StringValidator = class extends BaseValidator {\n  lengthLessThan(length) {\n    return this.addConstraint(stringLengthLessThan(length));\n  }\n  lengthLessThanOrEqual(length) {\n    return this.addConstraint(stringLengthLessThanOrEqual(length));\n  }\n  lengthGreaterThan(length) {\n    return this.addConstraint(stringLengthGreaterThan(length));\n  }\n  lengthGreaterThanOrEqual(length) {\n    return this.addConstraint(stringLengthGreaterThanOrEqual(length));\n  }\n  lengthEqual(length) {\n    return this.addConstraint(stringLengthEqual(length));\n  }\n  lengthNotEqual(length) {\n    return this.addConstraint(stringLengthNotEqual(length));\n  }\n  get email() {\n    return this.addConstraint(stringEmail());\n  }\n  url(options) {\n    return this.addConstraint(stringUrl(options));\n  }\n  uuid(options) {\n    return this.addConstraint(stringUuid(options));\n  }\n  regex(regex) {\n    return this.addConstraint(stringRegex(regex));\n  }\n  get date() {\n    return this.addConstraint(stringDate());\n  }\n  get ipv4() {\n    return this.ip(4);\n  }\n  get ipv6() {\n    return this.ip(6);\n  }\n  ip(version) {\n    return this.addConstraint(stringIp(version));\n  }\n  phone() {\n    return this.addConstraint(stringPhone());\n  }\n  handle(value) {\n    return typeof value === \"string\" ? Result.ok(value) : Result.err(new ValidationError(\"s.string\", \"Expected a string primitive\", value));\n  }\n};\n__name(StringValidator, \"StringValidator\");\n\n// src/validators/TupleValidator.ts\nvar TupleValidator = class extends BaseValidator {\n  constructor(validators) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.validators = [];\n    this.validators = validators;\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validators, this.constraints]);\n  }\n  handle(values) {\n    if (!Array.isArray(values)) {\n      return Result.err(new ValidationError(\"s.tuple(T)\", \"Expected an array\", values));\n    }\n    if (values.length !== this.validators.length) {\n      return Result.err(new ValidationError(\"s.tuple(T)\", `Expected an array of length ${this.validators.length}`, values));\n    }\n    if (!this.shouldRunConstraints) {\n      return Result.ok(values);\n    }\n    const errors = [];\n    const transformed = [];\n    for (let i = 0; i < values.length; i++) {\n      const result = this.validators[i].run(values[i]);\n      if (result.isOk()) transformed.push(result.value);else errors.push([i, result.error]);\n    }\n    return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));\n  }\n};\n__name(TupleValidator, \"TupleValidator\");\n\n// src/validators/MapValidator.ts\nvar MapValidator = class extends BaseValidator {\n  constructor(keyValidator, valueValidator) {\n    let constraints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(constraints);\n    this.keyValidator = keyValidator;\n    this.valueValidator = valueValidator;\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);\n  }\n  handle(value) {\n    if (!(value instanceof Map)) {\n      return Result.err(new ValidationError(\"s.map(K, V)\", \"Expected a map\", value));\n    }\n    if (!this.shouldRunConstraints) {\n      return Result.ok(value);\n    }\n    const errors = [];\n    const transformed = /* @__PURE__ */new Map();\n    for (const [key, val] of value.entries()) {\n      const keyResult = this.keyValidator.run(key);\n      const valueResult = this.valueValidator.run(val);\n      const {\n        length\n      } = errors;\n      if (keyResult.isErr()) errors.push([key, keyResult.error]);\n      if (valueResult.isErr()) errors.push([key, valueResult.error]);\n      if (errors.length === length) transformed.set(keyResult.value, valueResult.value);\n    }\n    return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));\n  }\n};\n__name(MapValidator, \"MapValidator\");\n\n// src/validators/LazyValidator.ts\nvar LazyValidator = class extends BaseValidator {\n  constructor(validator) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.validator = validator;\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.validator, this.constraints]);\n  }\n  handle(values) {\n    return this.validator(values).run(values);\n  }\n};\n__name(LazyValidator, \"LazyValidator\");\n\n// src/lib/errors/UnknownEnumValueError.ts\nvar UnknownEnumValueError = class extends BaseError {\n  constructor(value, keys, enumMappings) {\n    super(\"Expected the value to be one of the following enum values:\");\n    this.value = value;\n    this.enumKeys = keys;\n    this.enumMappings = enumMappings;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      value: this.value,\n      enumKeys: this.enumKeys,\n      enumMappings: [...this.enumMappings.entries()]\n    };\n  }\n  [customInspectSymbolStackLess](depth, options) {\n    const value = options.stylize(this.value.toString(), \"string\");\n    if (depth < 0) {\n      return options.stylize(`[UnknownEnumValueError: ${value}]`, \"special\");\n    }\n    const padding = `\n  ${options.stylize(\"|\", \"undefined\")} `;\n    const pairs = this.enumKeys.map(key => {\n      const enumValue = this.enumMappings.get(key);\n      return `${options.stylize(key, \"string\")} or ${options.stylize(enumValue.toString(), typeof enumValue === \"number\" ? \"number\" : \"string\")}`;\n    }).join(padding);\n    const header = `${options.stylize(\"UnknownEnumValueError\", \"special\")} > ${value}`;\n    const message = options.stylize(this.message, \"regexp\");\n    const pairsBlock = `${padding}${pairs}`;\n    return `${header}\n  ${message}\n${pairsBlock}`;\n  }\n};\n__name(UnknownEnumValueError, \"UnknownEnumValueError\");\n\n// src/validators/NativeEnumValidator.ts\nvar NativeEnumValidator = class extends BaseValidator {\n  constructor(enumShape) {\n    super();\n    this.hasNumericElements = false;\n    this.enumMapping = /* @__PURE__ */new Map();\n    this.enumShape = enumShape;\n    this.enumKeys = Object.keys(enumShape).filter(key => {\n      return typeof enumShape[enumShape[key]] !== \"number\";\n    });\n    for (const key of this.enumKeys) {\n      const enumValue = enumShape[key];\n      this.enumMapping.set(key, enumValue);\n      this.enumMapping.set(enumValue, enumValue);\n      if (typeof enumValue === \"number\") {\n        this.hasNumericElements = true;\n        this.enumMapping.set(`${enumValue}`, enumValue);\n      }\n    }\n  }\n  handle(value) {\n    const typeOfValue = typeof value;\n    if (typeOfValue === \"number\") {\n      if (!this.hasNumericElements) {\n        return Result.err(new ValidationError(\"s.nativeEnum(T)\", \"Expected the value to be a string\", value));\n      }\n    } else if (typeOfValue !== \"string\") {\n      return Result.err(new ValidationError(\"s.nativeEnum(T)\", \"Expected the value to be a string or number\", value));\n    }\n    const casted = value;\n    const possibleEnumValue = this.enumMapping.get(casted);\n    return typeof possibleEnumValue === \"undefined\" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.enumShape]);\n  }\n};\n__name(NativeEnumValidator, \"NativeEnumValidator\");\n\n// src/constraints/TypedArrayLengthConstraints.ts\nfunction typedArrayByteLengthComparator(comparator, name, expected, length) {\n  return {\n    run(input) {\n      return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid Typed Array byte length\", input, expected));\n    }\n  };\n}\n__name(typedArrayByteLengthComparator, \"typedArrayByteLengthComparator\");\nfunction typedArrayByteLengthLessThan(value) {\n  const expected = `expected.byteLength < ${value}`;\n  return typedArrayByteLengthComparator(lessThan, \"s.typedArray(T).byteLengthLessThan\", expected, value);\n}\n__name(typedArrayByteLengthLessThan, \"typedArrayByteLengthLessThan\");\nfunction typedArrayByteLengthLessThanOrEqual(value) {\n  const expected = `expected.byteLength <= ${value}`;\n  return typedArrayByteLengthComparator(lessThanOrEqual, \"s.typedArray(T).byteLengthLessThanOrEqual\", expected, value);\n}\n__name(typedArrayByteLengthLessThanOrEqual, \"typedArrayByteLengthLessThanOrEqual\");\nfunction typedArrayByteLengthGreaterThan(value) {\n  const expected = `expected.byteLength > ${value}`;\n  return typedArrayByteLengthComparator(greaterThan, \"s.typedArray(T).byteLengthGreaterThan\", expected, value);\n}\n__name(typedArrayByteLengthGreaterThan, \"typedArrayByteLengthGreaterThan\");\nfunction typedArrayByteLengthGreaterThanOrEqual(value) {\n  const expected = `expected.byteLength >= ${value}`;\n  return typedArrayByteLengthComparator(greaterThanOrEqual, \"s.typedArray(T).byteLengthGreaterThanOrEqual\", expected, value);\n}\n__name(typedArrayByteLengthGreaterThanOrEqual, \"typedArrayByteLengthGreaterThanOrEqual\");\nfunction typedArrayByteLengthEqual(value) {\n  const expected = `expected.byteLength === ${value}`;\n  return typedArrayByteLengthComparator(equal, \"s.typedArray(T).byteLengthEqual\", expected, value);\n}\n__name(typedArrayByteLengthEqual, \"typedArrayByteLengthEqual\");\nfunction typedArrayByteLengthNotEqual(value) {\n  const expected = `expected.byteLength !== ${value}`;\n  return typedArrayByteLengthComparator(notEqual, \"s.typedArray(T).byteLengthNotEqual\", expected, value);\n}\n__name(typedArrayByteLengthNotEqual, \"typedArrayByteLengthNotEqual\");\nfunction typedArrayByteLengthRange(start, endBefore) {\n  const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;\n  return {\n    run(input) {\n      return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.typedArray(T).byteLengthRange\", \"Invalid Typed Array byte length\", input, expected));\n    }\n  };\n}\n__name(typedArrayByteLengthRange, \"typedArrayByteLengthRange\");\nfunction typedArrayByteLengthRangeInclusive(start, end) {\n  const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;\n  return {\n    run(input) {\n      return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.typedArray(T).byteLengthRangeInclusive\", \"Invalid Typed Array byte length\", input, expected));\n    }\n  };\n}\n__name(typedArrayByteLengthRangeInclusive, \"typedArrayByteLengthRangeInclusive\");\nfunction typedArrayByteLengthRangeExclusive(startAfter, endBefore) {\n  const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;\n  return {\n    run(input) {\n      return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.typedArray(T).byteLengthRangeExclusive\", \"Invalid Typed Array byte length\", input, expected));\n    }\n  };\n}\n__name(typedArrayByteLengthRangeExclusive, \"typedArrayByteLengthRangeExclusive\");\nfunction typedArrayLengthComparator(comparator, name, expected, length) {\n  return {\n    run(input) {\n      return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, \"Invalid Typed Array length\", input, expected));\n    }\n  };\n}\n__name(typedArrayLengthComparator, \"typedArrayLengthComparator\");\nfunction typedArrayLengthLessThan(value) {\n  const expected = `expected.length < ${value}`;\n  return typedArrayLengthComparator(lessThan, \"s.typedArray(T).lengthLessThan\", expected, value);\n}\n__name(typedArrayLengthLessThan, \"typedArrayLengthLessThan\");\nfunction typedArrayLengthLessThanOrEqual(value) {\n  const expected = `expected.length <= ${value}`;\n  return typedArrayLengthComparator(lessThanOrEqual, \"s.typedArray(T).lengthLessThanOrEqual\", expected, value);\n}\n__name(typedArrayLengthLessThanOrEqual, \"typedArrayLengthLessThanOrEqual\");\nfunction typedArrayLengthGreaterThan(value) {\n  const expected = `expected.length > ${value}`;\n  return typedArrayLengthComparator(greaterThan, \"s.typedArray(T).lengthGreaterThan\", expected, value);\n}\n__name(typedArrayLengthGreaterThan, \"typedArrayLengthGreaterThan\");\nfunction typedArrayLengthGreaterThanOrEqual(value) {\n  const expected = `expected.length >= ${value}`;\n  return typedArrayLengthComparator(greaterThanOrEqual, \"s.typedArray(T).lengthGreaterThanOrEqual\", expected, value);\n}\n__name(typedArrayLengthGreaterThanOrEqual, \"typedArrayLengthGreaterThanOrEqual\");\nfunction typedArrayLengthEqual(value) {\n  const expected = `expected.length === ${value}`;\n  return typedArrayLengthComparator(equal, \"s.typedArray(T).lengthEqual\", expected, value);\n}\n__name(typedArrayLengthEqual, \"typedArrayLengthEqual\");\nfunction typedArrayLengthNotEqual(value) {\n  const expected = `expected.length !== ${value}`;\n  return typedArrayLengthComparator(notEqual, \"s.typedArray(T).lengthNotEqual\", expected, value);\n}\n__name(typedArrayLengthNotEqual, \"typedArrayLengthNotEqual\");\nfunction typedArrayLengthRange(start, endBefore) {\n  const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;\n  return {\n    run(input) {\n      return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.typedArray(T).lengthRange\", \"Invalid Typed Array length\", input, expected));\n    }\n  };\n}\n__name(typedArrayLengthRange, \"typedArrayLengthRange\");\nfunction typedArrayLengthRangeInclusive(start, end) {\n  const expected = `expected.length >= ${start} && expected.length <= ${end}`;\n  return {\n    run(input) {\n      return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.typedArray(T).lengthRangeInclusive\", \"Invalid Typed Array length\", input, expected));\n    }\n  };\n}\n__name(typedArrayLengthRangeInclusive, \"typedArrayLengthRangeInclusive\");\nfunction typedArrayLengthRangeExclusive(startAfter, endBefore) {\n  const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;\n  return {\n    run(input) {\n      return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError(\"s.typedArray(T).lengthRangeExclusive\", \"Invalid Typed Array length\", input, expected));\n    }\n  };\n}\n__name(typedArrayLengthRangeExclusive, \"typedArrayLengthRangeExclusive\");\n\n// src/constraints/util/common/vowels.ts\nvar vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\nvar aOrAn = /* @__PURE__ */__name(word => {\n  return `${vowels.includes(word[0].toLowerCase()) ? \"an\" : \"a\"} ${word}`;\n}, \"aOrAn\");\n\n// src/constraints/util/typedArray.ts\nvar TypedArrays = {\n  Int8Array: x => x instanceof Int8Array,\n  Uint8Array: x => x instanceof Uint8Array,\n  Uint8ClampedArray: x => x instanceof Uint8ClampedArray,\n  Int16Array: x => x instanceof Int16Array,\n  Uint16Array: x => x instanceof Uint16Array,\n  Int32Array: x => x instanceof Int32Array,\n  Uint32Array: x => x instanceof Uint32Array,\n  Float32Array: x => x instanceof Float32Array,\n  Float64Array: x => x instanceof Float64Array,\n  BigInt64Array: x => x instanceof BigInt64Array,\n  BigUint64Array: x => x instanceof BigUint64Array,\n  TypedArray: x => ArrayBuffer.isView(x) && !(x instanceof DataView)\n};\n\n// src/validators/TypedArrayValidator.ts\nvar TypedArrayValidator = class extends BaseValidator {\n  constructor(type) {\n    let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(constraints);\n    this.type = type;\n  }\n  byteLengthLessThan(length) {\n    return this.addConstraint(typedArrayByteLengthLessThan(length));\n  }\n  byteLengthLessThanOrEqual(length) {\n    return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));\n  }\n  byteLengthGreaterThan(length) {\n    return this.addConstraint(typedArrayByteLengthGreaterThan(length));\n  }\n  byteLengthGreaterThanOrEqual(length) {\n    return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));\n  }\n  byteLengthEqual(length) {\n    return this.addConstraint(typedArrayByteLengthEqual(length));\n  }\n  byteLengthNotEqual(length) {\n    return this.addConstraint(typedArrayByteLengthNotEqual(length));\n  }\n  byteLengthRange(start, endBefore) {\n    return this.addConstraint(typedArrayByteLengthRange(start, endBefore));\n  }\n  byteLengthRangeInclusive(startAt, endAt) {\n    return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));\n  }\n  byteLengthRangeExclusive(startAfter, endBefore) {\n    return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));\n  }\n  lengthLessThan(length) {\n    return this.addConstraint(typedArrayLengthLessThan(length));\n  }\n  lengthLessThanOrEqual(length) {\n    return this.addConstraint(typedArrayLengthLessThanOrEqual(length));\n  }\n  lengthGreaterThan(length) {\n    return this.addConstraint(typedArrayLengthGreaterThan(length));\n  }\n  lengthGreaterThanOrEqual(length) {\n    return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));\n  }\n  lengthEqual(length) {\n    return this.addConstraint(typedArrayLengthEqual(length));\n  }\n  lengthNotEqual(length) {\n    return this.addConstraint(typedArrayLengthNotEqual(length));\n  }\n  lengthRange(start, endBefore) {\n    return this.addConstraint(typedArrayLengthRange(start, endBefore));\n  }\n  lengthRangeInclusive(startAt, endAt) {\n    return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));\n  }\n  lengthRangeExclusive(startAfter, endBefore) {\n    return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));\n  }\n  clone() {\n    return Reflect.construct(this.constructor, [this.type, this.constraints]);\n  }\n  handle(value) {\n    return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError(\"s.typedArray\", `Expected ${aOrAn(this.type)}`, value));\n  }\n};\n__name(TypedArrayValidator, \"TypedArrayValidator\");\n\n// src/lib/Shapes.ts\nvar Shapes = class {\n  get string() {\n    return new StringValidator();\n  }\n  get number() {\n    return new NumberValidator();\n  }\n  get bigint() {\n    return new BigIntValidator();\n  }\n  get boolean() {\n    return new BooleanValidator();\n  }\n  get date() {\n    return new DateValidator();\n  }\n  object(shape) {\n    return new ObjectValidator(shape);\n  }\n  get undefined() {\n    return this.literal(void 0);\n  }\n  get null() {\n    return this.literal(null);\n  }\n  get nullish() {\n    return new NullishValidator();\n  }\n  get any() {\n    return new PassthroughValidator();\n  }\n  get unknown() {\n    return new PassthroughValidator();\n  }\n  get never() {\n    return new NeverValidator();\n  }\n  enum() {\n    for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      values[_key4] = arguments[_key4];\n    }\n    return this.union(...values.map(value => this.literal(value)));\n  }\n  nativeEnum(enumShape) {\n    return new NativeEnumValidator(enumShape);\n  }\n  literal(value) {\n    if (value instanceof Date) return this.date.equal(value);\n    return new LiteralValidator(value);\n  }\n  instance(expected) {\n    return new InstanceValidator(expected);\n  }\n  union() {\n    for (var _len5 = arguments.length, validators = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      validators[_key5] = arguments[_key5];\n    }\n    return new UnionValidator(validators);\n  }\n  array(validator) {\n    return new ArrayValidator(validator);\n  }\n  typedArray() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"TypedArray\";\n    return new TypedArrayValidator(type);\n  }\n  get int8Array() {\n    return this.typedArray(\"Int8Array\");\n  }\n  get uint8Array() {\n    return this.typedArray(\"Uint8Array\");\n  }\n  get uint8ClampedArray() {\n    return this.typedArray(\"Uint8ClampedArray\");\n  }\n  get int16Array() {\n    return this.typedArray(\"Int16Array\");\n  }\n  get uint16Array() {\n    return this.typedArray(\"Uint16Array\");\n  }\n  get int32Array() {\n    return this.typedArray(\"Int32Array\");\n  }\n  get uint32Array() {\n    return this.typedArray(\"Uint32Array\");\n  }\n  get float32Array() {\n    return this.typedArray(\"Float32Array\");\n  }\n  get float64Array() {\n    return this.typedArray(\"Float64Array\");\n  }\n  get bigInt64Array() {\n    return this.typedArray(\"BigInt64Array\");\n  }\n  get bigUint64Array() {\n    return this.typedArray(\"BigUint64Array\");\n  }\n  tuple(validators) {\n    return new TupleValidator(validators);\n  }\n  set(validator) {\n    return new SetValidator(validator);\n  }\n  record(validator) {\n    return new RecordValidator(validator);\n  }\n  map(keyValidator, valueValidator) {\n    return new MapValidator(keyValidator, valueValidator);\n  }\n  lazy(validator) {\n    return new LazyValidator(validator);\n  }\n};\n__name(Shapes, \"Shapes\");\n\n// src/index.ts\nvar s = new Shapes();\nexports.BaseError = BaseError;\nexports.CombinedError = CombinedError;\nexports.CombinedPropertyError = CombinedPropertyError;\nexports.ExpectedConstraintError = ExpectedConstraintError;\nexports.ExpectedValidationError = ExpectedValidationError;\nexports.MissingPropertyError = MissingPropertyError;\nexports.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;\nexports.Result = Result;\nexports.UnknownEnumValueError = UnknownEnumValueError;\nexports.UnknownPropertyError = UnknownPropertyError;\nexports.ValidationError = ValidationError;\nexports.customInspectSymbol = customInspectSymbol;\nexports.customInspectSymbolStackLess = customInspectSymbolStackLess;\nexports.getGlobalValidationEnabled = getGlobalValidationEnabled;\nexports.s = s;\nexports.setGlobalValidationEnabled = setGlobalValidationEnabled;\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["fastDeepEqual","require","uniqWith","_interopDefault","e","__esModule","default","get__default","get","fastDeepEqual__default","uniqWith__default","validationEnabled","setGlobalValidationEnabled","enabled","__name","getGlobalValidationEnabled","Result","constructor","success","value","error","isOk","isErr","ok","err","getValue","valueOrFn","customInspectSymbol","Symbol","for","customInspectSymbolStackLess","depth","options","stack","slice","indexOf","BaseError","BaseConstraintError","constraint","given","ExpectedConstraintError","message","expected","toJSON","name","stylize","newOptions","padding","util","inspect","replace","header","expectedBlock","givenBlock","whenConstraint","key","validator","run","input","parent","isKeyArray","Array","isArray","map","k","predicate","resolveBooleanIs","then","otherwise","is","some","val","Boolean","BaseValidator","constraints","arguments","length","undefined","isValidationEnabled","setParent","optional","UnionValidator","LiteralValidator","clone","nullable","nullish","NullishValidator","array","ArrayValidator","set","SetValidator","or","_len","predicates","_key","transform","cb","addConstraint","reshape","DefaultValidator","when","result","handle","parse","shouldRunConstraints","unwrap","reduce","v","setValidationEnabled","getValidationEnabled","Reflect","construct","concat","isUnique","uniqueArray2","lessThan","a","b","lessThanOrEqual","greaterThan","greaterThanOrEqual","equal","notEqual","arrayLengthComparator","comparator","arrayLengthLessThan","arrayLengthLessThanOrEqual","arrayLengthGreaterThan","arrayLengthGreaterThanOrEqual","arrayLengthEqual","arrayLengthNotEqual","arrayLengthRange","start","endBefore","arrayLengthRangeInclusive","end","arrayLengthRangeExclusive","startAfter","uniqueArray","CombinedPropertyError","errors","compact","toString","_ref","property","formatProperty","body","join","description","ValidationError","lengthLessThan","lengthLessThanOrEqual","lengthGreaterThan","lengthGreaterThanOrEqual","lengthEqual","lengthNotEqual","lengthRange","lengthRangeInclusive","startAt","endAt","lengthRangeExclusive","unique","values","transformed","i","push","bigintComparator","number","bigintLessThan","bigintLessThanOrEqual","bigintGreaterThan","bigintGreaterThanOrEqual","bigintEqual","bigintNotEqual","bigintDivisibleBy","divider","BigIntValidator","positive","negative","divisibleBy","abs","intN","bits","BigInt","asIntN","uintN","asUintN","booleanTrue","booleanFalse","BooleanValidator","true","false","dateComparator","getTime","dateLessThan","toISOString","dateLessThanOrEqual","dateGreaterThan","dateGreaterThanOrEqual","dateEqual","dateNotEqual","dateInvalid","Number","isNaN","dateValid","DateValidator","date","Date","resolved","invalid","valid","ExpectedValidationError","InstanceValidator","literal","Object","NeverValidator","numberComparator","numberLessThan","numberLessThanOrEqual","numberGreaterThan","numberGreaterThanOrEqual","numberEqual","numberNotEqual","numberInt","isInteger","numberSafeInt","isSafeInteger","numberFinite","isFinite","numberNaN","numberNotNaN","numberDivisibleBy","NumberValidator","int","safeInt","finite","Math","sign","trunc","floor","fround","round","ceil","MissingPropertyError","UnknownPropertyError","defaultValue","CombinedError","index","validators","required","_len2","_key2","ObjectValidator","shape","strategy","keys","possiblyUndefinedKeysWithDefaults","Map","handleStrategy","handleIgnoreStrategy","handleStrictStrategy","handlePassthroughStrategy","shapeEntries","entries","_ref2","possiblyLiteralOrNullishPredicate","possiblyUndefinedKeys","requiredKeys","strict","ignore","passthrough","partial","fromEntries","extend","schema","pick","filter","includes","omit","typeOfValue","finalObject","inputEntries","runPredicate","delete","size","checkInputEntriesInsteadOfSchemaKeys","finalResult","value2","PassthroughValidator","RecordValidator","Set","add","accountRegex","validateEmail","email","atIndex","domainIndex","dotIndex","lastDotIndex","test","validateEmailDomain","domain","URL","hostname","v4Seg","v4Str","IPv4Reg","RegExp","v6Seg","isIPv4","s2","isIPv6","IPv6Reg","isIP","phoneNumberRegex","validatePhoneNumber","verticalLine","expectedPadding","possible","MultiplePossibilitiesConstraintError","combinedErrorFn","_len3","fns","_key3","fn","createUrlValidators","allowedProtocols","allowedProtocolsFn","allowedDomains","allowedDomainsFn","url","protocol","stringLengthComparator","stringLengthLessThan","stringLengthLessThanOrEqual","stringLengthGreaterThan","stringLengthGreaterThanOrEqual","stringLengthEqual","stringLengthNotEqual","stringEmail","stringRegexValidator","type","regex","stringUrl","validatorFn","validatorFnResult","stringIp","version","ipVersion","stringRegex","stringUuid","stringDate","time","stringPhone","StringValidator","uuid","ipv4","ip","ipv6","phone","TupleValidator","MapValidator","keyValidator","valueValidator","keyResult","valueResult","LazyValidator","UnknownEnumValueError","enumMappings","enumKeys","pairs","enumValue","pairsBlock","NativeEnumValidator","enumShape","hasNumericElements","enumMapping","casted","possibleEnumValue","typedArrayByteLengthComparator","byteLength","typedArrayByteLengthLessThan","typedArrayByteLengthLessThanOrEqual","typedArrayByteLengthGreaterThan","typedArrayByteLengthGreaterThanOrEqual","typedArrayByteLengthEqual","typedArrayByteLengthNotEqual","typedArrayByteLengthRange","typedArrayByteLengthRangeInclusive","typedArrayByteLengthRangeExclusive","typedArrayLengthComparator","typedArrayLengthLessThan","typedArrayLengthLessThanOrEqual","typedArrayLengthGreaterThan","typedArrayLengthGreaterThanOrEqual","typedArrayLengthEqual","typedArrayLengthNotEqual","typedArrayLengthRange","typedArrayLengthRangeInclusive","typedArrayLengthRangeExclusive","vowels","aOrAn","word","toLowerCase","TypedArrays","Uint8ClampedArray","x","Int16Array","Uint16Array","Int32Array","Float64Array","BigInt64Array","BigUint64Array","TypedArray","ArrayBuffer","isView","DataView","TypedArrayValidator","byteLengthLessThan","byteLengthGreaterThan","byteLengthGreaterThanOrEqual","byteLengthEqual","byteLengthNotEqual","byteLengthRange","byteLengthRangeInclusive","byteLengthRangeExclusive","Shapes","string","boolean","object","null","any","unknown","never","enum","_len4","_key4","union","nativeEnum","instance","_len5","_key5","typedArray","int8Array","uint8Array","uint8ClampedArray","int16Array","uint16Array","int32Array","uint32Array","float32Array","float64Array","bigInt64Array","bigUint64Array","tuple","record","lazy","s","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/configs.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/Result.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/util/getValue.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/ObjectConstrains.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/ExpectedConstraintError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/BaseError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/BaseConstraintError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/BaseValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/isUnique.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/operators.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/ArrayConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/CombinedPropertyError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/ValidationError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/ArrayValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/BigIntConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/BigIntValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/BooleanConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/BooleanValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/DateConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/DateValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/ExpectedValidationError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/InstanceValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/LiteralValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/NeverValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/NullishValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/NumberConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/NumberValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/MissingPropertyError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/UnknownPropertyError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/DefaultValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/CombinedError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/UnionValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/ObjectValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/PassthroughValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/RecordValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/SetValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/emailValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/net.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/phoneValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/MultiplePossibilitiesConstraintError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/common/combinedResultFn.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/urlValidators.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/StringConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/StringValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/TupleValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/MapValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/LazyValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/errors/UnknownEnumValueError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/NativeEnumValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/TypedArrayLengthConstraints.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/common/vowels.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/constraints/util/typedArray.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/validators/TypedArrayValidator.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/lib/Shapes.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@sapphire/shapeshift/src/index.ts"],"sourcesContent":["let validationEnabled = true;\n\n/**\n * Sets whether validators should run on the input, or if the input should be passed through.\n * @param enabled Whether validation should be done on inputs\n */\nexport function setGlobalValidationEnabled(enabled: boolean) {\n\tvalidationEnabled = enabled;\n}\n\n/**\n * @returns Whether validation is enabled\n */\nexport function getGlobalValidationEnabled() {\n\treturn validationEnabled;\n}\n","export class Result<T, E extends Error = Error> {\n\tpublic readonly success: boolean;\n\tpublic readonly value?: T;\n\tpublic readonly error?: E;\n\n\tprivate constructor(success: boolean, value?: T, error?: E) {\n\t\tthis.success = success;\n\t\tif (success) {\n\t\t\tthis.value = value;\n\t\t} else {\n\t\t\tthis.error = error;\n\t\t}\n\t}\n\n\tpublic isOk(): this is { success: true; value: T } {\n\t\treturn this.success;\n\t}\n\n\tpublic isErr(): this is { success: false; error: E } {\n\t\treturn !this.success;\n\t}\n\n\tpublic unwrap(): T {\n\t\tif (this.isOk()) return this.value;\n\t\tthrow this.error as Error;\n\t}\n\n\tpublic static ok<T, E extends Error = Error>(value: T): Result<T, E> {\n\t\treturn new Result<T, E>(true, value);\n\t}\n\n\tpublic static err<T, E extends Error = Error>(error: E): Result<T, E> {\n\t\treturn new Result<T, E>(false, undefined, error);\n\t}\n}\n","// https://github.com/microsoft/TypeScript/issues/37663\ntype Fn = (...args: unknown[]) => unknown;\n\nexport function getValue<T, U = T extends Fn ? ReturnType<T> : T>(valueOrFn: T): U {\n\treturn typeof valueOrFn === 'function' ? valueOrFn() : valueOrFn;\n}\n","import get from 'lodash/get.js';\nimport { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { BaseValidator } from '../type-exports';\nimport type { IConstraint } from './type-exports';\n\nexport type ObjectConstraintName = `s.object(T.when)`;\n\nexport type WhenKey = PropertyKey | PropertyKey[];\n\nexport interface WhenOptions<T extends BaseValidator<any>, Key extends WhenKey> {\n\tis?: boolean | ((value: Key extends Array<any> ? any[] : any) => boolean);\n\tthen: (predicate: T) => T;\n\totherwise?: (predicate: T) => T;\n}\n\nexport function whenConstraint<T extends BaseValidator<any>, I, Key extends WhenKey>(\n\tkey: Key,\n\toptions: WhenOptions<T, Key>,\n\tvalidator: T\n): IConstraint<I> {\n\treturn {\n\t\trun(input: I, parent?: any) {\n\t\t\tif (!parent) {\n\t\t\t\treturn Result.err(new ExpectedConstraintError('s.object(T.when)', 'Validator has no parent', parent, 'Validator to have a parent'));\n\t\t\t}\n\n\t\t\tconst isKeyArray = Array.isArray(key);\n\n\t\t\tconst value = isKeyArray ? key.map((k) => get(parent, k)) : get(parent, key);\n\n\t\t\tconst predicate = resolveBooleanIs<T, Key>(options, value, isKeyArray) ? options.then : options.otherwise;\n\n\t\t\tif (predicate) {\n\t\t\t\treturn predicate(validator).run(input) as Result<I, ExpectedConstraintError<I>>;\n\t\t\t}\n\n\t\t\treturn Result.ok(input);\n\t\t}\n\t};\n}\n\nfunction resolveBooleanIs<T extends BaseValidator<any>, Key extends WhenKey>(options: WhenOptions<T, Key>, value: any, isKeyArray: boolean) {\n\tif (options.is === undefined) {\n\t\treturn isKeyArray ? !value.some((val: any) => !val) : Boolean(value);\n\t}\n\n\tif (typeof options.is === 'function') {\n\t\treturn options.is(value);\n\t}\n\n\treturn value === options.is;\n}\n","import { inspect, type InspectOptionsStylized } from 'util';\nimport { customInspectSymbolStackLess } from './BaseError';\nimport { BaseConstraintError, type ConstraintErrorNames } from './BaseConstraintError';\n\nexport class ExpectedConstraintError<T = unknown> extends BaseConstraintError<T> {\n\tpublic readonly expected: string;\n\n\tpublic constructor(constraint: ConstraintErrorNames, message: string, given: T, expected: string) {\n\t\tsuper(constraint, message, given);\n\t\tthis.expected = expected;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tconstraint: this.constraint,\n\t\t\tgiven: this.given,\n\t\t\texpected: this.expected\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst constraint = options.stylize(this.constraint, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[ExpectedConstraintError: ${constraint}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1 };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst given = inspect(this.given, newOptions).replace(/\\n/g, padding);\n\n\t\tconst header = `${options.stylize('ExpectedConstraintError', 'special')} > ${constraint}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst expectedBlock = `\\n  ${options.stylize('Expected: ', 'string')}${options.stylize(this.expected, 'boolean')}`;\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${expectedBlock}\\n${givenBlock}`;\n\t}\n}\n","import type { InspectOptionsStylized } from 'util';\n\nexport const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');\nexport const customInspectSymbolStackLess = Symbol.for('nodejs.util.inspect.custom.stack-less');\n\nexport abstract class BaseError extends Error {\n\tprotected [customInspectSymbol](depth: number, options: InspectOptionsStylized) {\n\t\treturn `${this[customInspectSymbolStackLess](depth, options)}\\n${this.stack!.slice(this.stack!.indexOf('\\n'))}`;\n\t}\n\n\tprotected abstract [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string;\n}\n","import type {\n\tArrayConstraintName,\n\tBigIntConstraintName,\n\tBooleanConstraintName,\n\tDateConstraintName,\n\tNumberConstraintName,\n\tObjectConstraintName,\n\tStringConstraintName,\n\tTypedArrayConstraintName\n} from '../../constraints/type-exports';\nimport { BaseError } from './BaseError';\n\nexport type ConstraintErrorNames =\n\t| TypedArrayConstraintName\n\t| ArrayConstraintName\n\t| BigIntConstraintName\n\t| BooleanConstraintName\n\t| DateConstraintName\n\t| NumberConstraintName\n\t| ObjectConstraintName\n\t| StringConstraintName;\n\nexport abstract class BaseConstraintError<T = unknown> extends BaseError {\n\tpublic readonly constraint: ConstraintErrorNames;\n\tpublic readonly given: T;\n\n\tpublic constructor(constraint: ConstraintErrorNames, message: string, given: T) {\n\t\tsuper(message);\n\t\tthis.constraint = constraint;\n\t\tthis.given = given;\n\t}\n}\n","import { getGlobalValidationEnabled } from '../lib/configs';\nimport { Result } from '../lib/Result';\nimport { ArrayValidator, DefaultValidator, LiteralValidator, NullishValidator, SetValidator, UnionValidator } from './imports';\nimport { getValue } from './util/getValue';\nimport { whenConstraint, type WhenKey, type WhenOptions } from '../constraints/ObjectConstrains';\nimport type { CombinedError } from '../lib/errors/CombinedError';\nimport type { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport type { UnknownEnumValueError } from '../lib/errors/UnknownEnumValueError';\nimport type { ValidationError } from '../lib/errors/ValidationError';\nimport type { BaseConstraintError, InferResultType } from '../type-exports';\nimport type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\n\nexport abstract class BaseValidator<T> {\n\tprotected parent?: object;\n\tprotected constraints: readonly IConstraint<T>[] = [];\n\tprotected isValidationEnabled: boolean | (() => boolean) | null = null;\n\n\tpublic constructor(constraints: readonly IConstraint<T>[] = []) {\n\t\tthis.constraints = constraints;\n\t}\n\n\tpublic setParent(parent: object): this {\n\t\tthis.parent = parent;\n\t\treturn this;\n\t}\n\n\tpublic get optional(): UnionValidator<T | undefined> {\n\t\treturn new UnionValidator([new LiteralValidator(undefined), this.clone()]);\n\t}\n\n\tpublic get nullable(): UnionValidator<T | null> {\n\t\treturn new UnionValidator([new LiteralValidator(null), this.clone()]);\n\t}\n\n\tpublic get nullish(): UnionValidator<T | null | undefined> {\n\t\treturn new UnionValidator([new NullishValidator(), this.clone()]);\n\t}\n\n\tpublic get array(): ArrayValidator<T[]> {\n\t\treturn new ArrayValidator<T[]>(this.clone());\n\t}\n\n\tpublic get set(): SetValidator<T> {\n\t\treturn new SetValidator<T>(this.clone());\n\t}\n\n\tpublic or<O>(...predicates: readonly BaseValidator<O>[]): UnionValidator<T | O> {\n\t\treturn new UnionValidator<T | O>([this.clone(), ...predicates]);\n\t}\n\n\tpublic transform(cb: (value: T) => T): this;\n\tpublic transform<O>(cb: (value: T) => O): BaseValidator<O>;\n\tpublic transform<O>(cb: (value: T) => O): BaseValidator<O> {\n\t\treturn this.addConstraint({ run: (input) => Result.ok(cb(input) as unknown as T) }) as unknown as BaseValidator<O>;\n\t}\n\n\tpublic reshape(cb: (input: T) => Result<T>): this;\n\tpublic reshape<R extends Result<unknown>, O = InferResultType<R>>(cb: (input: T) => R): BaseValidator<O>;\n\tpublic reshape<R extends Result<unknown>, O = InferResultType<R>>(cb: (input: T) => R): BaseValidator<O> {\n\t\treturn this.addConstraint({ run: cb as unknown as (input: T) => Result<T, BaseConstraintError<T>> }) as unknown as BaseValidator<O>;\n\t}\n\n\tpublic default(value: Exclude<T, undefined> | (() => Exclude<T, undefined>)): DefaultValidator<Exclude<T, undefined>> {\n\t\treturn new DefaultValidator(this.clone() as unknown as BaseValidator<Exclude<T, undefined>>, value);\n\t}\n\n\tpublic when<Key extends WhenKey, This extends BaseValidator<any> = this>(key: Key, options: WhenOptions<This, Key>): this {\n\t\treturn this.addConstraint(whenConstraint<This, T, Key>(key, options, this as unknown as This));\n\t}\n\n\tpublic run(value: unknown): Result<T, BaseError> {\n\t\tlet result = this.handle(value) as Result<T, BaseError>;\n\t\tif (result.isErr()) return result;\n\n\t\tfor (const constraint of this.constraints) {\n\t\t\tresult = constraint.run(result.value as T, this.parent);\n\t\t\tif (result.isErr()) break;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic parse<R extends T = T>(value: unknown): R {\n\t\t// If validation is disabled (at the validator or global level), we only run the `handle` method, which will do some basic checks\n\t\t// (like that the input is a string for a string validator)\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn this.handle(value).unwrap() as R;\n\t\t}\n\n\t\treturn this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap()) as R;\n\t}\n\n\tpublic is<R extends T = T>(value: unknown): value is R {\n\t\treturn this.run(value).isOk();\n\t}\n\n\t/**\n\t * Sets if the validator should also run constraints or just do basic checks.\n\t * @param isValidationEnabled Whether this validator should be enabled or disabled. You can pass boolean or a function returning boolean which will be called just before parsing.\n\t * Set to `null` to go off of the global configuration.\n\t */\n\tpublic setValidationEnabled(isValidationEnabled: boolean | (() => boolean) | null): this {\n\t\tconst clone = this.clone();\n\t\tclone.isValidationEnabled = isValidationEnabled;\n\t\treturn clone;\n\t}\n\n\tpublic getValidationEnabled() {\n\t\treturn getValue(this.isValidationEnabled);\n\t}\n\n\tprotected get shouldRunConstraints(): boolean {\n\t\treturn getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();\n\t}\n\n\tprotected clone(): this {\n\t\tconst clone: this = Reflect.construct(this.constructor, [this.constraints]);\n\t\tclone.isValidationEnabled = this.isValidationEnabled;\n\t\treturn clone;\n\t}\n\n\tprotected abstract handle(value: unknown): Result<T, ValidatorError>;\n\n\tprotected addConstraint(constraint: IConstraint<T>): this {\n\t\tconst clone = this.clone();\n\t\tclone.constraints = clone.constraints.concat(constraint);\n\t\treturn clone;\n\t}\n}\n\nexport type ValidatorError = ValidationError | CombinedError | CombinedPropertyError | UnknownEnumValueError;\n","import fastDeepEqual from 'fast-deep-equal/es6/index.js';\nimport uniqWith from 'lodash/uniqWith.js';\n\nexport function isUnique(input: unknown[]) {\n\tif (input.length < 2) return true;\n\tconst uniqueArray = uniqWith(input, fastDeepEqual);\n\treturn uniqueArray.length === input.length;\n}\n","export function lessThan(a: number, b: number): boolean;\nexport function lessThan(a: bigint, b: bigint): boolean;\nexport function lessThan(a: number | bigint, b: number | bigint): boolean {\n\treturn a < b;\n}\n\nexport function lessThanOrEqual(a: number, b: number): boolean;\nexport function lessThanOrEqual(a: bigint, b: bigint): boolean;\nexport function lessThanOrEqual(a: number | bigint, b: number | bigint): boolean {\n\treturn a <= b;\n}\n\nexport function greaterThan(a: number, b: number): boolean;\nexport function greaterThan(a: bigint, b: bigint): boolean;\nexport function greaterThan(a: number | bigint, b: number | bigint): boolean {\n\treturn a > b;\n}\n\nexport function greaterThanOrEqual(a: number, b: number): boolean;\nexport function greaterThanOrEqual(a: bigint, b: bigint): boolean;\nexport function greaterThanOrEqual(a: number | bigint, b: number | bigint): boolean {\n\treturn a >= b;\n}\n\nexport function equal(a: number, b: number): boolean;\nexport function equal(a: bigint, b: bigint): boolean;\nexport function equal(a: number | bigint, b: number | bigint): boolean {\n\treturn a === b;\n}\n\nexport function notEqual(a: number, b: number): boolean;\nexport function notEqual(a: bigint, b: bigint): boolean;\nexport function notEqual(a: number | bigint, b: number | bigint): boolean {\n\treturn a !== b;\n}\n\nexport interface Comparator {\n\t(a: number, b: number): boolean;\n\t(a: bigint, b: bigint): boolean;\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { isUnique } from './util/isUnique';\nimport { equal, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, notEqual, type Comparator } from './util/operators';\n\nexport type ArrayConstraintName = `s.array(T).${\n\t| 'unique'\n\t| `length${\n\t\t\t| 'LessThan'\n\t\t\t| 'LessThanOrEqual'\n\t\t\t| 'GreaterThan'\n\t\t\t| 'GreaterThanOrEqual'\n\t\t\t| 'Equal'\n\t\t\t| 'NotEqual'\n\t\t\t| 'Range'\n\t\t\t| 'RangeInclusive'\n\t\t\t| 'RangeExclusive'}`}`;\n\nfunction arrayLengthComparator<T>(comparator: Comparator, name: ArrayConstraintName, expected: string, length: number): IConstraint<T[]> {\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn comparator(input.length, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function arrayLengthLessThan<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length < ${value}`;\n\treturn arrayLengthComparator(lessThan, 's.array(T).lengthLessThan', expected, value);\n}\n\nexport function arrayLengthLessThanOrEqual<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length <= ${value}`;\n\treturn arrayLengthComparator(lessThanOrEqual, 's.array(T).lengthLessThanOrEqual', expected, value);\n}\n\nexport function arrayLengthGreaterThan<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length > ${value}`;\n\treturn arrayLengthComparator(greaterThan, 's.array(T).lengthGreaterThan', expected, value);\n}\n\nexport function arrayLengthGreaterThanOrEqual<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length >= ${value}`;\n\treturn arrayLengthComparator(greaterThanOrEqual, 's.array(T).lengthGreaterThanOrEqual', expected, value);\n}\n\nexport function arrayLengthEqual<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length === ${value}`;\n\treturn arrayLengthComparator(equal, 's.array(T).lengthEqual', expected, value);\n}\n\nexport function arrayLengthNotEqual<T>(value: number): IConstraint<T[]> {\n\tconst expected = `expected.length !== ${value}`;\n\treturn arrayLengthComparator(notEqual, 's.array(T).lengthNotEqual', expected, value);\n}\n\nexport function arrayLengthRange<T>(start: number, endBefore: number): IConstraint<T[]> {\n\tconst expected = `expected.length >= ${start} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn input.length >= start && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).lengthRange', 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function arrayLengthRangeInclusive<T>(start: number, end: number): IConstraint<T[]> {\n\tconst expected = `expected.length >= ${start} && expected.length <= ${end}`;\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn input.length >= start && input.length <= end //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).lengthRangeInclusive', 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function arrayLengthRangeExclusive<T>(startAfter: number, endBefore: number): IConstraint<T[]> {\n\tconst expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T[]) {\n\t\t\treturn input.length > startAfter && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).lengthRangeExclusive', 'Invalid Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport const uniqueArray: IConstraint<unknown[]> = {\n\trun(input: unknown[]) {\n\t\treturn isUnique(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.array(T).unique', 'Array values are not unique', input, 'Expected all values to be unique'));\n\t}\n};\n","import type { InspectOptionsStylized } from 'util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class CombinedPropertyError extends BaseError {\n\tpublic readonly errors: [PropertyKey, BaseError][];\n\n\tpublic constructor(errors: [PropertyKey, BaseError][]) {\n\t\tsuper('Received one or more errors');\n\n\t\tthis.errors = errors;\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize('[CombinedPropertyError]', 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\n\t\tconst header = `${options.stylize('CombinedPropertyError', 'special')} (${options.stylize(this.errors.length.toString(), 'number')})`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst errors = this.errors\n\t\t\t.map(([key, error]) => {\n\t\t\t\tconst property = CombinedPropertyError.formatProperty(key, options);\n\t\t\t\tconst body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\\n/g, padding);\n\n\t\t\t\treturn `  input${property}${padding}${body}`;\n\t\t\t})\n\t\t\t.join('\\n\\n');\n\t\treturn `${header}\\n  ${message}\\n\\n${errors}`;\n\t}\n\n\tprivate static formatProperty(key: PropertyKey, options: InspectOptionsStylized): string {\n\t\tif (typeof key === 'string') return options.stylize(`.${key}`, 'symbol');\n\t\tif (typeof key === 'number') return `[${options.stylize(key.toString(), 'number')}]`;\n\t\treturn `[${options.stylize('Symbol', 'symbol')}(${key.description})]`;\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class ValidationError extends BaseError {\n\tpublic readonly validator: string;\n\tpublic readonly given: unknown;\n\n\tpublic constructor(validator: string, message: string, given: unknown) {\n\t\tsuper(message);\n\n\t\tthis.validator = validator;\n\t\tthis.given = given;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvalidator: this.validator,\n\t\t\tgiven: this.given\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst validator = options.stylize(this.validator, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[ValidationError: ${validator}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst given = inspect(this.given, newOptions).replace(/\\n/g, padding);\n\n\t\tconst header = `${options.stylize('ValidationError', 'special')} > ${validator}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${givenBlock}`;\n\t}\n}\n","import {\n\tarrayLengthEqual,\n\tarrayLengthGreaterThan,\n\tarrayLengthGreaterThanOrEqual,\n\tarrayLengthLessThan,\n\tarrayLengthLessThanOrEqual,\n\tarrayLengthNotEqual,\n\tarrayLengthRange,\n\tarrayLengthRangeExclusive,\n\tarrayLengthRangeInclusive,\n\tuniqueArray\n} from '../constraints/ArrayConstraints';\nimport type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport type { ExpandSmallerTuples, Tuple, UnshiftTuple } from '../lib/util-types';\nimport { BaseValidator } from './imports';\n\nexport class ArrayValidator<T extends unknown[], I = T[number]> extends BaseValidator<T> {\n\tprivate readonly validator: BaseValidator<I>;\n\n\tpublic constructor(validator: BaseValidator<I>, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tpublic lengthLessThan<N extends number>(length: N): ArrayValidator<ExpandSmallerTuples<UnshiftTuple<[...Tuple<I, N>]>>> {\n\t\treturn this.addConstraint(arrayLengthLessThan(length) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthLessThanOrEqual<N extends number>(length: N): ArrayValidator<ExpandSmallerTuples<[...Tuple<I, N>]>> {\n\t\treturn this.addConstraint(arrayLengthLessThanOrEqual(length) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthGreaterThan<N extends number>(length: N): ArrayValidator<[...Tuple<I, N>, I, ...T]> {\n\t\treturn this.addConstraint(arrayLengthGreaterThan(length) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthGreaterThanOrEqual<N extends number>(length: N): ArrayValidator<[...Tuple<I, N>, ...T]> {\n\t\treturn this.addConstraint(arrayLengthGreaterThanOrEqual(length) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthEqual<N extends number>(length: N): ArrayValidator<[...Tuple<I, N>]> {\n\t\treturn this.addConstraint(arrayLengthEqual(length) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthNotEqual(length: number): ArrayValidator<[...T]> {\n\t\treturn this.addConstraint(arrayLengthNotEqual(length) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthRange<S extends number, E extends number>(\n\t\tstart: S,\n\t\tendBefore: E\n\t): ArrayValidator<Exclude<ExpandSmallerTuples<UnshiftTuple<[...Tuple<I, E>]>>, ExpandSmallerTuples<UnshiftTuple<[...Tuple<I, S>]>>>> {\n\t\treturn this.addConstraint(arrayLengthRange(start, endBefore) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthRangeInclusive<S extends number, E extends number>(\n\t\tstartAt: S,\n\t\tendAt: E\n\t): ArrayValidator<Exclude<ExpandSmallerTuples<[...Tuple<I, E>]>, ExpandSmallerTuples<UnshiftTuple<[...Tuple<I, S>]>>>> {\n\t\treturn this.addConstraint(arrayLengthRangeInclusive(startAt, endAt) as IConstraint<T>) as any;\n\t}\n\n\tpublic lengthRangeExclusive<S extends number, E extends number>(\n\t\tstartAfter: S,\n\t\tendBefore: E\n\t): ArrayValidator<Exclude<ExpandSmallerTuples<UnshiftTuple<[...Tuple<I, E>]>>, ExpandSmallerTuples<[...Tuple<T, S>]>>> {\n\t\treturn this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore) as IConstraint<T>) as any;\n\t}\n\n\tpublic get unique(): this {\n\t\treturn this.addConstraint(uniqueArray as IConstraint<T>);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<T, ValidationError | CombinedPropertyError> {\n\t\tif (!Array.isArray(values)) {\n\t\t\treturn Result.err(new ValidationError('s.array(T)', 'Expected an array', values));\n\t\t}\n\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn Result.ok(values as T);\n\t\t}\n\n\t\tconst errors: [number, BaseError][] = [];\n\t\tconst transformed: T = [] as unknown as T;\n\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst result = this.validator.run(values[i]);\n\t\t\tif (result.isOk()) transformed.push(result.value);\n\t\t\telse errors.push([i, result.error!]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { equal, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, notEqual, type Comparator } from './util/operators';\n\nexport type BigIntConstraintName = `s.bigint.${\n\t| 'lessThan'\n\t| 'lessThanOrEqual'\n\t| 'greaterThan'\n\t| 'greaterThanOrEqual'\n\t| 'equal'\n\t| 'notEqual'\n\t| 'divisibleBy'}`;\n\nfunction bigintComparator(comparator: Comparator, name: BigIntConstraintName, expected: string, number: bigint): IConstraint<bigint> {\n\treturn {\n\t\trun(input: bigint) {\n\t\t\treturn comparator(input, number) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid bigint value', input, expected));\n\t\t}\n\t};\n}\n\nexport function bigintLessThan(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected < ${value}n`;\n\treturn bigintComparator(lessThan, 's.bigint.lessThan', expected, value);\n}\n\nexport function bigintLessThanOrEqual(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected <= ${value}n`;\n\treturn bigintComparator(lessThanOrEqual, 's.bigint.lessThanOrEqual', expected, value);\n}\n\nexport function bigintGreaterThan(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected > ${value}n`;\n\treturn bigintComparator(greaterThan, 's.bigint.greaterThan', expected, value);\n}\n\nexport function bigintGreaterThanOrEqual(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected >= ${value}n`;\n\treturn bigintComparator(greaterThanOrEqual, 's.bigint.greaterThanOrEqual', expected, value);\n}\n\nexport function bigintEqual(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected === ${value}n`;\n\treturn bigintComparator(equal, 's.bigint.equal', expected, value);\n}\n\nexport function bigintNotEqual(value: bigint): IConstraint<bigint> {\n\tconst expected = `expected !== ${value}n`;\n\treturn bigintComparator(notEqual, 's.bigint.notEqual', expected, value);\n}\n\nexport function bigintDivisibleBy(divider: bigint): IConstraint<bigint> {\n\tconst expected = `expected % ${divider}n === 0n`;\n\treturn {\n\t\trun(input: bigint) {\n\t\t\treturn input % divider === 0n //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.bigint.divisibleBy', 'BigInt is not divisible', input, expected));\n\t\t}\n\t};\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport {\n\tbigintDivisibleBy,\n\tbigintEqual,\n\tbigintGreaterThan,\n\tbigintGreaterThanOrEqual,\n\tbigintLessThan,\n\tbigintLessThanOrEqual,\n\tbigintNotEqual\n} from '../constraints/BigIntConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class BigIntValidator<T extends bigint> extends BaseValidator<T> {\n\tpublic lessThan(number: bigint): this {\n\t\treturn this.addConstraint(bigintLessThan(number) as IConstraint<T>);\n\t}\n\n\tpublic lessThanOrEqual(number: bigint): this {\n\t\treturn this.addConstraint(bigintLessThanOrEqual(number) as IConstraint<T>);\n\t}\n\n\tpublic greaterThan(number: bigint): this {\n\t\treturn this.addConstraint(bigintGreaterThan(number) as IConstraint<T>);\n\t}\n\n\tpublic greaterThanOrEqual(number: bigint): this {\n\t\treturn this.addConstraint(bigintGreaterThanOrEqual(number) as IConstraint<T>);\n\t}\n\n\tpublic equal<N extends bigint>(number: N): BigIntValidator<N> {\n\t\treturn this.addConstraint(bigintEqual(number) as IConstraint<T>) as unknown as BigIntValidator<N>;\n\t}\n\n\tpublic notEqual(number: bigint): this {\n\t\treturn this.addConstraint(bigintNotEqual(number) as IConstraint<T>);\n\t}\n\n\tpublic get positive(): this {\n\t\treturn this.greaterThanOrEqual(0n);\n\t}\n\n\tpublic get negative(): this {\n\t\treturn this.lessThan(0n);\n\t}\n\n\tpublic divisibleBy(number: bigint): this {\n\t\treturn this.addConstraint(bigintDivisibleBy(number) as IConstraint<T>);\n\t}\n\n\tpublic get abs(): this {\n\t\treturn this.transform((value) => (value < 0 ? -value : value) as T);\n\t}\n\n\tpublic intN(bits: number): this {\n\t\treturn this.transform((value) => BigInt.asIntN(bits, value) as T);\n\t}\n\n\tpublic uintN(bits: number): this {\n\t\treturn this.transform((value) => BigInt.asUintN(bits, value) as T);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'bigint' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.bigint', 'Expected a bigint primitive', value));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\n\nexport type BooleanConstraintName = `s.boolean.${boolean}`;\n\nexport const booleanTrue: IConstraint<boolean, true> = {\n\trun(input: boolean) {\n\t\treturn input //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.boolean.true', 'Invalid boolean value', input, 'true'));\n\t}\n};\n\nexport const booleanFalse: IConstraint<boolean, false> = {\n\trun(input: boolean) {\n\t\treturn input //\n\t\t\t? Result.err(new ExpectedConstraintError('s.boolean.false', 'Invalid boolean value', input, 'false'))\n\t\t\t: Result.ok(input);\n\t}\n};\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { booleanFalse, booleanTrue } from '../constraints/BooleanConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class BooleanValidator<T extends boolean = boolean> extends BaseValidator<T> {\n\tpublic get true(): BooleanValidator<true> {\n\t\treturn this.addConstraint(booleanTrue as IConstraint<T>) as BooleanValidator<true>;\n\t}\n\n\tpublic get false(): BooleanValidator<false> {\n\t\treturn this.addConstraint(booleanFalse as IConstraint<T>) as BooleanValidator<false>;\n\t}\n\n\tpublic equal<R extends true | false>(value: R): BooleanValidator<R> {\n\t\treturn (value ? this.true : this.false) as BooleanValidator<R>;\n\t}\n\n\tpublic notEqual<R extends true | false>(value: R): BooleanValidator<R> {\n\t\treturn (value ? this.false : this.true) as BooleanValidator<R>;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'boolean' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.boolean', 'Expected a boolean primitive', value));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { equal, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, notEqual, type Comparator } from './util/operators';\n\nexport type DateConstraintName = `s.date.${\n\t| 'lessThan'\n\t| 'lessThanOrEqual'\n\t| 'greaterThan'\n\t| 'greaterThanOrEqual'\n\t| 'equal'\n\t| 'notEqual'\n\t| 'valid'\n\t| 'invalid'}`;\n\nfunction dateComparator(comparator: Comparator, name: DateConstraintName, expected: string, number: number): IConstraint<Date> {\n\treturn {\n\t\trun(input: Date) {\n\t\t\treturn comparator(input.getTime(), number) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Date value', input, expected));\n\t\t}\n\t};\n}\n\nexport function dateLessThan(value: Date): IConstraint<Date> {\n\tconst expected = `expected < ${value.toISOString()}`;\n\treturn dateComparator(lessThan, 's.date.lessThan', expected, value.getTime());\n}\n\nexport function dateLessThanOrEqual(value: Date): IConstraint<Date> {\n\tconst expected = `expected <= ${value.toISOString()}`;\n\treturn dateComparator(lessThanOrEqual, 's.date.lessThanOrEqual', expected, value.getTime());\n}\n\nexport function dateGreaterThan(value: Date): IConstraint<Date> {\n\tconst expected = `expected > ${value.toISOString()}`;\n\treturn dateComparator(greaterThan, 's.date.greaterThan', expected, value.getTime());\n}\n\nexport function dateGreaterThanOrEqual(value: Date): IConstraint<Date> {\n\tconst expected = `expected >= ${value.toISOString()}`;\n\treturn dateComparator(greaterThanOrEqual, 's.date.greaterThanOrEqual', expected, value.getTime());\n}\n\nexport function dateEqual(value: Date): IConstraint<Date> {\n\tconst expected = `expected === ${value.toISOString()}`;\n\treturn dateComparator(equal, 's.date.equal', expected, value.getTime());\n}\n\nexport function dateNotEqual(value: Date): IConstraint<Date> {\n\tconst expected = `expected !== ${value.toISOString()}`;\n\treturn dateComparator(notEqual, 's.date.notEqual', expected, value.getTime());\n}\n\nexport const dateInvalid: IConstraint<Date> = {\n\trun(input: Date) {\n\t\treturn Number.isNaN(input.getTime()) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.date.invalid', 'Invalid Date value', input, 'expected === NaN'));\n\t}\n};\n\nexport const dateValid: IConstraint<Date> = {\n\trun(input: Date) {\n\t\treturn Number.isNaN(input.getTime()) //\n\t\t\t? Result.err(new ExpectedConstraintError('s.date.valid', 'Invalid Date value', input, 'expected !== NaN'))\n\t\t\t: Result.ok(input);\n\t}\n};\n","import {\n\tdateEqual,\n\tdateGreaterThan,\n\tdateGreaterThanOrEqual,\n\tdateInvalid,\n\tdateLessThan,\n\tdateLessThanOrEqual,\n\tdateNotEqual,\n\tdateValid\n} from '../constraints/DateConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class DateValidator extends BaseValidator<Date> {\n\tpublic lessThan(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateLessThan(new Date(date)));\n\t}\n\n\tpublic lessThanOrEqual(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateLessThanOrEqual(new Date(date)));\n\t}\n\n\tpublic greaterThan(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateGreaterThan(new Date(date)));\n\t}\n\n\tpublic greaterThanOrEqual(date: Date | number | string): this {\n\t\treturn this.addConstraint(dateGreaterThanOrEqual(new Date(date)));\n\t}\n\n\tpublic equal(date: Date | number | string): this {\n\t\tconst resolved = new Date(date);\n\t\treturn Number.isNaN(resolved.getTime()) //\n\t\t\t? this.invalid\n\t\t\t: this.addConstraint(dateEqual(resolved));\n\t}\n\n\tpublic notEqual(date: Date | number | string): this {\n\t\tconst resolved = new Date(date);\n\t\treturn Number.isNaN(resolved.getTime()) //\n\t\t\t? this.valid\n\t\t\t: this.addConstraint(dateNotEqual(resolved));\n\t}\n\n\tpublic get valid(): this {\n\t\treturn this.addConstraint(dateValid);\n\t}\n\n\tpublic get invalid(): this {\n\t\treturn this.addConstraint(dateInvalid);\n\t}\n\n\tprotected handle(value: unknown): Result<Date, ValidationError> {\n\t\treturn value instanceof Date //\n\t\t\t? Result.ok(value)\n\t\t\t: Result.err(new ValidationError('s.date', 'Expected a Date', value));\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'util';\nimport { customInspectSymbolStackLess } from './BaseError';\nimport { ValidationError } from './ValidationError';\n\nexport class ExpectedValidationError<T> extends ValidationError {\n\tpublic readonly expected: T;\n\n\tpublic constructor(validator: string, message: string, given: unknown, expected: T) {\n\t\tsuper(validator, message, given);\n\t\tthis.expected = expected;\n\t}\n\n\tpublic override toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvalidator: this.validator,\n\t\t\tgiven: this.given,\n\t\t\texpected: this.expected\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst validator = options.stylize(this.validator, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[ExpectedValidationError: ${validator}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1 };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst expected = inspect(this.expected, newOptions).replace(/\\n/g, padding);\n\t\tconst given = inspect(this.given, newOptions).replace(/\\n/g, padding);\n\n\t\tconst header = `${options.stylize('ExpectedValidationError', 'special')} > ${validator}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst expectedBlock = `\\n  ${options.stylize('Expected:', 'string')}${padding}${expected}`;\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${expectedBlock}\\n${givenBlock}`;\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { ExpectedValidationError } from '../lib/errors/ExpectedValidationError';\nimport { Result } from '../lib/Result';\nimport type { Constructor } from '../lib/util-types';\nimport { BaseValidator } from './imports';\n\nexport class InstanceValidator<T> extends BaseValidator<T> {\n\tpublic readonly expected: Constructor<T>;\n\n\tpublic constructor(expected: Constructor<T>, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.expected = expected;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ExpectedValidationError<Constructor<T>>> {\n\t\treturn value instanceof this.expected //\n\t\t\t? Result.ok(value)\n\t\t\t: Result.err(new ExpectedValidationError('s.instance(V)', 'Expected', value, this.expected));\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.expected, this.constraints]);\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { ExpectedValidationError } from '../lib/errors/ExpectedValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class LiteralValidator<T> extends BaseValidator<T> {\n\tpublic readonly expected: T;\n\n\tpublic constructor(literal: T, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.expected = literal;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ExpectedValidationError<T>> {\n\t\treturn Object.is(value, this.expected) //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ExpectedValidationError('s.literal(V)', 'Expected values to be equals', value, this.expected));\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.expected, this.constraints]);\n\t}\n}\n","import { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NeverValidator extends BaseValidator<never> {\n\tprotected handle(value: unknown): Result<never, ValidationError> {\n\t\treturn Result.err(new ValidationError('s.never', 'Expected a value to not be passed', value));\n\t}\n}\n","import { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NullishValidator extends BaseValidator<undefined | null> {\n\tprotected handle(value: unknown): Result<undefined | null, ValidationError> {\n\t\treturn value === undefined || value === null //\n\t\t\t? Result.ok(value)\n\t\t\t: Result.err(new ValidationError('s.nullish', 'Expected undefined or null', value));\n\t}\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { equal, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, notEqual, type Comparator } from './util/operators';\n\nexport type NumberConstraintName = `s.number.${\n\t| 'lessThan'\n\t| 'lessThanOrEqual'\n\t| 'greaterThan'\n\t| 'greaterThanOrEqual'\n\t| 'equal'\n\t| 'equal(NaN)'\n\t| 'notEqual'\n\t| 'notEqual(NaN)'\n\t| 'int'\n\t| 'safeInt'\n\t| 'finite'\n\t| 'divisibleBy'}`;\n\nfunction numberComparator(comparator: Comparator, name: NumberConstraintName, expected: string, number: number): IConstraint<number> {\n\treturn {\n\t\trun(input: number) {\n\t\t\treturn comparator(input, number) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid number value', input, expected));\n\t\t}\n\t};\n}\n\nexport function numberLessThan(value: number): IConstraint<number> {\n\tconst expected = `expected < ${value}`;\n\treturn numberComparator(lessThan, 's.number.lessThan', expected, value);\n}\n\nexport function numberLessThanOrEqual(value: number): IConstraint<number> {\n\tconst expected = `expected <= ${value}`;\n\treturn numberComparator(lessThanOrEqual, 's.number.lessThanOrEqual', expected, value);\n}\n\nexport function numberGreaterThan(value: number): IConstraint<number> {\n\tconst expected = `expected > ${value}`;\n\treturn numberComparator(greaterThan, 's.number.greaterThan', expected, value);\n}\n\nexport function numberGreaterThanOrEqual(value: number): IConstraint<number> {\n\tconst expected = `expected >= ${value}`;\n\treturn numberComparator(greaterThanOrEqual, 's.number.greaterThanOrEqual', expected, value);\n}\n\nexport function numberEqual(value: number): IConstraint<number> {\n\tconst expected = `expected === ${value}`;\n\treturn numberComparator(equal, 's.number.equal', expected, value);\n}\n\nexport function numberNotEqual(value: number): IConstraint<number> {\n\tconst expected = `expected !== ${value}`;\n\treturn numberComparator(notEqual, 's.number.notEqual', expected, value);\n}\n\nexport const numberInt: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isInteger(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(\n\t\t\t\t\tnew ExpectedConstraintError('s.number.int', 'Given value is not an integer', input, 'Number.isInteger(expected) to be true')\n\t\t\t  );\n\t}\n};\n\nexport const numberSafeInt: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isSafeInteger(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(\n\t\t\t\t\tnew ExpectedConstraintError(\n\t\t\t\t\t\t's.number.safeInt',\n\t\t\t\t\t\t'Given value is not a safe integer',\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\t'Number.isSafeInteger(expected) to be true'\n\t\t\t\t\t)\n\t\t\t  );\n\t}\n};\n\nexport const numberFinite: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isFinite(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.number.finite', 'Given value is not finite', input, 'Number.isFinite(expected) to be true'));\n\t}\n};\n\nexport const numberNaN: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isNaN(input) //\n\t\t\t? Result.ok(input)\n\t\t\t: Result.err(new ExpectedConstraintError('s.number.equal(NaN)', 'Invalid number value', input, 'expected === NaN'));\n\t}\n};\n\nexport const numberNotNaN: IConstraint<number> = {\n\trun(input: number) {\n\t\treturn Number.isNaN(input) //\n\t\t\t? Result.err(new ExpectedConstraintError('s.number.notEqual(NaN)', 'Invalid number value', input, 'expected !== NaN'))\n\t\t\t: Result.ok(input);\n\t}\n};\n\nexport function numberDivisibleBy(divider: number): IConstraint<number> {\n\tconst expected = `expected % ${divider} === 0`;\n\treturn {\n\t\trun(input: number) {\n\t\t\treturn input % divider === 0 //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.number.divisibleBy', 'Number is not divisible', input, expected));\n\t\t}\n\t};\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport {\n\tnumberDivisibleBy,\n\tnumberEqual,\n\tnumberFinite,\n\tnumberGreaterThan,\n\tnumberGreaterThanOrEqual,\n\tnumberInt,\n\tnumberLessThan,\n\tnumberLessThanOrEqual,\n\tnumberNaN,\n\tnumberNotEqual,\n\tnumberNotNaN,\n\tnumberSafeInt\n} from '../constraints/NumberConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NumberValidator<T extends number> extends BaseValidator<T> {\n\tpublic lessThan(number: number): this {\n\t\treturn this.addConstraint(numberLessThan(number) as IConstraint<T>);\n\t}\n\n\tpublic lessThanOrEqual(number: number): this {\n\t\treturn this.addConstraint(numberLessThanOrEqual(number) as IConstraint<T>);\n\t}\n\n\tpublic greaterThan(number: number): this {\n\t\treturn this.addConstraint(numberGreaterThan(number) as IConstraint<T>);\n\t}\n\n\tpublic greaterThanOrEqual(number: number): this {\n\t\treturn this.addConstraint(numberGreaterThanOrEqual(number) as IConstraint<T>);\n\t}\n\n\tpublic equal<N extends number>(number: N): NumberValidator<N> {\n\t\treturn Number.isNaN(number) //\n\t\t\t? (this.addConstraint(numberNaN as IConstraint<T>) as unknown as NumberValidator<N>)\n\t\t\t: (this.addConstraint(numberEqual(number) as IConstraint<T>) as unknown as NumberValidator<N>);\n\t}\n\n\tpublic notEqual(number: number): this {\n\t\treturn Number.isNaN(number) //\n\t\t\t? this.addConstraint(numberNotNaN as IConstraint<T>)\n\t\t\t: this.addConstraint(numberNotEqual(number) as IConstraint<T>);\n\t}\n\n\tpublic get int(): this {\n\t\treturn this.addConstraint(numberInt as IConstraint<T>);\n\t}\n\n\tpublic get safeInt(): this {\n\t\treturn this.addConstraint(numberSafeInt as IConstraint<T>);\n\t}\n\n\tpublic get finite(): this {\n\t\treturn this.addConstraint(numberFinite as IConstraint<T>);\n\t}\n\n\tpublic get positive(): this {\n\t\treturn this.greaterThanOrEqual(0);\n\t}\n\n\tpublic get negative(): this {\n\t\treturn this.lessThan(0);\n\t}\n\n\tpublic divisibleBy(divider: number): this {\n\t\treturn this.addConstraint(numberDivisibleBy(divider) as IConstraint<T>);\n\t}\n\n\tpublic get abs(): this {\n\t\treturn this.transform(Math.abs as (value: number) => T);\n\t}\n\n\tpublic get sign(): this {\n\t\treturn this.transform(Math.sign as (value: number) => T);\n\t}\n\n\tpublic get trunc(): this {\n\t\treturn this.transform(Math.trunc as (value: number) => T);\n\t}\n\n\tpublic get floor(): this {\n\t\treturn this.transform(Math.floor as (value: number) => T);\n\t}\n\n\tpublic get fround(): this {\n\t\treturn this.transform(Math.fround as (value: number) => T);\n\t}\n\n\tpublic get round(): this {\n\t\treturn this.transform(Math.round as (value: number) => T);\n\t}\n\n\tpublic get ceil(): this {\n\t\treturn this.transform(Math.ceil as (value: number) => T);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'number' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.number', 'Expected a number primitive', value));\n\t}\n}\n","import type { InspectOptionsStylized } from 'util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class MissingPropertyError extends BaseError {\n\tpublic readonly property: PropertyKey;\n\n\tpublic constructor(property: PropertyKey) {\n\t\tsuper('A required property is missing');\n\t\tthis.property = property;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tproperty: this.property\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst property = options.stylize(this.property.toString(), 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[MissingPropertyError: ${property}]`, 'special');\n\t\t}\n\n\t\tconst header = `${options.stylize('MissingPropertyError', 'special')} > ${property}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\treturn `${header}\\n  ${message}`;\n\t}\n}\n","import { inspect, type InspectOptionsStylized } from 'util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class UnknownPropertyError extends BaseError {\n\tpublic readonly property: PropertyKey;\n\tpublic readonly value: unknown;\n\n\tpublic constructor(property: PropertyKey, value: unknown) {\n\t\tsuper('Received unexpected property');\n\n\t\tthis.property = property;\n\t\tthis.value = value;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tproperty: this.property,\n\t\t\tvalue: this.value\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst property = options.stylize(this.property.toString(), 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[UnknownPropertyError: ${property}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst given = inspect(this.value, newOptions).replace(/\\n/g, padding);\n\n\t\tconst header = `${options.stylize('UnknownPropertyError', 'special')} > ${property}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${givenBlock}`;\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport { Result } from '../lib/Result';\nimport type { ValidatorError } from './BaseValidator';\nimport { BaseValidator } from './imports';\nimport { getValue } from './util/getValue';\n\nexport class DefaultValidator<T> extends BaseValidator<T> {\n\tprivate readonly validator: BaseValidator<T>;\n\tprivate defaultValue: T | (() => T);\n\n\tpublic constructor(validator: BaseValidator<T>, value: T | (() => T), constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t\tthis.defaultValue = value;\n\t}\n\n\tpublic override default(value: Exclude<T, undefined> | (() => Exclude<T, undefined>)): DefaultValidator<Exclude<T, undefined>> {\n\t\tconst clone = this.clone() as unknown as DefaultValidator<Exclude<T, undefined>>;\n\t\tclone.defaultValue = value;\n\t\treturn clone;\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidatorError> {\n\t\treturn typeof value === 'undefined' //\n\t\t\t? Result.ok(getValue(this.defaultValue))\n\t\t\t: this.validator['handle'](value); // eslint-disable-line @typescript-eslint/dot-notation\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);\n\t}\n}\n","import type { InspectOptionsStylized } from 'util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class CombinedError extends BaseError {\n\tpublic readonly errors: readonly BaseError[];\n\n\tpublic constructor(errors: readonly BaseError[]) {\n\t\tsuper('Received one or more errors');\n\n\t\tthis.errors = errors;\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize('[CombinedError]', 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1, compact: true };\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\n\t\tconst header = `${options.stylize('CombinedError', 'special')} (${options.stylize(this.errors.length.toString(), 'number')})`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst errors = this.errors\n\t\t\t.map((error, i) => {\n\t\t\t\tconst index = options.stylize((i + 1).toString(), 'number');\n\t\t\t\tconst body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\\n/g, padding);\n\n\t\t\t\treturn `  ${index} ${body}`;\n\t\t\t})\n\t\t\t.join('\\n\\n');\n\t\treturn `${header}\\n  ${message}\\n\\n${errors}`;\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedError } from '../lib/errors/CombinedError';\nimport type { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator, LiteralValidator, NullishValidator } from './imports';\n\nexport class UnionValidator<T> extends BaseValidator<T> {\n\tprivate validators: readonly BaseValidator<T>[];\n\n\tpublic constructor(validators: readonly BaseValidator<T>[], constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validators = validators;\n\t}\n\n\tpublic override get optional(): UnionValidator<T | undefined> {\n\t\tif (this.validators.length === 0) return new UnionValidator<T | undefined>([new LiteralValidator(undefined)], this.constraints);\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\t// If already optional, return a clone:\n\t\t\tif (validator.expected === undefined) return this.clone();\n\n\t\t\t// If it's nullable, convert the nullable validator into a nullish validator to optimize `null | undefined`:\n\t\t\tif (validator.expected === null) {\n\t\t\t\treturn new UnionValidator<T | null | undefined>(\n\t\t\t\t\t[new NullishValidator(), ...this.validators.slice(1)],\n\t\t\t\t\tthis.constraints\n\t\t\t\t) as UnionValidator<T | undefined>;\n\t\t\t}\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t// If it's already nullish (which validates optional), return a clone:\n\t\t\treturn this.clone();\n\t\t}\n\n\t\treturn new UnionValidator([new LiteralValidator(undefined), ...this.validators]);\n\t}\n\n\tpublic get required(): UnionValidator<Exclude<T, undefined>> {\n\t\ttype RequiredValidator = UnionValidator<Exclude<T, undefined>>;\n\n\t\tif (this.validators.length === 0) return this.clone() as unknown as RequiredValidator;\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\tif (validator.expected === undefined) return new UnionValidator(this.validators.slice(1), this.constraints) as RequiredValidator;\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\treturn new UnionValidator([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints) as RequiredValidator;\n\t\t}\n\n\t\treturn this.clone() as unknown as RequiredValidator;\n\t}\n\n\tpublic override get nullable(): UnionValidator<T | null> {\n\t\tif (this.validators.length === 0) return new UnionValidator<T | null>([new LiteralValidator(null)], this.constraints);\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\t// If already nullable, return a clone:\n\t\t\tif (validator.expected === null) return this.clone();\n\n\t\t\t// If it's optional, convert the optional validator into a nullish validator to optimize `null | undefined`:\n\t\t\tif (validator.expected === undefined) {\n\t\t\t\treturn new UnionValidator<T | null | undefined>(\n\t\t\t\t\t[new NullishValidator(), ...this.validators.slice(1)],\n\t\t\t\t\tthis.constraints\n\t\t\t\t) as UnionValidator<T | null>;\n\t\t\t}\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t// If it's already nullish (which validates nullable), return a clone:\n\t\t\treturn this.clone();\n\t\t}\n\n\t\treturn new UnionValidator([new LiteralValidator(null), ...this.validators]);\n\t}\n\n\tpublic override get nullish(): UnionValidator<T | null | undefined> {\n\t\tif (this.validators.length === 0) return new UnionValidator<T | null | undefined>([new NullishValidator()], this.constraints);\n\n\t\tconst [validator] = this.validators;\n\t\tif (validator instanceof LiteralValidator) {\n\t\t\t// If already nullable or optional, promote the union to nullish:\n\t\t\tif (validator.expected === null || validator.expected === undefined) {\n\t\t\t\treturn new UnionValidator<T | null | undefined>([new NullishValidator(), ...this.validators.slice(1)], this.constraints);\n\t\t\t}\n\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t// If it's already nullish, return a clone:\n\t\t\treturn this.clone();\n\t\t}\n\n\t\treturn new UnionValidator<T | null | undefined>([new NullishValidator(), ...this.validators]);\n\t}\n\n\tpublic override or<O>(...predicates: readonly BaseValidator<O>[]): UnionValidator<T | O> {\n\t\treturn new UnionValidator<T | O>([...this.validators, ...predicates]);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validators, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError | CombinedError> {\n\t\tconst errors: BaseError[] = [];\n\n\t\tfor (const validator of this.validators) {\n\t\t\tconst result = validator.run(value);\n\t\t\tif (result.isOk()) return result as Result<T, CombinedError>;\n\t\t\terrors.push(result.error!);\n\t\t}\n\n\t\treturn Result.err(new CombinedError(errors));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { MissingPropertyError } from '../lib/errors/MissingPropertyError';\nimport { UnknownPropertyError } from '../lib/errors/UnknownPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport type { MappedObjectValidator, UndefinedToOptional } from '../lib/util-types';\nimport { BaseValidator } from './BaseValidator';\nimport { DefaultValidator } from './DefaultValidator';\nimport { LiteralValidator } from './LiteralValidator';\nimport { NullishValidator } from './NullishValidator';\nimport { UnionValidator } from './UnionValidator';\n\nexport class ObjectValidator<T extends object, I = UndefinedToOptional<T>> extends BaseValidator<I> {\n\tpublic readonly shape: MappedObjectValidator<T>;\n\tpublic readonly strategy: ObjectValidatorStrategy;\n\tprivate readonly keys: readonly (keyof I)[] = [];\n\tprivate readonly handleStrategy: (value: object) => Result<I, CombinedPropertyError>;\n\n\tprivate readonly requiredKeys = new Map<keyof I, BaseValidator<unknown>>();\n\tprivate readonly possiblyUndefinedKeys = new Map<keyof I, BaseValidator<unknown>>();\n\tprivate readonly possiblyUndefinedKeysWithDefaults = new Map<keyof I, DefaultValidator<unknown>>();\n\n\tpublic constructor(\n\t\tshape: MappedObjectValidator<T>,\n\t\tstrategy: ObjectValidatorStrategy = ObjectValidatorStrategy.Ignore,\n\t\tconstraints: readonly IConstraint<I>[] = []\n\t) {\n\t\tsuper(constraints);\n\t\tthis.shape = shape;\n\t\tthis.strategy = strategy;\n\n\t\tswitch (this.strategy) {\n\t\t\tcase ObjectValidatorStrategy.Ignore:\n\t\t\t\tthis.handleStrategy = (value) => this.handleIgnoreStrategy(value);\n\t\t\t\tbreak;\n\t\t\tcase ObjectValidatorStrategy.Strict: {\n\t\t\t\tthis.handleStrategy = (value) => this.handleStrictStrategy(value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ObjectValidatorStrategy.Passthrough:\n\t\t\t\tthis.handleStrategy = (value) => this.handlePassthroughStrategy(value);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst shapeEntries = Object.entries(shape) as [keyof I, BaseValidator<T>][];\n\t\tthis.keys = shapeEntries.map(([key]) => key);\n\n\t\tfor (const [key, validator] of shapeEntries) {\n\t\t\tif (validator instanceof UnionValidator) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\t\t\t\tconst [possiblyLiteralOrNullishPredicate] = validator['validators'];\n\n\t\t\t\tif (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {\n\t\t\t\t\tthis.possiblyUndefinedKeys.set(key, validator);\n\t\t\t\t} else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {\n\t\t\t\t\tif (possiblyLiteralOrNullishPredicate.expected === undefined) {\n\t\t\t\t\t\tthis.possiblyUndefinedKeys.set(key, validator);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.requiredKeys.set(key, validator);\n\t\t\t\t\t}\n\t\t\t\t} else if (validator instanceof DefaultValidator) {\n\t\t\t\t\tthis.possiblyUndefinedKeysWithDefaults.set(key, validator);\n\t\t\t\t} else {\n\t\t\t\t\tthis.requiredKeys.set(key, validator);\n\t\t\t\t}\n\t\t\t} else if (validator instanceof NullishValidator) {\n\t\t\t\tthis.possiblyUndefinedKeys.set(key, validator);\n\t\t\t} else if (validator instanceof LiteralValidator) {\n\t\t\t\tif (validator.expected === undefined) {\n\t\t\t\t\tthis.possiblyUndefinedKeys.set(key, validator);\n\t\t\t\t} else {\n\t\t\t\t\tthis.requiredKeys.set(key, validator);\n\t\t\t\t}\n\t\t\t} else if (validator instanceof DefaultValidator) {\n\t\t\t\tthis.possiblyUndefinedKeysWithDefaults.set(key, validator);\n\t\t\t} else {\n\t\t\t\tthis.requiredKeys.set(key, validator);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get strict(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Strict, this.constraints]);\n\t}\n\n\tpublic get ignore(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Ignore, this.constraints]);\n\t}\n\n\tpublic get passthrough(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Passthrough, this.constraints]);\n\t}\n\n\tpublic get partial(): ObjectValidator<{ [Key in keyof I]?: I[Key] }> {\n\t\tconst shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key as unknown as keyof typeof this.shape].optional]));\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic get required(): ObjectValidator<{ [Key in keyof I]-?: I[Key] }> {\n\t\tconst shape = Object.fromEntries(\n\t\t\tthis.keys.map((key) => {\n\t\t\t\tlet validator = this.shape[key as unknown as keyof typeof this.shape];\n\t\t\t\tif (validator instanceof UnionValidator) validator = validator.required;\n\t\t\t\treturn [key, validator];\n\t\t\t})\n\t\t);\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic extend<ET extends object>(schema: ObjectValidator<ET> | MappedObjectValidator<ET>): ObjectValidator<T & ET> {\n\t\tconst shape = { ...this.shape, ...(schema instanceof ObjectValidator ? schema.shape : schema) };\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic pick<K extends keyof I>(keys: readonly K[]): ObjectValidator<{ [Key in keyof Pick<I, K>]: I[Key] }> {\n\t\tconst shape = Object.fromEntries(\n\t\t\tkeys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key as unknown as keyof typeof this.shape]])\n\t\t);\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tpublic omit<K extends keyof I>(keys: readonly K[]): ObjectValidator<{ [Key in keyof Omit<I, K>]: I[Key] }> {\n\t\tconst shape = Object.fromEntries(\n\t\t\tthis.keys.filter((key) => !keys.includes(key as any)).map((key) => [key, this.shape[key as unknown as keyof typeof this.shape]])\n\t\t);\n\t\treturn Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);\n\t}\n\n\tprotected override handle(value: unknown): Result<I, ValidationError | CombinedPropertyError> {\n\t\tconst typeOfValue = typeof value;\n\t\tif (typeOfValue !== 'object') {\n\t\t\treturn Result.err(new ValidationError('s.object(T)', `Expected the value to be an object, but received ${typeOfValue} instead`, value));\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn Result.err(new ValidationError('s.object(T)', 'Expected the value to not be null', value));\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn Result.err(new ValidationError('s.object(T)', 'Expected the value to not be an array', value));\n\t\t}\n\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn Result.ok(value as I);\n\t\t}\n\n\t\tfor (const predicate of Object.values(this.shape) as BaseValidator<any>[]) {\n\t\t\tpredicate.setParent(this.parent ?? value!);\n\t\t}\n\n\t\treturn this.handleStrategy(value as object);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);\n\t}\n\n\tprivate handleIgnoreStrategy(value: object): Result<I, CombinedPropertyError> {\n\t\tconst errors: [PropertyKey, BaseError][] = [];\n\t\tconst finalObject = {} as I;\n\t\tconst inputEntries = new Map(Object.entries(value) as [keyof I, unknown][]);\n\n\t\tconst runPredicate = (key: keyof I, predicate: BaseValidator<unknown>) => {\n\t\t\tconst result = predicate.run(value[key as keyof object]);\n\n\t\t\tif (result.isOk()) {\n\t\t\t\tfinalObject[key] = result.value as I[keyof I];\n\t\t\t} else {\n\t\t\t\tconst error = result.error!;\n\t\t\t\terrors.push([key, error]);\n\t\t\t}\n\t\t};\n\n\t\tfor (const [key, predicate] of this.requiredKeys) {\n\t\t\tif (inputEntries.delete(key)) {\n\t\t\t\trunPredicate(key, predicate);\n\t\t\t} else {\n\t\t\t\terrors.push([key, new MissingPropertyError(key)]);\n\t\t\t}\n\t\t}\n\n\t\t// Run possibly undefined keys that also have defaults even if there are no more keys to process (this is necessary so we fill in those defaults)\n\t\tfor (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {\n\t\t\tinputEntries.delete(key);\n\t\t\trunPredicate(key, validator);\n\t\t}\n\n\t\t// Early exit if there are no more properties to validate in the object and there are errors to report\n\t\tif (inputEntries.size === 0) {\n\t\t\treturn errors.length === 0 //\n\t\t\t\t? Result.ok(finalObject)\n\t\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t\t}\n\n\t\t// In the event the remaining keys to check are less than the number of possible undefined keys, we check those\n\t\t// as it could yield a faster execution\n\t\tconst checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;\n\n\t\tif (checkInputEntriesInsteadOfSchemaKeys) {\n\t\t\tfor (const [key] of inputEntries) {\n\t\t\t\tconst predicate = this.possiblyUndefinedKeys.get(key);\n\n\t\t\t\tif (predicate) {\n\t\t\t\t\trunPredicate(key, predicate);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, predicate] of this.possiblyUndefinedKeys) {\n\t\t\t\tif (inputEntries.delete(key)) {\n\t\t\t\t\trunPredicate(key, predicate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(finalObject)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n\n\tprivate handleStrictStrategy(value: object): Result<I, CombinedPropertyError> {\n\t\tconst errors: [PropertyKey, BaseError][] = [];\n\t\tconst finalResult = {} as I;\n\t\tconst inputEntries = new Map(Object.entries(value) as [keyof I, unknown][]);\n\n\t\tconst runPredicate = (key: keyof I, predicate: BaseValidator<unknown>) => {\n\t\t\tconst result = predicate.run(value[key as keyof object]);\n\n\t\t\tif (result.isOk()) {\n\t\t\t\tfinalResult[key] = result.value as I[keyof I];\n\t\t\t} else {\n\t\t\t\tconst error = result.error!;\n\t\t\t\terrors.push([key, error]);\n\t\t\t}\n\t\t};\n\n\t\tfor (const [key, predicate] of this.requiredKeys) {\n\t\t\tif (inputEntries.delete(key)) {\n\t\t\t\trunPredicate(key, predicate);\n\t\t\t} else {\n\t\t\t\terrors.push([key, new MissingPropertyError(key)]);\n\t\t\t}\n\t\t}\n\n\t\t// Run possibly undefined keys that also have defaults even if there are no more keys to process (this is necessary so we fill in those defaults)\n\t\tfor (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {\n\t\t\tinputEntries.delete(key);\n\t\t\trunPredicate(key, validator);\n\t\t}\n\n\t\tfor (const [key, predicate] of this.possiblyUndefinedKeys) {\n\t\t\t// All of these validators are assumed to be possibly undefined, so if we have gone through the entire object and there's still validators,\n\t\t\t// safe to assume we're done here\n\t\t\tif (inputEntries.size === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (inputEntries.delete(key)) {\n\t\t\t\trunPredicate(key, predicate);\n\t\t\t}\n\t\t}\n\n\t\tif (inputEntries.size !== 0) {\n\t\t\tfor (const [key, value] of inputEntries.entries()) {\n\t\t\t\terrors.push([key, new UnknownPropertyError(key, value)]);\n\t\t\t}\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(finalResult)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n\n\tprivate handlePassthroughStrategy(value: object): Result<I, CombinedPropertyError> {\n\t\tconst result = this.handleIgnoreStrategy(value);\n\t\treturn result.isErr() ? result : Result.ok({ ...value, ...result.value } as I);\n\t}\n}\n\nexport enum ObjectValidatorStrategy {\n\tIgnore,\n\tStrict,\n\tPassthrough\n}\n","import type { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class PassthroughValidator<T extends any | unknown> extends BaseValidator<T> {\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn Result.ok(value as T);\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class RecordValidator<T> extends BaseValidator<Record<string, T>> {\n\tprivate readonly validator: BaseValidator<T>;\n\n\tpublic constructor(validator: BaseValidator<T>, constraints: readonly IConstraint<Record<string, T>>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<Record<string, T>, ValidationError | CombinedPropertyError> {\n\t\tif (typeof value !== 'object') {\n\t\t\treturn Result.err(new ValidationError('s.record(T)', 'Expected an object', value));\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn Result.err(new ValidationError('s.record(T)', 'Expected the value to not be null', value));\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn Result.err(new ValidationError('s.record(T)', 'Expected the value to not be an array', value));\n\t\t}\n\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn Result.ok(value as Record<string, T>);\n\t\t}\n\n\t\tconst errors: [string, BaseError][] = [];\n\t\tconst transformed: Record<string, T> = {};\n\n\t\tfor (const [key, val] of Object.entries(value!)) {\n\t\t\tconst result = this.validator.run(val);\n\t\t\tif (result.isOk()) transformed[key] = result.value;\n\t\t\telse errors.push([key, result.error!]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedError } from '../lib/errors/CombinedError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class SetValidator<T> extends BaseValidator<Set<T>> {\n\tprivate readonly validator: BaseValidator<T>;\n\n\tpublic constructor(validator: BaseValidator<T>, constraints: readonly IConstraint<Set<T>>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<Set<T>, ValidationError | CombinedError> {\n\t\tif (!(values instanceof Set)) {\n\t\t\treturn Result.err(new ValidationError('s.set(T)', 'Expected a set', values));\n\t\t}\n\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn Result.ok(values);\n\t\t}\n\n\t\tconst errors: BaseError[] = [];\n\t\tconst transformed = new Set<T>();\n\n\t\tfor (const value of values) {\n\t\t\tconst result = this.validator.run(value);\n\t\t\tif (result.isOk()) transformed.add(result.value);\n\t\t\telse errors.push(result.error!);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedError(errors));\n\t}\n}\n","/**\n * [RFC-5322](https://datatracker.ietf.org/doc/html/rfc5322)\n * compliant {@link RegExp} to validate an email address\n *\n * @see https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression/201378#201378\n */\nconst accountRegex =\n\t/^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")$/;\n\n/**\n * Validates an email address string based on various checks:\n * - It must be a non nullish and non empty string\n * - It must include at least an `@` symbol`\n * - The account name may not exceed 64 characters\n * - The domain name may not exceed 255 characters\n * - The domain must include at least one `.` symbol\n * - Each part of the domain, split by `.` must not exceed 63 characters\n * - The email address must be [RFC-5322](https://datatracker.ietf.org/doc/html/rfc5322) compliant\n * @param email The email to validate\n * @returns `true` if the email is valid, `false` otherwise\n *\n * @remark Based on the following sources:\n * - `email-validator` by [manisharaan](https://github.com/manishsaraan) ([code](https://github.com/manishsaraan/email-validator/blob/master/index.js))\n * - [Comparing E-mail Address Validating Regular Expressions](http://fightingforalostcause.net/misc/2006/compare-email-regex.php)\n * - [Validating Email Addresses by Derrick Pallas](http://thedailywtf.com/Articles/Validating_Email_Addresses.aspx)\n * - [StackOverflow answer by bortzmeyer](http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/201378#201378)\n * - [The wikipedia page on Email addresses](https://en.wikipedia.org/wiki/Email_address)\n */\nexport function validateEmail(email: string): boolean {\n\t// 1. Non-nullish and non-empty string check.\n\t//\n\t// If a nullish or empty email was provided then do an early exit\n\tif (!email) return false;\n\n\t// Find the location of the @ symbol:\n\tconst atIndex = email.indexOf('@');\n\n\t// 2. @ presence check.\n\t//\n\t// If the email does not have the @ symbol, it's automatically invalid:\n\tif (atIndex === -1) return false;\n\n\t// 3. <account> maximum length check.\n\t//\n\t// From <account>@<domain>, if <account> exceeds 64 characters, then the\n\t// position of the @ symbol is 64 or greater. In this case, the email is\n\t// invalid:\n\tif (atIndex > 64) return false;\n\n\tconst domainIndex = atIndex + 1;\n\n\t// 7.1. Duplicated @ symbol check.\n\t//\n\t// If there's a second @ symbol, the email is automatically invalid:\n\tif (email.includes('@', domainIndex)) return false;\n\n\t// 4. <domain> maximum length check.\n\t//\n\t// From <account>@<domain>, if <domain> exceeds 255 characters, then it\n\t// means that the amount of characters between the start of <domain> and the\n\t// end of the string is separated by 255 or more characters.\n\tif (email.length - domainIndex > 255) return false;\n\n\t// Find the location of the . symbol in <domain>:\n\tlet dotIndex = email.indexOf('.', domainIndex);\n\n\t// 5. <domain> dot (.) symbol check.\n\t//\n\t// From <account>@<domain>, if <domain> does not contain a dot (.) symbol,\n\t// then it means the domain is invalid.\n\tif (dotIndex === -1) return false;\n\n\t// 6. <domain> parts length.\n\t//\n\t// Assign a temporary variable to store the start of the last read domain\n\t// part, this would be at the start of <domain>.\n\t//\n\t// For a <domain> part to be correct, it must have at most, 63 characters.\n\t// We repeat this step for every sub-section of <domain> contained within\n\t// dot (.) symbols.\n\t//\n\t// The following step is a more optimized version of the following code:\n\t//\n\t// ```javascript\n\t// domain.split('.').some((part) => part.length > 63);\n\t// ```\n\tlet lastDotIndex = domainIndex;\n\tdo {\n\t\tif (dotIndex - lastDotIndex > 63) return false;\n\n\t\tlastDotIndex = dotIndex + 1;\n\t} while ((dotIndex = email.indexOf('.', lastDotIndex)) !== -1);\n\n\t// The loop iterates from the first to the n - 1 part, this line checks for\n\t// the last (n) part:\n\tif (email.length - lastDotIndex > 63) return false;\n\n\t// 7.2. Character checks.\n\t//\n\t// From <account>@<domain>:\n\t// - Extract the <account> part by slicing the input from start to the @\n\t//   character. Validate afterwards.\n\t// - Extract the <domain> part by slicing the input from the start of\n\t//   <domain>. Validate afterwards.\n\t//\n\t// Note: we inline the variables so <domain> isn't created unless the\n\t//       <account> check passes.\n\treturn accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));\n}\n\nfunction validateEmailDomain(domain: string): boolean {\n\ttry {\n\t\treturn new URL(`http://${domain}`).hostname === domain;\n\t} catch {\n\t\treturn false;\n\t}\n}\n","/**\n * Code ported from https://github.com/nodejs/node/blob/5fad0b93667ffc6e4def52996b9529ac99b26319/lib/internal/net.js\n */\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})';\nconst IPv6Reg = new RegExp(\n\t'^(' +\n\t\t`(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n\t\t`(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n\t\t`(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n\t\t`(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n\t\t`(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n\t\t`(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n\t\t`(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n\t\t`(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n\t\t')(%[0-9a-zA-Z-.:]{1,})?$'\n);\n\nexport function isIPv4(s: string): boolean {\n\treturn IPv4Reg.test(s);\n}\n\nexport function isIPv6(s: string): boolean {\n\treturn IPv6Reg.test(s);\n}\n\nexport function isIP(s: string): number {\n\tif (isIPv4(s)) return 4;\n\tif (isIPv6(s)) return 6;\n\treturn 0;\n}\n","export const phoneNumberRegex = /^((?:\\+|0{0,2})\\d{1,2}\\s?)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}$/;\n\nexport function validatePhoneNumber(input: string) {\n\treturn phoneNumberRegex.test(input);\n}\n","import { inspect, type InspectOptionsStylized } from 'util';\nimport { customInspectSymbolStackLess } from './BaseError';\nimport { BaseConstraintError, type ConstraintErrorNames } from './BaseConstraintError';\n\nexport class MultiplePossibilitiesConstraintError<T = unknown> extends BaseConstraintError<T> {\n\tpublic readonly expected: readonly string[];\n\n\tpublic constructor(constraint: ConstraintErrorNames, message: string, given: T, expected: readonly string[]) {\n\t\tsuper(constraint, message, given);\n\t\tthis.expected = expected;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tconstraint: this.constraint,\n\t\t\tgiven: this.given,\n\t\t\texpected: this.expected\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst constraint = options.stylize(this.constraint, 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, 'special');\n\t\t}\n\n\t\tconst newOptions = { ...options, depth: options.depth === null ? null : options.depth! - 1 };\n\n\t\tconst verticalLine = options.stylize('|', 'undefined');\n\t\tconst padding = `\\n  ${verticalLine} `;\n\t\tconst given = inspect(this.given, newOptions).replace(/\\n/g, padding);\n\n\t\tconst header = `${options.stylize('MultiplePossibilitiesConstraintError', 'special')} > ${constraint}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\n\t\tconst expectedPadding = `\\n  ${verticalLine} - `;\n\t\tconst expectedBlock = `\\n  ${options.stylize('Expected any of the following:', 'string')}${expectedPadding}${this.expected\n\t\t\t.map((possible) => options.stylize(possible, 'boolean'))\n\t\t\t.join(expectedPadding)}`;\n\t\tconst givenBlock = `\\n  ${options.stylize('Received:', 'regexp')}${padding}${given}`;\n\t\treturn `${header}\\n  ${message}\\n${expectedBlock}\\n${givenBlock}`;\n\t}\n}\n","export function combinedErrorFn<P extends [...any], E extends Error>(...fns: ErrorFn<P, E>[]): ErrorFn<P, E> {\n\tswitch (fns.length) {\n\t\tcase 0:\n\t\t\treturn () => null;\n\t\tcase 1:\n\t\t\treturn fns[0];\n\t\tcase 2: {\n\t\t\tconst [fn0, fn1] = fns;\n\t\t\treturn (...params) => fn0(...params) || fn1(...params);\n\t\t}\n\t\tdefault: {\n\t\t\treturn (...params) => {\n\t\t\t\tfor (const fn of fns) {\n\t\t\t\t\tconst result = fn(...params);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport type ErrorFn<P extends [...any], E extends Error> = (...params: P) => E | null;\n","import { MultiplePossibilitiesConstraintError } from '../../lib/errors/MultiplePossibilitiesConstraintError';\nimport { combinedErrorFn, type ErrorFn } from './common/combinedResultFn';\n\nexport type StringProtocol = `${string}:`;\n\nexport type StringDomain = `${string}.${string}`;\n\nexport interface UrlOptions {\n\tallowedProtocols?: StringProtocol[];\n\tallowedDomains?: StringDomain[];\n}\n\nexport function createUrlValidators(options?: UrlOptions) {\n\tconst fns: ErrorFn<[input: string, url: URL], MultiplePossibilitiesConstraintError<string>>[] = [];\n\n\tif (options?.allowedProtocols?.length) fns.push(allowedProtocolsFn(options.allowedProtocols));\n\tif (options?.allowedDomains?.length) fns.push(allowedDomainsFn(options.allowedDomains));\n\n\treturn combinedErrorFn(...fns);\n}\n\nfunction allowedProtocolsFn(allowedProtocols: StringProtocol[]) {\n\treturn (input: string, url: URL) =>\n\t\tallowedProtocols.includes(url.protocol as StringProtocol)\n\t\t\t? null\n\t\t\t: new MultiplePossibilitiesConstraintError('s.string.url', 'Invalid URL protocol', input, allowedProtocols);\n}\n\nfunction allowedDomainsFn(allowedDomains: StringDomain[]) {\n\treturn (input: string, url: URL) =>\n\t\tallowedDomains.includes(url.hostname as StringDomain)\n\t\t\t? null\n\t\t\t: new MultiplePossibilitiesConstraintError('s.string.url', 'Invalid URL domain', input, allowedDomains);\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { validateEmail } from './util/emailValidator';\nimport { isIP, isIPv4, isIPv6 } from './util/net';\nimport { equal, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, notEqual, type Comparator } from './util/operators';\nimport { validatePhoneNumber } from './util/phoneValidator';\nimport { createUrlValidators } from './util/urlValidators';\n\nexport type StringConstraintName =\n\t| `s.string.${\n\t\t\t| `length${'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'Equal' | 'NotEqual'}`\n\t\t\t| 'regex'\n\t\t\t| 'url'\n\t\t\t| 'uuid'\n\t\t\t| 'email'\n\t\t\t| `ip${'v4' | 'v6' | ''}`\n\t\t\t| 'date'\n\t\t\t| 'phone'}`;\n\nexport type StringProtocol = `${string}:`;\n\nexport type StringDomain = `${string}.${string}`;\n\nexport interface UrlOptions {\n\tallowedProtocols?: StringProtocol[];\n\tallowedDomains?: StringDomain[];\n}\n\nexport type UUIDVersion = 1 | 3 | 4 | 5;\n\nexport interface StringUuidOptions {\n\tversion?: UUIDVersion | `${UUIDVersion}-${UUIDVersion}` | null;\n\tnullable?: boolean;\n}\n\nfunction stringLengthComparator(comparator: Comparator, name: StringConstraintName, expected: string, length: number): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn comparator(input.length, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid string length', input, expected));\n\t\t}\n\t};\n}\n\nexport function stringLengthLessThan(length: number): IConstraint<string> {\n\tconst expected = `expected.length < ${length}`;\n\treturn stringLengthComparator(lessThan, 's.string.lengthLessThan', expected, length);\n}\n\nexport function stringLengthLessThanOrEqual(length: number): IConstraint<string> {\n\tconst expected = `expected.length <= ${length}`;\n\treturn stringLengthComparator(lessThanOrEqual, 's.string.lengthLessThanOrEqual', expected, length);\n}\n\nexport function stringLengthGreaterThan(length: number): IConstraint<string> {\n\tconst expected = `expected.length > ${length}`;\n\treturn stringLengthComparator(greaterThan, 's.string.lengthGreaterThan', expected, length);\n}\n\nexport function stringLengthGreaterThanOrEqual(length: number): IConstraint<string> {\n\tconst expected = `expected.length >= ${length}`;\n\treturn stringLengthComparator(greaterThanOrEqual, 's.string.lengthGreaterThanOrEqual', expected, length);\n}\n\nexport function stringLengthEqual(length: number): IConstraint<string> {\n\tconst expected = `expected.length === ${length}`;\n\treturn stringLengthComparator(equal, 's.string.lengthEqual', expected, length);\n}\n\nexport function stringLengthNotEqual(length: number): IConstraint<string> {\n\tconst expected = `expected.length !== ${length}`;\n\treturn stringLengthComparator(notEqual, 's.string.lengthNotEqual', expected, length);\n}\n\nexport function stringEmail(): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn validateEmail(input)\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.string.email', 'Invalid email address', input, 'expected to be an email address'));\n\t\t}\n\t};\n}\n\nfunction stringRegexValidator(type: StringConstraintName, expected: string, regex: RegExp): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn regex.test(input) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(type, 'Invalid string format', input, expected));\n\t\t}\n\t};\n}\n\nexport function stringUrl(options?: UrlOptions): IConstraint<string> {\n\tconst validatorFn = createUrlValidators(options);\n\treturn {\n\t\trun(input: string) {\n\t\t\tlet url: URL;\n\t\t\ttry {\n\t\t\t\turl = new URL(input);\n\t\t\t} catch {\n\t\t\t\treturn Result.err(new ExpectedConstraintError('s.string.url', 'Invalid URL', input, 'expected to match an URL'));\n\t\t\t}\n\n\t\t\tconst validatorFnResult = validatorFn(input, url);\n\t\t\tif (validatorFnResult === null) return Result.ok(input);\n\t\t\treturn Result.err(validatorFnResult);\n\t\t}\n\t};\n}\n\nexport function stringIp(version?: 4 | 6): IConstraint<string> {\n\tconst ipVersion = version ? (`v${version}` as const) : '';\n\tconst validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;\n\n\tconst name = `s.string.ip${ipVersion}` as const;\n\tconst message = `Invalid IP${ipVersion} address`;\n\tconst expected = `expected to be an IP${ipVersion} address`;\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));\n\t\t}\n\t};\n}\n\nexport function stringRegex(regex: RegExp) {\n\treturn stringRegexValidator('s.string.regex', `expected ${regex}.test(expected) to be true`, regex);\n}\n\nexport function stringUuid({ version = 4, nullable = false }: StringUuidOptions = {}) {\n\tversion ??= '1-5';\n\tconst regex = new RegExp(\n\t\t`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${\n\t\t\tnullable ? '|00000000-0000-0000-0000-000000000000' : ''\n\t\t})$`,\n\t\t'i'\n\t);\n\tconst expected = `expected to match UUID${typeof version === 'number' ? `v${version}` : ` in range of ${version}`}`;\n\treturn stringRegexValidator('s.string.uuid', expected, regex);\n}\n\nexport function stringDate(): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\tconst time = Date.parse(input);\n\n\t\t\treturn Number.isNaN(time)\n\t\t\t\t? Result.err(\n\t\t\t\t\t\tnew ExpectedConstraintError(\n\t\t\t\t\t\t\t's.string.date',\n\t\t\t\t\t\t\t'Invalid date string',\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t'expected to be a valid date string (in the ISO 8601 or ECMA-262 format)'\n\t\t\t\t\t\t)\n\t\t\t\t  )\n\t\t\t\t: Result.ok(input);\n\t\t}\n\t};\n}\n\nexport function stringPhone(): IConstraint<string> {\n\treturn {\n\t\trun(input: string) {\n\t\t\treturn validatePhoneNumber(input)\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.string.phone', 'Invalid phone number', input, 'expected to be a phone number'));\n\t\t}\n\t};\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport {\n\tstringDate,\n\tstringEmail,\n\tstringIp,\n\tstringLengthEqual,\n\tstringLengthGreaterThan,\n\tstringLengthGreaterThanOrEqual,\n\tstringLengthLessThan,\n\tstringLengthLessThanOrEqual,\n\tstringLengthNotEqual,\n\tstringPhone,\n\tstringRegex,\n\tstringUrl,\n\tstringUuid,\n\ttype StringUuidOptions,\n\ttype UrlOptions\n} from '../constraints/StringConstraints';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class StringValidator<T extends string> extends BaseValidator<T> {\n\tpublic lengthLessThan(length: number): this {\n\t\treturn this.addConstraint(stringLengthLessThan(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthLessThanOrEqual(length: number): this {\n\t\treturn this.addConstraint(stringLengthLessThanOrEqual(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthGreaterThan(length: number): this {\n\t\treturn this.addConstraint(stringLengthGreaterThan(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthGreaterThanOrEqual(length: number): this {\n\t\treturn this.addConstraint(stringLengthGreaterThanOrEqual(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthEqual(length: number): this {\n\t\treturn this.addConstraint(stringLengthEqual(length) as IConstraint<T>);\n\t}\n\n\tpublic lengthNotEqual(length: number): this {\n\t\treturn this.addConstraint(stringLengthNotEqual(length) as IConstraint<T>);\n\t}\n\n\tpublic get email(): this {\n\t\treturn this.addConstraint(stringEmail() as IConstraint<T>);\n\t}\n\n\tpublic url(options?: UrlOptions): this {\n\t\treturn this.addConstraint(stringUrl(options) as IConstraint<T>);\n\t}\n\n\tpublic uuid(options?: StringUuidOptions): this {\n\t\treturn this.addConstraint(stringUuid(options) as IConstraint<T>);\n\t}\n\n\tpublic regex(regex: RegExp): this {\n\t\treturn this.addConstraint(stringRegex(regex) as IConstraint<T>);\n\t}\n\n\tpublic get date() {\n\t\treturn this.addConstraint(stringDate() as IConstraint<T>);\n\t}\n\n\tpublic get ipv4(): this {\n\t\treturn this.ip(4);\n\t}\n\n\tpublic get ipv6(): this {\n\t\treturn this.ip(6);\n\t}\n\n\tpublic ip(version?: 4 | 6): this {\n\t\treturn this.addConstraint(stringIp(version) as IConstraint<T>);\n\t}\n\n\tpublic phone(): this {\n\t\treturn this.addConstraint(stringPhone() as IConstraint<T>);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn typeof value === 'string' //\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.string', 'Expected a string primitive', value));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class TupleValidator<T extends any[]> extends BaseValidator<[...T]> {\n\tprivate readonly validators: BaseValidator<[...T]>[] = [];\n\n\tpublic constructor(validators: BaseValidator<[...T]>[], constraints: readonly IConstraint<[...T]>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validators = validators;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validators, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<[...T], ValidationError | CombinedPropertyError> {\n\t\tif (!Array.isArray(values)) {\n\t\t\treturn Result.err(new ValidationError('s.tuple(T)', 'Expected an array', values));\n\t\t}\n\n\t\tif (values.length !== this.validators.length) {\n\t\t\treturn Result.err(new ValidationError('s.tuple(T)', `Expected an array of length ${this.validators.length}`, values));\n\t\t}\n\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn Result.ok(values as [...T]);\n\t\t}\n\n\t\tconst errors: [number, BaseError][] = [];\n\t\tconst transformed: T = [] as unknown as T;\n\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst result = this.validators[i].run(values[i]);\n\t\t\tif (result.isOk()) transformed.push(result.value);\n\t\t\telse errors.push([i, result.error!]);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport type { BaseError } from '../lib/errors/BaseError';\nimport { CombinedPropertyError } from '../lib/errors/CombinedPropertyError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class MapValidator<K, V> extends BaseValidator<Map<K, V>> {\n\tprivate readonly keyValidator: BaseValidator<K>;\n\tprivate readonly valueValidator: BaseValidator<V>;\n\n\tpublic constructor(keyValidator: BaseValidator<K>, valueValidator: BaseValidator<V>, constraints: readonly IConstraint<Map<K, V>>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.keyValidator = keyValidator;\n\t\tthis.valueValidator = valueValidator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<Map<K, V>, ValidationError | CombinedPropertyError> {\n\t\tif (!(value instanceof Map)) {\n\t\t\treturn Result.err(new ValidationError('s.map(K, V)', 'Expected a map', value));\n\t\t}\n\n\t\tif (!this.shouldRunConstraints) {\n\t\t\treturn Result.ok(value);\n\t\t}\n\n\t\tconst errors: [string, BaseError][] = [];\n\t\tconst transformed = new Map<K, V>();\n\n\t\tfor (const [key, val] of value.entries()) {\n\t\t\tconst keyResult = this.keyValidator.run(key);\n\t\t\tconst valueResult = this.valueValidator.run(val);\n\t\t\tconst { length } = errors;\n\t\t\tif (keyResult.isErr()) errors.push([key, keyResult.error]);\n\t\t\tif (valueResult.isErr()) errors.push([key, valueResult.error]);\n\t\t\tif (errors.length === length) transformed.set(keyResult.value!, valueResult.value!);\n\t\t}\n\n\t\treturn errors.length === 0 //\n\t\t\t? Result.ok(transformed)\n\t\t\t: Result.err(new CombinedPropertyError(errors));\n\t}\n}\n","import type { Result } from '../lib/Result';\nimport type { IConstraint, Unwrap } from '../type-exports';\nimport { BaseValidator, type ValidatorError } from './imports';\n\nexport class LazyValidator<T extends BaseValidator<unknown>, R = Unwrap<T>> extends BaseValidator<R> {\n\tprivate readonly validator: (value: unknown) => T;\n\n\tpublic constructor(validator: (value: unknown) => T, constraints: readonly IConstraint<R>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.validator = validator;\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.validator, this.constraints]);\n\t}\n\n\tprotected handle(values: unknown): Result<R, ValidatorError> {\n\t\treturn this.validator(values).run(values) as Result<R, ValidatorError>;\n\t}\n}\n","import type { InspectOptionsStylized } from 'util';\nimport { BaseError, customInspectSymbolStackLess } from './BaseError';\n\nexport class UnknownEnumValueError extends BaseError {\n\tpublic readonly value: string | number;\n\tpublic readonly enumKeys: string[];\n\tpublic readonly enumMappings: Map<string | number, string | number>;\n\n\tpublic constructor(value: string | number, keys: string[], enumMappings: Map<string | number, string | number>) {\n\t\tsuper('Expected the value to be one of the following enum values:');\n\n\t\tthis.value = value;\n\t\tthis.enumKeys = keys;\n\t\tthis.enumMappings = enumMappings;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tvalue: this.value,\n\t\t\tenumKeys: this.enumKeys,\n\t\t\tenumMappings: [...this.enumMappings.entries()]\n\t\t};\n\t}\n\n\tprotected [customInspectSymbolStackLess](depth: number, options: InspectOptionsStylized): string {\n\t\tconst value = options.stylize(this.value.toString(), 'string');\n\t\tif (depth < 0) {\n\t\t\treturn options.stylize(`[UnknownEnumValueError: ${value}]`, 'special');\n\t\t}\n\n\t\tconst padding = `\\n  ${options.stylize('|', 'undefined')} `;\n\t\tconst pairs = this.enumKeys\n\t\t\t.map((key) => {\n\t\t\t\tconst enumValue = this.enumMappings.get(key)!;\n\t\t\t\treturn `${options.stylize(key, 'string')} or ${options.stylize(\n\t\t\t\t\tenumValue.toString(),\n\t\t\t\t\ttypeof enumValue === 'number' ? 'number' : 'string'\n\t\t\t\t)}`;\n\t\t\t})\n\t\t\t.join(padding);\n\n\t\tconst header = `${options.stylize('UnknownEnumValueError', 'special')} > ${value}`;\n\t\tconst message = options.stylize(this.message, 'regexp');\n\t\tconst pairsBlock = `${padding}${pairs}`;\n\t\treturn `${header}\\n  ${message}\\n${pairsBlock}`;\n\t}\n}\n","import { UnknownEnumValueError } from '../lib/errors/UnknownEnumValueError';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class NativeEnumValidator<T extends NativeEnumLike> extends BaseValidator<T[keyof T]> {\n\tpublic readonly enumShape: T;\n\tpublic readonly hasNumericElements: boolean = false;\n\tprivate readonly enumKeys: string[];\n\tprivate readonly enumMapping = new Map<string | number, T[keyof T]>();\n\n\tpublic constructor(enumShape: T) {\n\t\tsuper();\n\t\tthis.enumShape = enumShape;\n\n\t\tthis.enumKeys = Object.keys(enumShape).filter((key) => {\n\t\t\treturn typeof enumShape[enumShape[key]] !== 'number';\n\t\t});\n\n\t\tfor (const key of this.enumKeys) {\n\t\t\tconst enumValue = enumShape[key] as T[keyof T];\n\n\t\t\tthis.enumMapping.set(key, enumValue);\n\t\t\tthis.enumMapping.set(enumValue, enumValue);\n\n\t\t\tif (typeof enumValue === 'number') {\n\t\t\t\tthis.hasNumericElements = true;\n\t\t\t\tthis.enumMapping.set(`${enumValue}`, enumValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected override handle(value: unknown): Result<T[keyof T], ValidationError | UnknownEnumValueError> {\n\t\tconst typeOfValue = typeof value;\n\n\t\tif (typeOfValue === 'number') {\n\t\t\tif (!this.hasNumericElements) {\n\t\t\t\treturn Result.err(new ValidationError('s.nativeEnum(T)', 'Expected the value to be a string', value));\n\t\t\t}\n\t\t} else if (typeOfValue !== 'string') {\n\t\t\t// typeOfValue !== 'number' is implied here\n\t\t\treturn Result.err(new ValidationError('s.nativeEnum(T)', 'Expected the value to be a string or number', value));\n\t\t}\n\n\t\tconst casted = value as string | number;\n\n\t\tconst possibleEnumValue = this.enumMapping.get(casted);\n\n\t\treturn typeof possibleEnumValue === 'undefined'\n\t\t\t? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping))\n\t\t\t: Result.ok(possibleEnumValue);\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.enumShape]);\n\t}\n}\n\nexport interface NativeEnumLike {\n\t[key: string]: string | number;\n\t[key: number]: string;\n}\n","import { ExpectedConstraintError } from '../lib/errors/ExpectedConstraintError';\nimport { Result } from '../lib/Result';\nimport type { IConstraint } from './base/IConstraint';\nimport { equal, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, notEqual, type Comparator } from './util/operators';\nimport type { TypedArray } from './util/typedArray';\n\nexport type TypedArrayConstraintName = `s.typedArray(T).${'byteLength' | 'length'}${\n\t| 'LessThan'\n\t| 'LessThanOrEqual'\n\t| 'GreaterThan'\n\t| 'GreaterThanOrEqual'\n\t| 'Equal'\n\t| 'NotEqual'\n\t| 'Range'\n\t| 'RangeInclusive'\n\t| 'RangeExclusive'}`;\n\nfunction typedArrayByteLengthComparator<T extends TypedArray>(\n\tcomparator: Comparator,\n\tname: TypedArrayConstraintName,\n\texpected: string,\n\tlength: number\n): IConstraint<T> {\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn comparator(input.byteLength, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Typed Array byte length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayByteLengthLessThan<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength < ${value}`;\n\treturn typedArrayByteLengthComparator(lessThan, 's.typedArray(T).byteLengthLessThan', expected, value);\n}\n\nexport function typedArrayByteLengthLessThanOrEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength <= ${value}`;\n\treturn typedArrayByteLengthComparator(lessThanOrEqual, 's.typedArray(T).byteLengthLessThanOrEqual', expected, value);\n}\n\nexport function typedArrayByteLengthGreaterThan<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength > ${value}`;\n\treturn typedArrayByteLengthComparator(greaterThan, 's.typedArray(T).byteLengthGreaterThan', expected, value);\n}\n\nexport function typedArrayByteLengthGreaterThanOrEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength >= ${value}`;\n\treturn typedArrayByteLengthComparator(greaterThanOrEqual, 's.typedArray(T).byteLengthGreaterThanOrEqual', expected, value);\n}\n\nexport function typedArrayByteLengthEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength === ${value}`;\n\treturn typedArrayByteLengthComparator(equal, 's.typedArray(T).byteLengthEqual', expected, value);\n}\n\nexport function typedArrayByteLengthNotEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.byteLength !== ${value}`;\n\treturn typedArrayByteLengthComparator(notEqual, 's.typedArray(T).byteLengthNotEqual', expected, value);\n}\n\nexport function typedArrayByteLengthRange<T extends TypedArray>(start: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.byteLength >= start && input.byteLength < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).byteLengthRange', 'Invalid Typed Array byte length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayByteLengthRangeInclusive<T extends TypedArray>(start: number, end: number) {\n\tconst expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.byteLength >= start && input.byteLength <= end //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(\n\t\t\t\t\t\tnew ExpectedConstraintError('s.typedArray(T).byteLengthRangeInclusive', 'Invalid Typed Array byte length', input, expected)\n\t\t\t\t  );\n\t\t}\n\t};\n}\n\nexport function typedArrayByteLengthRangeExclusive<T extends TypedArray>(startAfter: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.byteLength > startAfter && input.byteLength < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(\n\t\t\t\t\t\tnew ExpectedConstraintError('s.typedArray(T).byteLengthRangeExclusive', 'Invalid Typed Array byte length', input, expected)\n\t\t\t\t  );\n\t\t}\n\t};\n}\n\nfunction typedArrayLengthComparator<T extends TypedArray>(\n\tcomparator: Comparator,\n\tname: TypedArrayConstraintName,\n\texpected: string,\n\tlength: number\n): IConstraint<T> {\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn comparator(input.length, length) //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError(name, 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayLengthLessThan<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length < ${value}`;\n\treturn typedArrayLengthComparator(lessThan, 's.typedArray(T).lengthLessThan', expected, value);\n}\n\nexport function typedArrayLengthLessThanOrEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length <= ${value}`;\n\treturn typedArrayLengthComparator(lessThanOrEqual, 's.typedArray(T).lengthLessThanOrEqual', expected, value);\n}\n\nexport function typedArrayLengthGreaterThan<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length > ${value}`;\n\treturn typedArrayLengthComparator(greaterThan, 's.typedArray(T).lengthGreaterThan', expected, value);\n}\n\nexport function typedArrayLengthGreaterThanOrEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length >= ${value}`;\n\treturn typedArrayLengthComparator(greaterThanOrEqual, 's.typedArray(T).lengthGreaterThanOrEqual', expected, value);\n}\n\nexport function typedArrayLengthEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length === ${value}`;\n\treturn typedArrayLengthComparator(equal, 's.typedArray(T).lengthEqual', expected, value);\n}\n\nexport function typedArrayLengthNotEqual<T extends TypedArray>(value: number): IConstraint<T> {\n\tconst expected = `expected.length !== ${value}`;\n\treturn typedArrayLengthComparator(notEqual, 's.typedArray(T).lengthNotEqual', expected, value);\n}\n\nexport function typedArrayLengthRange<T extends TypedArray>(start: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.length >= ${start} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.length >= start && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).lengthRange', 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayLengthRangeInclusive<T extends TypedArray>(start: number, end: number): IConstraint<T> {\n\tconst expected = `expected.length >= ${start} && expected.length <= ${end}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.length >= start && input.length <= end //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).lengthRangeInclusive', 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n\nexport function typedArrayLengthRangeExclusive<T extends TypedArray>(startAfter: number, endBefore: number): IConstraint<T> {\n\tconst expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;\n\treturn {\n\t\trun(input: T) {\n\t\t\treturn input.length > startAfter && input.length < endBefore //\n\t\t\t\t? Result.ok(input)\n\t\t\t\t: Result.err(new ExpectedConstraintError('s.typedArray(T).lengthRangeExclusive', 'Invalid Typed Array length', input, expected));\n\t\t}\n\t};\n}\n","const vowels = ['a', 'e', 'i', 'o', 'u'];\n\nexport const aOrAn = (word: string) => {\n\treturn `${vowels.includes(word[0].toLowerCase()) ? 'an' : 'a'} ${word}`;\n};\n","export type TypedArray =\n\t| Int8Array\n\t| Uint8Array\n\t| Uint8ClampedArray\n\t| Int16Array\n\t| Uint16Array\n\t| Int32Array\n\t| Uint32Array\n\t| Float32Array\n\t| Float64Array\n\t| BigInt64Array\n\t| BigUint64Array;\n\nexport const TypedArrays = {\n\tInt8Array: (x: unknown): x is Int8Array => x instanceof Int8Array,\n\tUint8Array: (x: unknown): x is Uint8Array => x instanceof Uint8Array,\n\tUint8ClampedArray: (x: unknown): x is Uint8ClampedArray => x instanceof Uint8ClampedArray,\n\tInt16Array: (x: unknown): x is Int16Array => x instanceof Int16Array,\n\tUint16Array: (x: unknown): x is Uint16Array => x instanceof Uint16Array,\n\tInt32Array: (x: unknown): x is Int32Array => x instanceof Int32Array,\n\tUint32Array: (x: unknown): x is Uint32Array => x instanceof Uint32Array,\n\tFloat32Array: (x: unknown): x is Float32Array => x instanceof Float32Array,\n\tFloat64Array: (x: unknown): x is Float64Array => x instanceof Float64Array,\n\tBigInt64Array: (x: unknown): x is BigInt64Array => x instanceof BigInt64Array,\n\tBigUint64Array: (x: unknown): x is BigUint64Array => x instanceof BigUint64Array,\n\tTypedArray: (x: unknown): x is TypedArray => ArrayBuffer.isView(x) && !(x instanceof DataView)\n} as const;\n\nexport type TypedArrayName = keyof typeof TypedArrays;\n","import type { IConstraint } from '../constraints/base/IConstraint';\nimport {\n\ttypedArrayByteLengthEqual,\n\ttypedArrayByteLengthGreaterThan,\n\ttypedArrayByteLengthGreaterThanOrEqual,\n\ttypedArrayByteLengthLessThan,\n\ttypedArrayByteLengthLessThanOrEqual,\n\ttypedArrayByteLengthNotEqual,\n\ttypedArrayByteLengthRange,\n\ttypedArrayByteLengthRangeExclusive,\n\ttypedArrayByteLengthRangeInclusive,\n\ttypedArrayLengthEqual,\n\ttypedArrayLengthGreaterThan,\n\ttypedArrayLengthGreaterThanOrEqual,\n\ttypedArrayLengthLessThan,\n\ttypedArrayLengthLessThanOrEqual,\n\ttypedArrayLengthNotEqual,\n\ttypedArrayLengthRange,\n\ttypedArrayLengthRangeExclusive,\n\ttypedArrayLengthRangeInclusive\n} from '../constraints/TypedArrayLengthConstraints';\nimport { aOrAn } from '../constraints/util/common/vowels';\nimport { TypedArrays, type TypedArray, type TypedArrayName } from '../constraints/util/typedArray';\nimport { ValidationError } from '../lib/errors/ValidationError';\nimport { Result } from '../lib/Result';\nimport { BaseValidator } from './imports';\n\nexport class TypedArrayValidator<T extends TypedArray> extends BaseValidator<T> {\n\tprivate readonly type: TypedArrayName;\n\n\tpublic constructor(type: TypedArrayName, constraints: readonly IConstraint<T>[] = []) {\n\t\tsuper(constraints);\n\t\tthis.type = type;\n\t}\n\n\tpublic byteLengthLessThan(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthLessThan(length));\n\t}\n\n\tpublic byteLengthLessThanOrEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));\n\t}\n\n\tpublic byteLengthGreaterThan(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthGreaterThan(length));\n\t}\n\n\tpublic byteLengthGreaterThanOrEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));\n\t}\n\n\tpublic byteLengthEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthEqual(length));\n\t}\n\n\tpublic byteLengthNotEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthNotEqual(length));\n\t}\n\n\tpublic byteLengthRange(start: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthRange(start, endBefore));\n\t}\n\n\tpublic byteLengthRangeInclusive(startAt: number, endAt: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt) as IConstraint<T>);\n\t}\n\n\tpublic byteLengthRangeExclusive(startAfter: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));\n\t}\n\n\tpublic lengthLessThan(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthLessThan(length));\n\t}\n\n\tpublic lengthLessThanOrEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthLessThanOrEqual(length));\n\t}\n\n\tpublic lengthGreaterThan(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthGreaterThan(length));\n\t}\n\n\tpublic lengthGreaterThanOrEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));\n\t}\n\n\tpublic lengthEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthEqual(length));\n\t}\n\n\tpublic lengthNotEqual(length: number) {\n\t\treturn this.addConstraint(typedArrayLengthNotEqual(length));\n\t}\n\n\tpublic lengthRange(start: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayLengthRange(start, endBefore));\n\t}\n\n\tpublic lengthRangeInclusive(startAt: number, endAt: number) {\n\t\treturn this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));\n\t}\n\n\tpublic lengthRangeExclusive(startAfter: number, endBefore: number) {\n\t\treturn this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));\n\t}\n\n\tprotected override clone(): this {\n\t\treturn Reflect.construct(this.constructor, [this.type, this.constraints]);\n\t}\n\n\tprotected handle(value: unknown): Result<T, ValidationError> {\n\t\treturn TypedArrays[this.type](value)\n\t\t\t? Result.ok(value as T)\n\t\t\t: Result.err(new ValidationError('s.typedArray', `Expected ${aOrAn(this.type)}`, value));\n\t}\n}\n","import type { TypedArray, TypedArrayName } from '../constraints/util/typedArray';\nimport type { Unwrap, UnwrapTuple } from '../lib/util-types';\nimport {\n\tArrayValidator,\n\tBaseValidator,\n\tBigIntValidator,\n\tBooleanValidator,\n\tDateValidator,\n\tInstanceValidator,\n\tLiteralValidator,\n\tMapValidator,\n\tNeverValidator,\n\tNullishValidator,\n\tNumberValidator,\n\tObjectValidator,\n\tPassthroughValidator,\n\tRecordValidator,\n\tSetValidator,\n\tStringValidator,\n\tTupleValidator,\n\tUnionValidator\n} from '../validators/imports';\nimport { LazyValidator } from '../validators/LazyValidator';\nimport { NativeEnumValidator, type NativeEnumLike } from '../validators/NativeEnumValidator';\nimport { TypedArrayValidator } from '../validators/TypedArrayValidator';\nimport type { Constructor, MappedObjectValidator } from './util-types';\n\nexport class Shapes {\n\tpublic get string() {\n\t\treturn new StringValidator();\n\t}\n\n\tpublic get number() {\n\t\treturn new NumberValidator();\n\t}\n\n\tpublic get bigint() {\n\t\treturn new BigIntValidator();\n\t}\n\n\tpublic get boolean() {\n\t\treturn new BooleanValidator();\n\t}\n\n\tpublic get date() {\n\t\treturn new DateValidator();\n\t}\n\n\tpublic object<T extends object>(shape: MappedObjectValidator<T>) {\n\t\treturn new ObjectValidator<T>(shape);\n\t}\n\n\tpublic get undefined() {\n\t\treturn this.literal(undefined);\n\t}\n\n\tpublic get null() {\n\t\treturn this.literal(null);\n\t}\n\n\tpublic get nullish() {\n\t\treturn new NullishValidator();\n\t}\n\n\tpublic get any() {\n\t\treturn new PassthroughValidator<any>();\n\t}\n\n\tpublic get unknown() {\n\t\treturn new PassthroughValidator<unknown>();\n\t}\n\n\tpublic get never() {\n\t\treturn new NeverValidator();\n\t}\n\n\tpublic enum<T>(...values: readonly T[]) {\n\t\treturn this.union(...values.map((value) => this.literal(value)));\n\t}\n\n\tpublic nativeEnum<T extends NativeEnumLike>(enumShape: T): NativeEnumValidator<T> {\n\t\treturn new NativeEnumValidator(enumShape);\n\t}\n\n\tpublic literal<T>(value: T): BaseValidator<T> {\n\t\tif (value instanceof Date) return this.date.equal(value) as unknown as BaseValidator<T>;\n\t\treturn new LiteralValidator(value);\n\t}\n\n\tpublic instance<T>(expected: Constructor<T>): InstanceValidator<T> {\n\t\treturn new InstanceValidator(expected);\n\t}\n\n\tpublic union<T extends [...BaseValidator<any>[]]>(...validators: [...T]): UnionValidator<Unwrap<T[number]>> {\n\t\treturn new UnionValidator(validators);\n\t}\n\n\tpublic array<T>(validator: BaseValidator<T[][number]>): ArrayValidator<T[], T[][number]>;\n\tpublic array<T extends unknown[]>(validator: BaseValidator<T[number]>): ArrayValidator<T, T[number]>;\n\tpublic array<T extends unknown[]>(validator: BaseValidator<T[number]>) {\n\t\treturn new ArrayValidator(validator);\n\t}\n\n\tpublic typedArray<T extends TypedArray>(type: TypedArrayName = 'TypedArray') {\n\t\treturn new TypedArrayValidator<T>(type);\n\t}\n\n\tpublic get int8Array() {\n\t\treturn this.typedArray<Int8Array>('Int8Array');\n\t}\n\n\tpublic get uint8Array() {\n\t\treturn this.typedArray<Uint8Array>('Uint8Array');\n\t}\n\n\tpublic get uint8ClampedArray() {\n\t\treturn this.typedArray<Uint8ClampedArray>('Uint8ClampedArray');\n\t}\n\n\tpublic get int16Array() {\n\t\treturn this.typedArray<Int16Array>('Int16Array');\n\t}\n\n\tpublic get uint16Array() {\n\t\treturn this.typedArray<Uint16Array>('Uint16Array');\n\t}\n\n\tpublic get int32Array() {\n\t\treturn this.typedArray<Int32Array>('Int32Array');\n\t}\n\n\tpublic get uint32Array() {\n\t\treturn this.typedArray<Uint32Array>('Uint32Array');\n\t}\n\n\tpublic get float32Array() {\n\t\treturn this.typedArray<Float32Array>('Float32Array');\n\t}\n\n\tpublic get float64Array() {\n\t\treturn this.typedArray<Float64Array>('Float64Array');\n\t}\n\n\tpublic get bigInt64Array() {\n\t\treturn this.typedArray<BigInt64Array>('BigInt64Array');\n\t}\n\n\tpublic get bigUint64Array() {\n\t\treturn this.typedArray<BigUint64Array>('BigUint64Array');\n\t}\n\n\tpublic tuple<T extends [...BaseValidator<any>[]]>(validators: [...T]): TupleValidator<UnwrapTuple<T>> {\n\t\treturn new TupleValidator(validators);\n\t}\n\n\tpublic set<T>(validator: BaseValidator<T>) {\n\t\treturn new SetValidator(validator);\n\t}\n\n\tpublic record<T>(validator: BaseValidator<T>) {\n\t\treturn new RecordValidator(validator);\n\t}\n\n\tpublic map<T, U>(keyValidator: BaseValidator<T>, valueValidator: BaseValidator<U>) {\n\t\treturn new MapValidator(keyValidator, valueValidator);\n\t}\n\n\tpublic lazy<T extends BaseValidator<unknown>>(validator: (value: unknown) => T) {\n\t\treturn new LazyValidator(validator);\n\t}\n}\n","import { Shapes } from './lib/Shapes';\n\nexport const s = new Shapes();\n\nexport * from './lib/Result';\nexport * from './lib/configs';\nexport * from './lib/errors/BaseError';\nexport * from './lib/errors/CombinedError';\nexport * from './lib/errors/CombinedPropertyError';\nexport * from './lib/errors/ExpectedConstraintError';\nexport * from './lib/errors/ExpectedValidationError';\nexport * from './lib/errors/MissingPropertyError';\nexport * from './lib/errors/MultiplePossibilitiesConstraintError';\nexport * from './lib/errors/UnknownEnumValueError';\nexport * from './lib/errors/UnknownPropertyError';\nexport * from './lib/errors/ValidationError';\nexport * from './type-exports';\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}