{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst MessagePayload = require('../structures/MessagePayload');\nconst {\n  Sticker\n} = require('../structures/Sticker');\n\n/**\n * Manages API methods for Guild Stickers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildStickerManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Sticker, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of Guild Stickers\n   * @type {Collection<Snowflake, Sticker>}\n   * @name GuildStickerManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Options used to create a guild sticker.\n   * @typedef {Object} GuildStickerCreateOptions\n   * @property {AttachmentPayload|BufferResolvable|Stream} file The file for the sticker\n   * @property {string} name The name for the sticker\n   * @property {string} tags The Discord name of a unicode emoji representing the sticker's expression\n   * @property {?string} [description] The description for the sticker\n   * @property {string} [reason] Reason for creating the sticker\n   */\n\n  /**\n   * Creates a new custom sticker in the guild.\n   * @param {GuildStickerCreateOptions} options Options for creating a guild sticker\n   * @returns {Promise<Sticker>} The created sticker\n   * @example\n   * // Create a new sticker from a URL\n   * guild.stickers.create({ file: 'https://i.imgur.com/w3duR07.png', name: 'rip', tags: 'headstone' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new sticker from a file on your computer\n   * guild.stickers.create({ file: './memes/banana.png', name: 'banana', tags: 'banana' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   */\n  async create() {\n    let {\n      file,\n      name,\n      tags,\n      description,\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resolvedFile = await MessagePayload.resolveFile(file);\n    if (!resolvedFile) throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);\n    file = {\n      ...resolvedFile,\n      key: 'file'\n    };\n    const body = {\n      name,\n      tags,\n      description: description ?? ''\n    };\n    const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {\n      appendToFormData: true,\n      body,\n      files: [file],\n      reason\n    });\n    return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;\n  }\n\n  /**\n   * Data that resolves to give a Sticker object. This can be:\n   * * A Sticker object\n   * * A Snowflake\n   * @typedef {Sticker|Snowflake} StickerResolvable\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker object.\n   * @method resolve\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Sticker}\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker id string.\n   * @method resolveId\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a sticker.\n   * @param {StickerResolvable} sticker The sticker to edit\n   * @param {GuildStickerEditOptions} [options={}] The new data for the sticker\n   * @returns {Promise<Sticker>}\n   */\n  async edit(sticker) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const stickerId = this.resolveId(sticker);\n    if (!stickerId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {\n      body: options,\n      reason: options.reason\n    });\n    const existing = this.cache.get(stickerId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Deletes a sticker.\n   * @param {StickerResolvable} sticker The sticker to delete\n   * @param {string} [reason] Reason for deleting this sticker\n   * @returns {Promise<void>}\n   */\n  async delete(sticker, reason) {\n    sticker = this.resolveId(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), {\n      reason\n    });\n  }\n\n  /**\n   * Obtains one or more stickers from Discord, or the sticker cache if they're already available.\n   * @param {Snowflake} [id] The Sticker's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}\n   * @example\n   * // Fetch all stickers from the guild\n   * message.guild.stickers.fetch()\n   *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single sticker\n   * message.guild.stickers.fetch('222078108977594368')\n   *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));\n      return this._add(sticker, cache);\n    }\n    const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));\n    return new Collection(data.map(sticker => [sticker.id, this._add(sticker, cache)]));\n  }\n\n  /**\n   * Fetches the user who uploaded this sticker, if this is a guild sticker.\n   * @param {StickerResolvable} sticker The sticker to fetch the user for\n   * @returns {Promise<?User>}\n   */\n  async fetchUser(sticker) {\n    sticker = this.resolve(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));\n    sticker._patch(data);\n    return sticker.user;\n  }\n}\nmodule.exports = GuildStickerManager;","map":{"version":3,"names":["Collection","require","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","MessagePayload","Sticker","GuildStickerManager","constructor","guild","iterable","client","_add","data","cache","extras","create","file","name","tags","description","reason","arguments","length","undefined","resolvedFile","resolveFile","ReqResourceType","key","body","sticker","rest","post","guildStickers","id","appendToFormData","files","actions","GuildStickerCreate","handle","edit","options","stickerId","resolveId","InvalidType","d","patch","guildSticker","existing","get","clone","_clone","_patch","delete","fetch","force","map","fetchUser","resolve","user","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/managers/GuildStickerManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst MessagePayload = require('../structures/MessagePayload');\nconst { Sticker } = require('../structures/Sticker');\n\n/**\n * Manages API methods for Guild Stickers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildStickerManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Sticker, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of Guild Stickers\n   * @type {Collection<Snowflake, Sticker>}\n   * @name GuildStickerManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Options used to create a guild sticker.\n   * @typedef {Object} GuildStickerCreateOptions\n   * @property {AttachmentPayload|BufferResolvable|Stream} file The file for the sticker\n   * @property {string} name The name for the sticker\n   * @property {string} tags The Discord name of a unicode emoji representing the sticker's expression\n   * @property {?string} [description] The description for the sticker\n   * @property {string} [reason] Reason for creating the sticker\n   */\n\n  /**\n   * Creates a new custom sticker in the guild.\n   * @param {GuildStickerCreateOptions} options Options for creating a guild sticker\n   * @returns {Promise<Sticker>} The created sticker\n   * @example\n   * // Create a new sticker from a URL\n   * guild.stickers.create({ file: 'https://i.imgur.com/w3duR07.png', name: 'rip', tags: 'headstone' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new sticker from a file on your computer\n   * guild.stickers.create({ file: './memes/banana.png', name: 'banana', tags: 'banana' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   */\n  async create({ file, name, tags, description, reason } = {}) {\n    const resolvedFile = await MessagePayload.resolveFile(file);\n    if (!resolvedFile) throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);\n    file = { ...resolvedFile, key: 'file' };\n\n    const body = { name, tags, description: description ?? '' };\n\n    const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {\n      appendToFormData: true,\n      body,\n      files: [file],\n      reason,\n    });\n    return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;\n  }\n\n  /**\n   * Data that resolves to give a Sticker object. This can be:\n   * * A Sticker object\n   * * A Snowflake\n   * @typedef {Sticker|Snowflake} StickerResolvable\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker object.\n   * @method resolve\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Sticker}\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker id string.\n   * @method resolveId\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a sticker.\n   * @param {StickerResolvable} sticker The sticker to edit\n   * @param {GuildStickerEditOptions} [options={}] The new data for the sticker\n   * @returns {Promise<Sticker>}\n   */\n  async edit(sticker, options = {}) {\n    const stickerId = this.resolveId(sticker);\n    if (!stickerId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n\n    const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {\n      body: options,\n      reason: options.reason,\n    });\n\n    const existing = this.cache.get(stickerId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Deletes a sticker.\n   * @param {StickerResolvable} sticker The sticker to delete\n   * @param {string} [reason] Reason for deleting this sticker\n   * @returns {Promise<void>}\n   */\n  async delete(sticker, reason) {\n    sticker = this.resolveId(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n\n    await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });\n  }\n\n  /**\n   * Obtains one or more stickers from Discord, or the sticker cache if they're already available.\n   * @param {Snowflake} [id] The Sticker's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}\n   * @example\n   * // Fetch all stickers from the guild\n   * message.guild.stickers.fetch()\n   *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single sticker\n   * message.guild.stickers.fetch('222078108977594368')\n   *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));\n      return this._add(sticker, cache);\n    }\n\n    const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));\n    return new Collection(data.map(sticker => [sticker.id, this._add(sticker, cache)]));\n  }\n\n  /**\n   * Fetches the user who uploaded this sticker, if this is a guild sticker.\n   * @param {StickerResolvable} sticker The sticker to fetch the user for\n   * @returns {Promise<?User>}\n   */\n  async fetchUser(sticker) {\n    sticker = this.resolve(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));\n    sticker._patch(data);\n    return sticker.user;\n  }\n}\n\nmodule.exports = GuildStickerManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}