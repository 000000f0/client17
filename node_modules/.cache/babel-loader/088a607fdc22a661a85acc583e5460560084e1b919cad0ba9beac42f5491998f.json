{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes,\n  PermissionFlagsBits\n} = require('discord-api-types/v10');\nconst BaseGuildEmojiManager = require('./BaseGuildEmojiManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildEmojis and stores their cache.\n * @extends {BaseGuildEmojiManager}\n */\nclass GuildEmojiManager extends BaseGuildEmojiManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Options used for creating an emoji in a guild.\n   * @typedef {Object} GuildEmojiCreateOptions\n   * @property {BufferResolvable|Base64Resolvable} attachment The image for the emoji\n   * @property {string} name The name for the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to\n   * @property {string} [reason] The reason for creating the emoji\n   */\n\n  /**\n   * Creates a new custom emoji in the guild.\n   * @param {GuildEmojiCreateOptions} options Options for creating the emoji\n   * @returns {Promise<Emoji>} The created emoji\n   * @example\n   * // Create a new emoji from a URL\n   * guild.emojis.create({ attachment: 'https://i.imgur.com/w3duR07.png', name: 'rip' })\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new emoji from a file on your computer\n   * guild.emojis.create({ attachment: './memes/banana.png', name: 'banana' })\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   */\n  async create(_ref) {\n    let {\n      attachment,\n      name,\n      roles,\n      reason\n    } = _ref;\n    attachment = await DataResolver.resolveImage(attachment);\n    if (!attachment) throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);\n    const body = {\n      image: attachment,\n      name\n    };\n    if (roles) {\n      if (!Array.isArray(roles) && !(roles instanceof Collection)) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      body.roles = [];\n      for (const role of roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array or Collection', 'options.roles', role);\n        }\n        body.roles.push(resolvedRole);\n      }\n    }\n    const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), {\n      body,\n      reason\n    });\n    return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;\n  }\n\n  /**\n   * Obtains one or more emojis from Discord, or the emoji cache if they're already available.\n   * @param {Snowflake} [id] The emoji's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}\n   * @example\n   * // Fetch all emojis from the guild\n   * message.guild.emojis.fetch()\n   *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single emoji\n   * message.guild.emojis.fetch('222078108977594368')\n   *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));\n      return this._add(emoji, cache);\n    }\n    const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));\n    const emojis = new Collection();\n    for (const emoji of data) emojis.set(emoji.id, this._add(emoji, cache));\n    return emojis;\n  }\n\n  /**\n   * Deletes an emoji.\n   * @param {EmojiResolvable} emoji The Emoji resolvable to delete\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<void>}\n   */\n  async delete(emoji, reason) {\n    const id = this.resolveId(emoji);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'emoji', 'EmojiResolvable', true);\n    await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), {\n      reason\n    });\n  }\n\n  /**\n   * Edits an emoji.\n   * @param {EmojiResolvable} emoji The Emoji resolvable to edit\n   * @param {GuildEmojiEditOptions} options The options to provide\n   * @returns {Promise<GuildEmoji>}\n   */\n  async edit(emoji, options) {\n    const id = this.resolveId(emoji);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'emoji', 'EmojiResolvable', true);\n    const roles = options.roles?.map(r => this.guild.roles.resolveId(r));\n    const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {\n      body: {\n        name: options.name,\n        roles\n      },\n      reason: options.reason\n    });\n    const existing = this.cache.get(id);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(newData);\n      return clone;\n    }\n    return this._add(newData);\n  }\n\n  /**\n   * Fetches the author for this emoji\n   * @param {EmojiResolvable} emoji The emoji to fetch the author of\n   * @returns {Promise<User>}\n   */\n  async fetchAuthor(emoji) {\n    emoji = this.resolve(emoji);\n    if (!emoji) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'emoji', 'EmojiResolvable', true);\n    if (emoji.managed) {\n      throw new DiscordjsError(ErrorCodes.EmojiManaged);\n    }\n    const {\n      me\n    } = this.guild.members;\n    if (!me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);\n    if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {\n      throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);\n    }\n    const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));\n    emoji._patch(data);\n    return emoji.author;\n  }\n}\nmodule.exports = GuildEmojiManager;","map":{"version":3,"names":["Collection","require","Routes","PermissionFlagsBits","BaseGuildEmojiManager","DiscordjsError","DiscordjsTypeError","ErrorCodes","DataResolver","GuildEmojiManager","constructor","guild","iterable","client","_add","data","cache","extras","create","_ref","attachment","name","roles","reason","resolveImage","ReqResourceType","body","image","Array","isArray","InvalidType","role","values","resolvedRole","resolveId","InvalidElement","push","emoji","rest","post","guildEmojis","id","actions","GuildEmojiCreate","handle","fetch","force","arguments","length","undefined","existing","get","guildEmoji","emojis","set","delete","edit","options","map","r","newData","patch","clone","_clone","_patch","fetchAuthor","resolve","managed","EmojiManaged","me","members","GuildUncachedMe","permissions","has","ManageGuildExpressions","MissingManageGuildExpressionsPermission","author","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/managers/GuildEmojiManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { Routes, PermissionFlagsBits } = require('discord-api-types/v10');\nconst BaseGuildEmojiManager = require('./BaseGuildEmojiManager');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildEmojis and stores their cache.\n * @extends {BaseGuildEmojiManager}\n */\nclass GuildEmojiManager extends BaseGuildEmojiManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Options used for creating an emoji in a guild.\n   * @typedef {Object} GuildEmojiCreateOptions\n   * @property {BufferResolvable|Base64Resolvable} attachment The image for the emoji\n   * @property {string} name The name for the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to\n   * @property {string} [reason] The reason for creating the emoji\n   */\n\n  /**\n   * Creates a new custom emoji in the guild.\n   * @param {GuildEmojiCreateOptions} options Options for creating the emoji\n   * @returns {Promise<Emoji>} The created emoji\n   * @example\n   * // Create a new emoji from a URL\n   * guild.emojis.create({ attachment: 'https://i.imgur.com/w3duR07.png', name: 'rip' })\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new emoji from a file on your computer\n   * guild.emojis.create({ attachment: './memes/banana.png', name: 'banana' })\n   *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))\n   *   .catch(console.error);\n   */\n  async create({ attachment, name, roles, reason }) {\n    attachment = await DataResolver.resolveImage(attachment);\n    if (!attachment) throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);\n\n    const body = { image: attachment, name };\n    if (roles) {\n      if (!Array.isArray(roles) && !(roles instanceof Collection)) {\n        throw new DiscordjsTypeError(\n          ErrorCodes.InvalidType,\n          'options.roles',\n          'Array or Collection of Roles or Snowflakes',\n          true,\n        );\n      }\n      body.roles = [];\n      for (const role of roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array or Collection', 'options.roles', role);\n        }\n        body.roles.push(resolvedRole);\n      }\n    }\n\n    const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), { body, reason });\n    return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;\n  }\n\n  /**\n   * Obtains one or more emojis from Discord, or the emoji cache if they're already available.\n   * @param {Snowflake} [id] The emoji's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}\n   * @example\n   * // Fetch all emojis from the guild\n   * message.guild.emojis.fetch()\n   *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single emoji\n   * message.guild.emojis.fetch('222078108977594368')\n   *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));\n      return this._add(emoji, cache);\n    }\n\n    const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));\n    const emojis = new Collection();\n    for (const emoji of data) emojis.set(emoji.id, this._add(emoji, cache));\n    return emojis;\n  }\n\n  /**\n   * Deletes an emoji.\n   * @param {EmojiResolvable} emoji The Emoji resolvable to delete\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<void>}\n   */\n  async delete(emoji, reason) {\n    const id = this.resolveId(emoji);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'emoji', 'EmojiResolvable', true);\n    await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), { reason });\n  }\n\n  /**\n   * Edits an emoji.\n   * @param {EmojiResolvable} emoji The Emoji resolvable to edit\n   * @param {GuildEmojiEditOptions} options The options to provide\n   * @returns {Promise<GuildEmoji>}\n   */\n  async edit(emoji, options) {\n    const id = this.resolveId(emoji);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'emoji', 'EmojiResolvable', true);\n    const roles = options.roles?.map(r => this.guild.roles.resolveId(r));\n    const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {\n      body: {\n        name: options.name,\n        roles,\n      },\n      reason: options.reason,\n    });\n    const existing = this.cache.get(id);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(newData);\n      return clone;\n    }\n    return this._add(newData);\n  }\n\n  /**\n   * Fetches the author for this emoji\n   * @param {EmojiResolvable} emoji The emoji to fetch the author of\n   * @returns {Promise<User>}\n   */\n  async fetchAuthor(emoji) {\n    emoji = this.resolve(emoji);\n    if (!emoji) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'emoji', 'EmojiResolvable', true);\n    if (emoji.managed) {\n      throw new DiscordjsError(ErrorCodes.EmojiManaged);\n    }\n\n    const { me } = this.guild.members;\n    if (!me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);\n    if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {\n      throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);\n    }\n\n    const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));\n    emoji._patch(data);\n    return emoji.author;\n  }\n}\n\nmodule.exports = GuildEmojiManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}