{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  ChannelType,\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst GuildTextThreadManager = require('./GuildTextThreadManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst Webhook = require('../structures/Webhook');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\nconst {\n  transformGuildForumTag,\n  transformGuildDefaultReaction\n} = require('../util/Channels');\nconst {\n  ThreadChannelTypes\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst {\n  setPosition\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching = this._cache.constructor.name === 'Collection' || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Adds the target channel to a channel's followers.\n   * @param {NewsChannel|Snowflake} channel The channel to follow\n   * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<Snowflake>} Returns created target webhook id.\n   */\n  async addFollower(channel, targetChannel, reason) {\n    const channelId = this.resolveId(channel);\n    const targetChannelId = this.resolveId(targetChannel);\n    if (!channelId || !targetChannelId) throw new Error(ErrorCodes.GuildChannelResolve);\n    const {\n      webhook_id\n    } = await this.client.rest.post(Routes.channelFollowers(channelId), {\n      body: {\n        webhook_channel_id: targetChannelId\n      },\n      reason\n    });\n    return webhook_id;\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {?CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {GuildChannelCreateOptions} options Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create({\n   *   name: 'new-general',\n   *   type: ChannelType.GuildVoice,\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [PermissionFlagsBits.ViewChannel],\n   *     },\n   *   ],\n   * })\n   */\n  async create(_ref) {\n    let {\n      name,\n      type,\n      topic,\n      nsfw,\n      bitrate,\n      userLimit,\n      parent,\n      permissionOverwrites,\n      position,\n      rateLimitPerUser,\n      rtcRegion,\n      videoQualityMode,\n      availableTags,\n      defaultReactionEmoji,\n      defaultAutoArchiveDuration,\n      defaultSortOrder,\n      defaultForumLayout,\n      reason\n    } = _ref;\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {\n      body: {\n        name,\n        topic,\n        type,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n        video_quality_mode: videoQualityMode,\n        available_tags: availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),\n        default_auto_archive_duration: defaultAutoArchiveDuration,\n        default_sort_order: defaultSortOrder,\n        default_forum_layout: defaultForumLayout\n      },\n      reason\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions\n   * @property {TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|Snowflake} channel\n   * The channel to create the webhook for\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {WebhookCreateOptions} options Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * guild.channels.createWebhook({\n   *   channel: '222197033908436994',\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook(_ref2) {\n    let {\n      channel,\n      name,\n      avatar,\n      reason\n    } = _ref2;\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.rest.post(Routes.channelWebhooks(id), {\n      body: {\n        name,\n        avatar\n      },\n      reason\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Options used to edit a guild channel.\n   * @typedef {Object} GuildChannelEditOptions\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel\n   * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji\n   * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel\n   * @property {ForumLayoutType} [defaultForumLayout] The default forum layout to set on the channel\n   * @property {string} [reason] Reason for editing this channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelResolvable} channel The channel to edit\n   * @param {GuildChannelEditOptions} options Options for editing the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * guild.channels.edit('222197033908436994', { name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(channel, options) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const parent = options.parent && this.client.channels.resolveId(options.parent);\n    if (options.position !== undefined) {\n      await this.setPosition(channel, options.position, {\n        position: options.position,\n        reason: options.reason\n      });\n    }\n    let permission_overwrites = options.permissionOverwrites?.map(o => PermissionOverwrites.resolve(o, this.guild));\n    if (options.lockPermissions) {\n      if (parent) {\n        const newParent = this.guild.channels.resolve(parent);\n        if (newParent?.type === ChannelType.GuildCategory) {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (channel.parent) {\n        permission_overwrites = channel.parent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n    const newData = await this.client.rest.patch(Routes.channel(channel.id), {\n      body: {\n        name: (options.name ?? channel.name).trim(),\n        type: options.type,\n        topic: options.topic,\n        nsfw: options.nsfw,\n        bitrate: options.bitrate ?? channel.bitrate,\n        user_limit: options.userLimit ?? channel.userLimit,\n        rtc_region: 'rtcRegion' in options ? options.rtcRegion : channel.rtcRegion,\n        video_quality_mode: options.videoQualityMode,\n        parent_id: parent,\n        lock_permissions: options.lockPermissions,\n        rate_limit_per_user: options.rateLimitPerUser,\n        default_auto_archive_duration: options.defaultAutoArchiveDuration,\n        permission_overwrites,\n        available_tags: options.availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),\n        default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,\n        flags: 'flags' in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,\n        default_sort_order: options.defaultSortOrder,\n        default_forum_layout: options.defaultForumLayout\n      },\n      reason: options.reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {GuildChannelResolvable} channel The channel to set the position for\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} options Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * guild.channels.setPosition('222078374472843266', 2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(channel, position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels\n    });\n    return channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n    if (id) {\n      const data = await this.client.rest.get(Routes.channel(id));\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);\n      return this.client.channels._add(data, this.guild, {\n        cache\n      });\n    }\n    const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, {\n      cache\n    }));\n    return channels;\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @param {GuildChannelResolvable} channel The channel to fetch webhooks for\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.channels.fetchWebhooks('769862166131245066')\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks(channel) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const data = await this.client.rest.get(Routes.channelWebhooks(id));\n    return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection());\n  }\n\n  /**\n   * Data that can be resolved to give a Category Channel object. This can be:\n   * * A CategoryChannel object\n   * * A Snowflake\n   * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable\n   */\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {GuildChannel|Snowflake} channel Channel to update\n   * @property {number} [position] New position for the channel\n   * @property {CategoryChannelResolvable} [parent] Parent channel for this channel\n   * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: r.parent !== undefined ? this.resolveId(r.parent) : undefined\n    }));\n    await this.client.rest.patch(Routes.guildChannels(this.guild.id), {\n      body: channelPositions\n    });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions\n    }).guild;\n  }\n\n  /**\n   * Data returned from fetching threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched\n   * @property {Collection<Snowflake, ThreadMember>} members The thread members in the received threads\n   */\n\n  /**\n   * Obtains all active thread channels in the guild.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const raw = await this.client.rest.get(Routes.guildActiveThreads(this.guild.id));\n    return GuildTextThreadManager._mapThreads(raw, this.client, {\n      guild: this.guild,\n      cache\n    });\n  }\n\n  /**\n   * Deletes the channel.\n   * @param {GuildChannelResolvable} channel The channel to delete\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the channel\n   * guild.channels.delete('858850993013260338', 'making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(channel, reason) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    await this.client.rest.delete(Routes.channel(id), {\n      reason\n    });\n    this.client.actions.ChannelDelete.handle({\n      id\n    });\n  }\n}\nmodule.exports = GuildChannelManager;","map":{"version":3,"names":["process","require","Collection","ChannelType","Routes","CachedManager","GuildTextThreadManager","DiscordjsError","DiscordjsTypeError","ErrorCodes","GuildChannel","PermissionOverwrites","ThreadChannel","Webhook","ChannelFlagsBitField","transformGuildForumTag","transformGuildDefaultReaction","ThreadChannelTypes","DataResolver","setPosition","cacheWarningEmitted","GuildChannelManager","constructor","guild","iterable","client","defaultCaching","_cache","name","maxSize","undefined","Infinity","emitWarning","channelCountWithoutThreads","cache","reduce","acc","channel","includes","type","_add","existing","get","id","set","resolve","resolveId","addFollower","targetChannel","reason","channelId","targetChannelId","Error","GuildChannelResolve","webhook_id","rest","post","channelFollowers","body","webhook_channel_id","create","_ref","topic","nsfw","bitrate","userLimit","parent","permissionOverwrites","position","rateLimitPerUser","rtcRegion","videoQualityMode","availableTags","defaultReactionEmoji","defaultAutoArchiveDuration","defaultSortOrder","defaultForumLayout","channels","map","o","data","guildChannels","user_limit","parent_id","permission_overwrites","rate_limit_per_user","rtc_region","video_quality_mode","available_tags","availableTag","default_reaction_emoji","default_auto_archive_duration","default_sort_order","default_forum_layout","actions","ChannelCreate","handle","createWebhook","_ref2","avatar","InvalidType","startsWith","resolveImage","channelWebhooks","edit","options","lockPermissions","newParent","GuildCategory","newData","patch","trim","lock_permissions","default_thread_rate_limit_per_user","defaultThreadRateLimitPerUser","flags","ChannelUpdate","updated","relative","arguments","length","updatedChannels","_sortedChannels","GuildChannelsPositionUpdate","guild_id","fetch","force","GuildChannelUnowned","fetchWebhooks","hooks","hook","setPositions","channelPositions","r","fetchActiveThreads","raw","guildActiveThreads","_mapThreads","delete","ChannelDelete","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/managers/GuildChannelManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst { ChannelType, Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst GuildTextThreadManager = require('./GuildTextThreadManager');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst Webhook = require('../structures/Webhook');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\nconst { transformGuildForumTag, transformGuildDefaultReaction } = require('../util/Channels');\nconst { ThreadChannelTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst { setPosition } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching =\n      this._cache.constructor.name === 'Collection' ||\n      this._cache.maxSize === undefined ||\n      this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Adds the target channel to a channel's followers.\n   * @param {NewsChannel|Snowflake} channel The channel to follow\n   * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<Snowflake>} Returns created target webhook id.\n   */\n  async addFollower(channel, targetChannel, reason) {\n    const channelId = this.resolveId(channel);\n    const targetChannelId = this.resolveId(targetChannel);\n    if (!channelId || !targetChannelId) throw new Error(ErrorCodes.GuildChannelResolve);\n    const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {\n      body: { webhook_channel_id: targetChannelId },\n      reason,\n    });\n    return webhook_id;\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {?CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {GuildChannelCreateOptions} options Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create({\n   *   name: 'new-general',\n   *   type: ChannelType.GuildVoice,\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [PermissionFlagsBits.ViewChannel],\n   *     },\n   *   ],\n   * })\n   */\n  async create({\n    name,\n    type,\n    topic,\n    nsfw,\n    bitrate,\n    userLimit,\n    parent,\n    permissionOverwrites,\n    position,\n    rateLimitPerUser,\n    rtcRegion,\n    videoQualityMode,\n    availableTags,\n    defaultReactionEmoji,\n    defaultAutoArchiveDuration,\n    defaultSortOrder,\n    defaultForumLayout,\n    reason,\n  }) {\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n\n    const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {\n      body: {\n        name,\n        topic,\n        type,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n        video_quality_mode: videoQualityMode,\n        available_tags: availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),\n        default_auto_archive_duration: defaultAutoArchiveDuration,\n        default_sort_order: defaultSortOrder,\n        default_forum_layout: defaultForumLayout,\n      },\n      reason,\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions\n   * @property {TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|Snowflake} channel\n   * The channel to create the webhook for\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {WebhookCreateOptions} options Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * guild.channels.createWebhook({\n   *   channel: '222197033908436994',\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook({ channel, name, avatar, reason }) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.rest.post(Routes.channelWebhooks(id), {\n      body: {\n        name,\n        avatar,\n      },\n      reason,\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Options used to edit a guild channel.\n   * @typedef {Object} GuildChannelEditOptions\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel\n   * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji\n   * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel\n   * @property {ForumLayoutType} [defaultForumLayout] The default forum layout to set on the channel\n   * @property {string} [reason] Reason for editing this channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelResolvable} channel The channel to edit\n   * @param {GuildChannelEditOptions} options Options for editing the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * guild.channels.edit('222197033908436994', { name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(channel, options) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n\n    const parent = options.parent && this.client.channels.resolveId(options.parent);\n\n    if (options.position !== undefined) {\n      await this.setPosition(channel, options.position, { position: options.position, reason: options.reason });\n    }\n\n    let permission_overwrites = options.permissionOverwrites?.map(o => PermissionOverwrites.resolve(o, this.guild));\n\n    if (options.lockPermissions) {\n      if (parent) {\n        const newParent = this.guild.channels.resolve(parent);\n        if (newParent?.type === ChannelType.GuildCategory) {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o =>\n            PermissionOverwrites.resolve(o, this.guild),\n          );\n        }\n      } else if (channel.parent) {\n        permission_overwrites = channel.parent.permissionOverwrites.cache.map(o =>\n          PermissionOverwrites.resolve(o, this.guild),\n        );\n      }\n    }\n\n    const newData = await this.client.rest.patch(Routes.channel(channel.id), {\n      body: {\n        name: (options.name ?? channel.name).trim(),\n        type: options.type,\n        topic: options.topic,\n        nsfw: options.nsfw,\n        bitrate: options.bitrate ?? channel.bitrate,\n        user_limit: options.userLimit ?? channel.userLimit,\n        rtc_region: 'rtcRegion' in options ? options.rtcRegion : channel.rtcRegion,\n        video_quality_mode: options.videoQualityMode,\n        parent_id: parent,\n        lock_permissions: options.lockPermissions,\n        rate_limit_per_user: options.rateLimitPerUser,\n        default_auto_archive_duration: options.defaultAutoArchiveDuration,\n        permission_overwrites,\n        available_tags: options.availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji:\n          options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),\n        default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,\n        flags: 'flags' in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,\n        default_sort_order: options.defaultSortOrder,\n        default_forum_layout: options.defaultForumLayout,\n      },\n      reason: options.reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {GuildChannelResolvable} channel The channel to set the position for\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} options Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * guild.channels.setPosition('222078374472843266', 2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(channel, position, { relative, reason } = {}) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const updatedChannels = await setPosition(\n      channel,\n      position,\n      relative,\n      this.guild._sortedChannels(channel),\n      this.client,\n      Routes.guildChannels(this.guild.id),\n      reason,\n    );\n\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels,\n    });\n    return channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    if (id) {\n      const data = await this.client.rest.get(Routes.channel(id));\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);\n      return this.client.channels._add(data, this.guild, { cache });\n    }\n\n    const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));\n    return channels;\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @param {GuildChannelResolvable} channel The channel to fetch webhooks for\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.channels.fetchWebhooks('769862166131245066')\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks(channel) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const data = await this.client.rest.get(Routes.channelWebhooks(id));\n    return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection());\n  }\n\n  /**\n   * Data that can be resolved to give a Category Channel object. This can be:\n   * * A CategoryChannel object\n   * * A Snowflake\n   * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable\n   */\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {GuildChannel|Snowflake} channel Channel to update\n   * @property {number} [position] New position for the channel\n   * @property {CategoryChannelResolvable} [parent] Parent channel for this channel\n   * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: r.parent !== undefined ? this.resolveId(r.parent) : undefined,\n    }));\n\n    await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions,\n    }).guild;\n  }\n\n  /**\n   * Data returned from fetching threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched\n   * @property {Collection<Snowflake, ThreadMember>} members The thread members in the received threads\n   */\n\n  /**\n   * Obtains all active thread channels in the guild.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads(cache = true) {\n    const raw = await this.client.rest.get(Routes.guildActiveThreads(this.guild.id));\n    return GuildTextThreadManager._mapThreads(raw, this.client, { guild: this.guild, cache });\n  }\n\n  /**\n   * Deletes the channel.\n   * @param {GuildChannelResolvable} channel The channel to delete\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the channel\n   * guild.channels.delete('858850993013260338', 'making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(channel, reason) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    await this.client.rest.delete(Routes.channel(id), { reason });\n    this.client.actions.ChannelDelete.handle({ id });\n  }\n}\n\nmodule.exports = GuildChannelManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}