{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  Guild\n} = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst {\n  Role\n} = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Events = require('../util/Events');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst SystemChannelFlagsBitField = require('../util/SystemChannelFlagsBitField');\nconst {\n  resolveColor\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {string} name The name of the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild\n   * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {GuildCreateOptions} options Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(_ref) {\n    let {\n      name,\n      icon = null,\n      verificationLevel,\n      defaultMessageNotifications,\n      explicitContentFilter,\n      roles = [],\n      channels = [],\n      afkChannelId,\n      afkTimeout,\n      systemChannelId,\n      systemChannelFlags\n    } = _ref;\n    const data = await this.client.rest.post(Routes.guilds(), {\n      body: {\n        name,\n        icon: icon && (await DataResolver.resolveImage(icon)),\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles: roles.map(_ref2 => {\n          let {\n            color,\n            permissions,\n            ...options\n          } = _ref2;\n          return {\n            ...options,\n            color: color && resolveColor(color),\n            permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()\n          };\n        }),\n        channels: channels.map(_ref3 => {\n          let {\n            parentId,\n            userLimit,\n            rtcRegion,\n            videoQualityMode,\n            permissionOverwrites,\n            rateLimitPerUser,\n            ...options\n          } = _ref3;\n          return {\n            ...options,\n            parent_id: parentId,\n            user_limit: userLimit,\n            rtc_region: rtcRegion,\n            video_quality_mode: videoQualityMode,\n            permission_overwrites: permissionOverwrites?.map(_ref4 => {\n              let {\n                allow,\n                deny,\n                ...permissionOverwriteOptions\n              } = _ref4;\n              return {\n                ...permissionOverwriteOptions,\n                allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),\n                deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()\n              };\n            }),\n            rate_limit_per_user: rateLimitPerUser\n          };\n        }),\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)\n      }\n    });\n    return this.client.guilds.cache.get(data.id) ?? new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.once(Events.GuildCreate, handleGuild);\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildCreate, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10_000).unref();\n    });\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const data = await this.client.rest.get(Routes.guild(id), {\n        query: makeURLSearchParams({\n          with_counts: options.withCounts ?? true\n        })\n      });\n      return this._add(data, options.cache);\n    }\n    const data = await this.client.rest.get(Routes.userGuilds(), {\n      query: makeURLSearchParams(options)\n    });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\nmodule.exports = GuildManager;","map":{"version":3,"names":["process","require","setTimeout","clearTimeout","Collection","makeURLSearchParams","Routes","CachedManager","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","OAuth2Guild","Role","DataResolver","Events","PermissionsBitField","SystemChannelFlagsBitField","resolveColor","cacheWarningEmitted","GuildManager","constructor","client","iterable","_cache","name","emitWarning","resolve","guild","resolveId","id","create","_ref","icon","verificationLevel","defaultMessageNotifications","explicitContentFilter","roles","channels","afkChannelId","afkTimeout","systemChannelId","systemChannelFlags","data","rest","post","guilds","body","resolveImage","verification_level","default_message_notifications","explicit_content_filter","map","_ref2","color","permissions","options","undefined","toString","_ref3","parentId","userLimit","rtcRegion","videoQualityMode","permissionOverwrites","rateLimitPerUser","parent_id","user_limit","rtc_region","video_quality_mode","permission_overwrites","_ref4","allow","deny","permissionOverwriteOptions","rate_limit_per_user","afk_channel_id","afk_timeout","system_channel_id","system_channel_flags","cache","get","Promise","handleGuild","timeout","decrementMaxListeners","incrementMaxListeners","once","GuildCreate","removeListener","_add","unref","fetch","arguments","length","force","existing","query","with_counts","withCounts","userGuilds","reduce","coll","set","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/managers/GuildManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { Guild } = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst { GuildMember } = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst { Role } = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Events = require('../util/Events');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst SystemChannelFlagsBitField = require('../util/SystemChannelFlagsBitField');\nconst { resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {string} name The name of the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild\n   * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {GuildCreateOptions} options Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create({\n    name,\n    icon = null,\n    verificationLevel,\n    defaultMessageNotifications,\n    explicitContentFilter,\n    roles = [],\n    channels = [],\n    afkChannelId,\n    afkTimeout,\n    systemChannelId,\n    systemChannelFlags,\n  }) {\n    const data = await this.client.rest.post(Routes.guilds(), {\n      body: {\n        name,\n        icon: icon && (await DataResolver.resolveImage(icon)),\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles: roles.map(({ color, permissions, ...options }) => ({\n          ...options,\n          color: color && resolveColor(color),\n          permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString(),\n        })),\n        channels: channels.map(\n          ({\n            parentId,\n            userLimit,\n            rtcRegion,\n            videoQualityMode,\n            permissionOverwrites,\n            rateLimitPerUser,\n            ...options\n          }) => ({\n            ...options,\n            parent_id: parentId,\n            user_limit: userLimit,\n            rtc_region: rtcRegion,\n            video_quality_mode: videoQualityMode,\n            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({\n              ...permissionOverwriteOptions,\n              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),\n              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString(),\n            })),\n            rate_limit_per_user: rateLimitPerUser,\n          }),\n        ),\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags:\n          systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),\n      },\n    });\n\n    return (\n      this.client.guilds.cache.get(data.id) ??\n      new Promise(resolve => {\n        const handleGuild = guild => {\n          if (guild.id === data.id) {\n            clearTimeout(timeout);\n            this.client.decrementMaxListeners();\n            resolve(guild);\n          }\n        };\n        this.client.incrementMaxListeners();\n        this.client.once(Events.GuildCreate, handleGuild);\n\n        const timeout = setTimeout(() => {\n          this.client.removeListener(Events.GuildCreate, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(this.client.guilds._add(data));\n        }, 10_000).unref();\n      })\n    );\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.rest.get(Routes.guild(id), {\n        query: makeURLSearchParams({ with_counts: options.withCounts ?? true }),\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\n\nmodule.exports = GuildManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACvC,MAAM;EAAEC,UAAU;EAAEC;AAAa,CAAC,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC3D,MAAM;EAAEG;AAAW,CAAC,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEI;AAAoB,CAAC,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAC1D,MAAM;EAAEK;AAAO,CAAC,GAAGL,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAMM,aAAa,GAAGN,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAM;EAAEO;AAAM,CAAC,GAAGP,OAAO,CAAC,qBAAqB,CAAC;AAChD,MAAMQ,YAAY,GAAGR,OAAO,CAAC,4BAA4B,CAAC;AAC1D,MAAMS,UAAU,GAAGT,OAAO,CAAC,0BAA0B,CAAC;AACtD,MAAM;EAAEU;AAAY,CAAC,GAAGV,OAAO,CAAC,2BAA2B,CAAC;AAC5D,MAAMW,MAAM,GAAGX,OAAO,CAAC,sBAAsB,CAAC;AAC9C,MAAMY,WAAW,GAAGZ,OAAO,CAAC,2BAA2B,CAAC;AACxD,MAAM;EAAEa;AAAK,CAAC,GAAGb,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAMc,YAAY,GAAGd,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAMe,MAAM,GAAGf,OAAO,CAAC,gBAAgB,CAAC;AACxC,MAAMgB,mBAAmB,GAAGhB,OAAO,CAAC,6BAA6B,CAAC;AAClE,MAAMiB,0BAA0B,GAAGjB,OAAO,CAAC,oCAAoC,CAAC;AAChF,MAAM;EAAEkB;AAAa,CAAC,GAAGlB,OAAO,CAAC,cAAc,CAAC;AAEhD,IAAImB,mBAAmB,GAAG,KAAK;;AAE/B;AACA;AACA;AACA;AACA,MAAMC,YAAY,SAASd,aAAa,CAAC;EACvCe,WAAWA,CAACC,MAAM,EAAEC,QAAQ,EAAE;IAC5B,KAAK,CAACD,MAAM,EAAEf,KAAK,EAAEgB,QAAQ,CAAC;IAC9B,IAAI,CAACJ,mBAAmB,IAAI,IAAI,CAACK,MAAM,CAACH,WAAW,CAACI,IAAI,KAAK,YAAY,EAAE;MACzEN,mBAAmB,GAAG,IAAI;MAC1BpB,OAAO,CAAC2B,WAAW,CAChB,qCAAoC,IAAI,CAACL,WAAW,CAACI,IAAK,2CAA0C,EACrG,kCAAkC,CACnC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,OAAOA,CAACC,KAAK,EAAE;IACb,IACEA,KAAK,YAAYpB,YAAY,IAC7BoB,KAAK,YAAYlB,WAAW,IAC5BkB,KAAK,YAAYnB,UAAU,IAC3BmB,KAAK,YAAYf,IAAI,IACpBe,KAAK,YAAYjB,MAAM,IAAIiB,KAAK,CAACA,KAAM,EACxC;MACA,OAAO,KAAK,CAACD,OAAO,CAACC,KAAK,CAACA,KAAK,CAAC;IACnC;IACA,OAAO,KAAK,CAACD,OAAO,CAACC,KAAK,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAASA,CAACD,KAAK,EAAE;IACf,IACEA,KAAK,YAAYpB,YAAY,IAC7BoB,KAAK,YAAYlB,WAAW,IAC5BkB,KAAK,YAAYnB,UAAU,IAC3BmB,KAAK,YAAYf,IAAI,IACpBe,KAAK,YAAYjB,MAAM,IAAIiB,KAAK,CAACA,KAAM,EACxC;MACA,OAAO,KAAK,CAACC,SAAS,CAACD,KAAK,CAACA,KAAK,CAACE,EAAE,CAAC;IACxC;IACA,OAAO,KAAK,CAACD,SAAS,CAACD,KAAK,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,MAAMA,CAAAC,IAAA,EAYT;IAAA,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"},"metadata":{},"sourceType":"script","externalDependencies":[]}