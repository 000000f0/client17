{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../../errors');\nconst {\n  flatten\n} = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @extends {EventEmitter}\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    /**\n     * The reason the collector ended\n     * @type {string|null}\n     * @private\n     */\n    this._endReason = null;\n    if (typeof this.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.filter', 'function');\n    }\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n\n    /**\n     * The timestamp at which this collector last collected an item\n     * @type {?number}\n     */\n    this.lastCollectedTimestamp = null;\n  }\n\n  /**\n   * The Date at which this collector last collected an item\n   * @type {?Date}\n   */\n  get lastCollectedAt() {\n    return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const collectedId = await this.collect(...args);\n    if (collectedId) {\n      const filterResult = await this.filter(...args, this.collected);\n      if (filterResult) {\n        this.collected.set(collectedId, args[0]);\n\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('collect', ...args);\n        this.lastCollectedTimestamp = Date.now();\n        if (this._idletimeout) {\n          clearTimeout(this._idletimeout);\n          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n        }\n      } else {\n        /**\n         * Emitted whenever an element is not collected by the collector.\n         * @event Collector#ignore\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('ignore', ...args);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose() {\n    if (!this.options.dispose) return;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected);\n      };\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'user';\n    if (this.ended) return;\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this._endReason = reason;\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset the timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for resetting\n   */\n  resetTimer() {\n    let {\n      time,\n      idle\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = function () {\n      for (var _len3 = arguments.length, item = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        item[_key3] = arguments[_key3];\n      }\n      return queue.push(item);\n    };\n    this.on('collect', onCollect);\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n  toJSON() {\n    return flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    return this._endReason;\n  }\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\n\nmodule.exports = Collector;","map":{"version":3,"names":["EventEmitter","require","setTimeout","clearTimeout","Collection","DiscordjsTypeError","ErrorCodes","flatten","Collector","constructor","client","options","arguments","length","undefined","Object","defineProperty","value","filter","collected","ended","_timeout","_idletimeout","_endReason","InvalidType","handleCollect","bind","handleDispose","time","stop","unref","idle","lastCollectedTimestamp","lastCollectedAt","Date","_len","args","Array","_key","collectedId","collect","filterResult","set","emit","now","checkEnd","dispose","_len2","_key2","has","delete","next","Promise","resolve","reject","cleanup","removeListener","onCollect","onEnd","item","on","reason","resetTimer","endReason","Boolean","Symbol","asyncIterator","queue","_len3","_key3","push","shift","tick","toJSON","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/structures/interfaces/Collector.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { DiscordjsTypeError, ErrorCodes } = require('../../errors');\nconst { flatten } = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @extends {EventEmitter}\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    /**\n     * The reason the collector ended\n     * @type {string|null}\n     * @private\n     */\n    this._endReason = null;\n\n    if (typeof this.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.filter', 'function');\n    }\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n\n    /**\n     * The timestamp at which this collector last collected an item\n     * @type {?number}\n     */\n    this.lastCollectedTimestamp = null;\n  }\n\n  /**\n   * The Date at which this collector last collected an item\n   * @type {?Date}\n   */\n  get lastCollectedAt() {\n    return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collectedId = await this.collect(...args);\n\n    if (collectedId) {\n      const filterResult = await this.filter(...args, this.collected);\n      if (filterResult) {\n        this.collected.set(collectedId, args[0]);\n\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('collect', ...args);\n\n        this.lastCollectedTimestamp = Date.now();\n        if (this._idletimeout) {\n          clearTimeout(this._idletimeout);\n          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n        }\n      } else {\n        /**\n         * Emitted whenever an element is not collected by the collector.\n         * @event Collector#ignore\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('ignore', ...args);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose(...args) {\n    if (!this.options.dispose) return;\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected);\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n\n    this._endReason = reason;\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset the timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for resetting\n   */\n  resetTimer({ time, idle } = {}) {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = (...item) => queue.push(item);\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    return this._endReason;\n  }\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\n\nmodule.exports = Collector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}