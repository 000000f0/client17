{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst AutoModerationRule = require('../structures/AutoModerationRule');\n\n/**\n * Manages API methods for auto moderation rules and stores their cache.\n * @extends {CachedManager}\n */\nclass AutoModerationRuleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, AutoModerationRule, iterable);\n\n    /**\n     * The guild this manager belongs to.\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, AutoModerationRule>}\n   * @name AutoModerationRuleManager#cache\n   */\n\n  /**\n   * Resolves an {@link AutoModerationRuleResolvable} to an {@link AutoModerationRule} object.\n   * @method resolve\n   * @memberof AutoModerationRuleManager\n   * @instance\n   * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve\n   * @returns {?AutoModerationRule}\n   */\n\n  /**\n   * Resolves an {@link AutoModerationRuleResolvable} to a {@link AutoModerationRule} id.\n   * @method resolveId\n   * @memberof AutoModerationRuleManager\n   * @instance\n   * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Options used to set the trigger metadata of an auto moderation rule.\n   * @typedef {Object} AutoModerationTriggerMetadataOptions\n   * @property {string[]} [keywordFilter] The substrings that will be searched for in the content\n   * @property {string[]} [regexPatterns] The regular expression patterns which will be matched against the content\n   * <info>Only Rust-flavored regular expressions are supported.</info>\n   * @property {AutoModerationRuleKeywordPresetType[]} [presets]\n   * The internally pre-defined wordsets which will be searched for in the content\n   * @property {string[]} [allowList] The substrings that will be exempt from triggering\n   * {@link AutoModerationRuleTriggerType.Keyword} and {@link AutoModerationRuleTriggerType.KeywordPreset}\n   * @property {?number} [mentionTotalLimit] The total number of role & user mentions allowed per message\n   * @property {boolean} [mentionRaidProtectionEnabled] Whether to automatically detect mention raids\n   */\n\n  /**\n   * Options used to set the actions of an auto moderation rule.\n   * @typedef {Object} AutoModerationActionOptions\n   * @property {AutoModerationActionType} type The type of this auto moderation rule action\n   * @property {AutoModerationActionMetadataOptions} [metadata] Additional metadata needed during execution\n   * <info>This property is required if using a `type` of\n   * {@link AutoModerationActionType.SendAlertMessage} or {@link AutoModerationActionType.Timeout}.</info>\n   */\n\n  /**\n   * Options used to set the metadata of an auto moderation rule action.\n   * @typedef {Object} AutoModerationActionMetadataOptions\n   * @property {GuildTextChannelResolvable|ThreadChannel} [channel] The channel to which content will be logged\n   * @property {number} [durationSeconds] The timeout duration in seconds\n   * @property {string} [customMessage] The custom message that is shown whenever a message is blocked\n   */\n\n  /**\n   * Options used to create an auto moderation rule.\n   * @typedef {Object} AutoModerationRuleCreateOptions\n   * @property {string} name The name of the auto moderation rule\n   * @property {AutoModerationRuleEventType} eventType The event type of the auto moderation rule\n   * @property {AutoModerationRuleTriggerType} triggerType The trigger type of the auto moderation rule\n   * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule\n   * <info>This property is required if using a `triggerType` of\n   * {@link AutoModerationRuleTriggerType.Keyword}, {@link AutoModerationRuleTriggerType.KeywordPreset},\n   * or {@link AutoModerationRuleTriggerType.MentionSpam}.</info>\n   * @property {AutoModerationActionOptions[]} actions\n   * The actions that will execute when the auto moderation rule is triggered\n   * @property {boolean} [enabled] Whether the auto moderation rule should be enabled\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]\n   * The roles that should not be affected by the auto moderation rule\n   * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]\n   * The channels that should not be affected by the auto moderation rule\n   * @property {string} [reason] The reason for creating the auto moderation rule\n   */\n\n  /**\n   * Creates a new auto moderation rule.\n   * @param {AutoModerationRuleCreateOptions} options Options for creating the auto moderation rule\n   * @returns {Promise<AutoModerationRule>}\n   */\n  async create(_ref) {\n    let {\n      name,\n      eventType,\n      triggerType,\n      triggerMetadata,\n      actions,\n      enabled,\n      exemptRoles,\n      exemptChannels,\n      reason\n    } = _ref;\n    const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {\n      body: {\n        name,\n        event_type: eventType,\n        trigger_type: triggerType,\n        trigger_metadata: triggerMetadata && {\n          keyword_filter: triggerMetadata.keywordFilter,\n          regex_patterns: triggerMetadata.regexPatterns,\n          presets: triggerMetadata.presets,\n          allow_list: triggerMetadata.allowList,\n          mention_total_limit: triggerMetadata.mentionTotalLimit,\n          mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled\n        },\n        actions: actions.map(action => ({\n          type: action.type,\n          metadata: {\n            duration_seconds: action.metadata?.durationSeconds,\n            channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),\n            custom_message: action.metadata?.customMessage\n          }\n        })),\n        enabled,\n        exempt_roles: exemptRoles?.map(exemptRole => this.guild.roles.resolveId(exemptRole)),\n        exempt_channels: exemptChannels?.map(exemptChannel => this.guild.channels.resolveId(exemptChannel))\n      },\n      reason\n    });\n    return this._add(data);\n  }\n\n  /**\n   * Options used to edit an auto moderation rule.\n   * @typedef {Object} AutoModerationRuleEditOptions\n   * @property {string} [name] The name of the auto moderation rule\n   * @property {AutoModerationRuleEventType} [eventType] The event type of the auto moderation rule\n   * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule\n   * @property {AutoModerationActionOptions[]} [actions]\n   * The actions that will execute when the auto moderation rule is triggered\n   * @property {boolean} [enabled] Whether the auto moderation rule should be enabled\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]\n   * The roles that should not be affected by the auto moderation rule\n   * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]\n   * The channels that should not be affected by the auto moderation rule\n   * @property {string} [reason] The reason for creating the auto moderation rule\n   */\n\n  /**\n   * Edits an auto moderation rule.\n   * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to edit\n   * @param {AutoModerationRuleEditOptions} options Options for editing the auto moderation rule\n   * @returns {Promise<AutoModerationRule>}\n   */\n  async edit(autoModerationRule, _ref2) {\n    let {\n      name,\n      eventType,\n      triggerMetadata,\n      actions,\n      enabled,\n      exemptRoles,\n      exemptChannels,\n      reason\n    } = _ref2;\n    const autoModerationRuleId = this.resolveId(autoModerationRule);\n    const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {\n      body: {\n        name,\n        event_type: eventType,\n        trigger_metadata: triggerMetadata && {\n          keyword_filter: triggerMetadata.keywordFilter,\n          regex_patterns: triggerMetadata.regexPatterns,\n          presets: triggerMetadata.presets,\n          allow_list: triggerMetadata.allowList,\n          mention_total_limit: triggerMetadata.mentionTotalLimit,\n          mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled\n        },\n        actions: actions?.map(action => ({\n          type: action.type,\n          metadata: {\n            duration_seconds: action.metadata?.durationSeconds,\n            channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),\n            custom_message: action.metadata?.customMessage\n          }\n        })),\n        enabled,\n        exempt_roles: exemptRoles?.map(exemptRole => this.guild.roles.resolveId(exemptRole)),\n        exempt_channels: exemptChannels?.map(exemptChannel => this.guild.channels.resolveId(exemptChannel))\n      },\n      reason\n    });\n    return this._add(data);\n  }\n\n  /**\n   * Data that can be resolved to give an AutoModerationRule object. This can be:\n   * * An AutoModerationRule\n   * * A Snowflake\n   * @typedef {AutoModerationRule|Snowflake} AutoModerationRuleResolvable\n   */\n\n  /**\n   * Options used to fetch a single auto moderation rule from a guild.\n   * @typedef {BaseFetchOptions} FetchAutoModerationRuleOptions\n   * @property {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to fetch\n   */\n\n  /**\n   * Options used to fetch all auto moderation rules from a guild.\n   * @typedef {Object} FetchAutoModerationRulesOptions\n   * @property {boolean} [cache] Whether to cache the fetched auto moderation rules\n   */\n\n  /**\n   * Fetches auto moderation rules from Discord.\n   * @param {AutoModerationRuleResolvable|FetchAutoModerationRuleOptions|FetchAutoModerationRulesOptions} [options]\n   * Options for fetching auto moderation rule(s)\n   * @returns {Promise<AutoModerationRule|Collection<Snowflake, AutoModerationRule>>}\n   * @example\n   * // Fetch all auto moderation rules from a guild without caching\n   * guild.autoModerationRules.fetch({ cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single auto moderation rule\n   * guild.autoModerationRules.fetch('979083472868098119')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single auto moderation rule without checking cache and without caching\n   * guild.autoModerationRules.fetch({ autoModerationRule: '979083472868098119', cache: false, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const {\n      autoModerationRule,\n      cache,\n      force\n    } = options;\n    const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);\n    if (resolvedAutoModerationRule) {\n      return this._fetchSingle({\n        autoModerationRule: resolvedAutoModerationRule,\n        cache,\n        force\n      });\n    }\n    return this._fetchMany(options);\n  }\n  async _fetchSingle(_ref3) {\n    let {\n      autoModerationRule,\n      cache,\n      force = false\n    } = _ref3;\n    if (!force) {\n      const existing = this.cache.get(autoModerationRule);\n      if (existing) return existing;\n    }\n    const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));\n    return this._add(data, cache);\n  }\n  async _fetchMany() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));\n    return data.reduce((col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)), new Collection());\n  }\n\n  /**\n   * Deletes an auto moderation rule.\n   * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to delete\n   * @param {string} [reason] The reason for deleting the auto moderation rule\n   * @returns {Promise<void>}\n   */\n  async delete(autoModerationRule, reason) {\n    const autoModerationRuleId = this.resolveId(autoModerationRule);\n    await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {\n      reason\n    });\n  }\n}\nmodule.exports = AutoModerationRuleManager;","map":{"version":3,"names":["Collection","require","Routes","CachedManager","AutoModerationRule","AutoModerationRuleManager","constructor","guild","iterable","client","_add","data","cache","extras","create","_ref","name","eventType","triggerType","triggerMetadata","actions","enabled","exemptRoles","exemptChannels","reason","rest","post","guildAutoModerationRules","id","body","event_type","trigger_type","trigger_metadata","keyword_filter","keywordFilter","regex_patterns","regexPatterns","presets","allow_list","allowList","mention_total_limit","mentionTotalLimit","mention_raid_protection_enabled","mentionRaidProtectionEnabled","map","action","type","metadata","duration_seconds","durationSeconds","channel_id","channel","channels","resolveId","custom_message","customMessage","exempt_roles","exemptRole","roles","exempt_channels","exemptChannel","edit","autoModerationRule","_ref2","autoModerationRuleId","patch","guildAutoModerationRule","fetch","options","_fetchMany","force","resolvedAutoModerationRule","_fetchSingle","_ref3","existing","get","arguments","length","undefined","reduce","col","set","delete","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/managers/AutoModerationRuleManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst AutoModerationRule = require('../structures/AutoModerationRule');\n\n/**\n * Manages API methods for auto moderation rules and stores their cache.\n * @extends {CachedManager}\n */\nclass AutoModerationRuleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, AutoModerationRule, iterable);\n\n    /**\n     * The guild this manager belongs to.\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, AutoModerationRule>}\n   * @name AutoModerationRuleManager#cache\n   */\n\n  /**\n   * Resolves an {@link AutoModerationRuleResolvable} to an {@link AutoModerationRule} object.\n   * @method resolve\n   * @memberof AutoModerationRuleManager\n   * @instance\n   * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve\n   * @returns {?AutoModerationRule}\n   */\n\n  /**\n   * Resolves an {@link AutoModerationRuleResolvable} to a {@link AutoModerationRule} id.\n   * @method resolveId\n   * @memberof AutoModerationRuleManager\n   * @instance\n   * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Options used to set the trigger metadata of an auto moderation rule.\n   * @typedef {Object} AutoModerationTriggerMetadataOptions\n   * @property {string[]} [keywordFilter] The substrings that will be searched for in the content\n   * @property {string[]} [regexPatterns] The regular expression patterns which will be matched against the content\n   * <info>Only Rust-flavored regular expressions are supported.</info>\n   * @property {AutoModerationRuleKeywordPresetType[]} [presets]\n   * The internally pre-defined wordsets which will be searched for in the content\n   * @property {string[]} [allowList] The substrings that will be exempt from triggering\n   * {@link AutoModerationRuleTriggerType.Keyword} and {@link AutoModerationRuleTriggerType.KeywordPreset}\n   * @property {?number} [mentionTotalLimit] The total number of role & user mentions allowed per message\n   * @property {boolean} [mentionRaidProtectionEnabled] Whether to automatically detect mention raids\n   */\n\n  /**\n   * Options used to set the actions of an auto moderation rule.\n   * @typedef {Object} AutoModerationActionOptions\n   * @property {AutoModerationActionType} type The type of this auto moderation rule action\n   * @property {AutoModerationActionMetadataOptions} [metadata] Additional metadata needed during execution\n   * <info>This property is required if using a `type` of\n   * {@link AutoModerationActionType.SendAlertMessage} or {@link AutoModerationActionType.Timeout}.</info>\n   */\n\n  /**\n   * Options used to set the metadata of an auto moderation rule action.\n   * @typedef {Object} AutoModerationActionMetadataOptions\n   * @property {GuildTextChannelResolvable|ThreadChannel} [channel] The channel to which content will be logged\n   * @property {number} [durationSeconds] The timeout duration in seconds\n   * @property {string} [customMessage] The custom message that is shown whenever a message is blocked\n   */\n\n  /**\n   * Options used to create an auto moderation rule.\n   * @typedef {Object} AutoModerationRuleCreateOptions\n   * @property {string} name The name of the auto moderation rule\n   * @property {AutoModerationRuleEventType} eventType The event type of the auto moderation rule\n   * @property {AutoModerationRuleTriggerType} triggerType The trigger type of the auto moderation rule\n   * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule\n   * <info>This property is required if using a `triggerType` of\n   * {@link AutoModerationRuleTriggerType.Keyword}, {@link AutoModerationRuleTriggerType.KeywordPreset},\n   * or {@link AutoModerationRuleTriggerType.MentionSpam}.</info>\n   * @property {AutoModerationActionOptions[]} actions\n   * The actions that will execute when the auto moderation rule is triggered\n   * @property {boolean} [enabled] Whether the auto moderation rule should be enabled\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]\n   * The roles that should not be affected by the auto moderation rule\n   * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]\n   * The channels that should not be affected by the auto moderation rule\n   * @property {string} [reason] The reason for creating the auto moderation rule\n   */\n\n  /**\n   * Creates a new auto moderation rule.\n   * @param {AutoModerationRuleCreateOptions} options Options for creating the auto moderation rule\n   * @returns {Promise<AutoModerationRule>}\n   */\n  async create({\n    name,\n    eventType,\n    triggerType,\n    triggerMetadata,\n    actions,\n    enabled,\n    exemptRoles,\n    exemptChannels,\n    reason,\n  }) {\n    const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {\n      body: {\n        name,\n        event_type: eventType,\n        trigger_type: triggerType,\n        trigger_metadata: triggerMetadata && {\n          keyword_filter: triggerMetadata.keywordFilter,\n          regex_patterns: triggerMetadata.regexPatterns,\n          presets: triggerMetadata.presets,\n          allow_list: triggerMetadata.allowList,\n          mention_total_limit: triggerMetadata.mentionTotalLimit,\n          mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled,\n        },\n        actions: actions.map(action => ({\n          type: action.type,\n          metadata: {\n            duration_seconds: action.metadata?.durationSeconds,\n            channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),\n            custom_message: action.metadata?.customMessage,\n          },\n        })),\n        enabled,\n        exempt_roles: exemptRoles?.map(exemptRole => this.guild.roles.resolveId(exemptRole)),\n        exempt_channels: exemptChannels?.map(exemptChannel => this.guild.channels.resolveId(exemptChannel)),\n      },\n      reason,\n    });\n\n    return this._add(data);\n  }\n\n  /**\n   * Options used to edit an auto moderation rule.\n   * @typedef {Object} AutoModerationRuleEditOptions\n   * @property {string} [name] The name of the auto moderation rule\n   * @property {AutoModerationRuleEventType} [eventType] The event type of the auto moderation rule\n   * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule\n   * @property {AutoModerationActionOptions[]} [actions]\n   * The actions that will execute when the auto moderation rule is triggered\n   * @property {boolean} [enabled] Whether the auto moderation rule should be enabled\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]\n   * The roles that should not be affected by the auto moderation rule\n   * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]\n   * The channels that should not be affected by the auto moderation rule\n   * @property {string} [reason] The reason for creating the auto moderation rule\n   */\n\n  /**\n   * Edits an auto moderation rule.\n   * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to edit\n   * @param {AutoModerationRuleEditOptions} options Options for editing the auto moderation rule\n   * @returns {Promise<AutoModerationRule>}\n   */\n  async edit(\n    autoModerationRule,\n    { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason },\n  ) {\n    const autoModerationRuleId = this.resolveId(autoModerationRule);\n\n    const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {\n      body: {\n        name,\n        event_type: eventType,\n        trigger_metadata: triggerMetadata && {\n          keyword_filter: triggerMetadata.keywordFilter,\n          regex_patterns: triggerMetadata.regexPatterns,\n          presets: triggerMetadata.presets,\n          allow_list: triggerMetadata.allowList,\n          mention_total_limit: triggerMetadata.mentionTotalLimit,\n          mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled,\n        },\n        actions: actions?.map(action => ({\n          type: action.type,\n          metadata: {\n            duration_seconds: action.metadata?.durationSeconds,\n            channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),\n            custom_message: action.metadata?.customMessage,\n          },\n        })),\n        enabled,\n        exempt_roles: exemptRoles?.map(exemptRole => this.guild.roles.resolveId(exemptRole)),\n        exempt_channels: exemptChannels?.map(exemptChannel => this.guild.channels.resolveId(exemptChannel)),\n      },\n      reason,\n    });\n\n    return this._add(data);\n  }\n\n  /**\n   * Data that can be resolved to give an AutoModerationRule object. This can be:\n   * * An AutoModerationRule\n   * * A Snowflake\n   * @typedef {AutoModerationRule|Snowflake} AutoModerationRuleResolvable\n   */\n\n  /**\n   * Options used to fetch a single auto moderation rule from a guild.\n   * @typedef {BaseFetchOptions} FetchAutoModerationRuleOptions\n   * @property {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to fetch\n   */\n\n  /**\n   * Options used to fetch all auto moderation rules from a guild.\n   * @typedef {Object} FetchAutoModerationRulesOptions\n   * @property {boolean} [cache] Whether to cache the fetched auto moderation rules\n   */\n\n  /**\n   * Fetches auto moderation rules from Discord.\n   * @param {AutoModerationRuleResolvable|FetchAutoModerationRuleOptions|FetchAutoModerationRulesOptions} [options]\n   * Options for fetching auto moderation rule(s)\n   * @returns {Promise<AutoModerationRule|Collection<Snowflake, AutoModerationRule>>}\n   * @example\n   * // Fetch all auto moderation rules from a guild without caching\n   * guild.autoModerationRules.fetch({ cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single auto moderation rule\n   * guild.autoModerationRules.fetch('979083472868098119')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single auto moderation rule without checking cache and without caching\n   * guild.autoModerationRules.fetch({ autoModerationRule: '979083472868098119', cache: false, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const { autoModerationRule, cache, force } = options;\n    const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);\n    if (resolvedAutoModerationRule) {\n      return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });\n    }\n    return this._fetchMany(options);\n  }\n\n  async _fetchSingle({ autoModerationRule, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(autoModerationRule);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));\n    return this._add(data, cache);\n  }\n\n  async _fetchMany(options = {}) {\n    const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));\n\n    return data.reduce(\n      (col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)),\n      new Collection(),\n    );\n  }\n\n  /**\n   * Deletes an auto moderation rule.\n   * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to delete\n   * @param {string} [reason] The reason for deleting the auto moderation rule\n   * @returns {Promise<void>}\n   */\n  async delete(autoModerationRule, reason) {\n    const autoModerationRuleId = this.resolveId(autoModerationRule);\n    await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });\n  }\n}\n\nmodule.exports = AutoModerationRuleManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAW,CAAC,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAME,aAAa,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAMG,kBAAkB,GAAGH,OAAO,CAAC,kCAAkC,CAAC;;AAEtE;AACA;AACA;AACA;AACA,MAAMI,yBAAyB,SAASF,aAAa,CAAC;EACpDG,WAAWA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IAC3B,KAAK,CAACD,KAAK,CAACE,MAAM,EAAEL,kBAAkB,EAAEI,QAAQ,CAAC;;IAEjD;AACJ;AACA;AACA;IACI,IAAI,CAACD,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEG,IAAIA,CAACC,IAAI,EAAEC,KAAK,EAAE;IAChB,OAAO,KAAK,CAACF,IAAI,CAACC,IAAI,EAAEC,KAAK,EAAE;MAAEC,MAAM,EAAE,CAAC,IAAI,CAACN,KAAK;IAAE,CAAC,CAAC;EAC1D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;EACE,MAAMO,MAAMA,CAAAC,IAAA,EAUT;IAAA,IAVU;MACXC,IAAI;MACJC,SAAS;MACTC,WAAW;MACXC,eAAe;MACfC,OAAO;MACPC,OAAO;MACPC,WAAW;MACXC,cAAc;MACdC;IACF,CAAC,GAAAT,IAAA;IACC,MAAMJ,IAAI,GAAG,MAAM,IAAI,CAACF,MAAM,CAACgB,IAAI,CAACC,IAAI,CAACxB,MAAM,CAACyB,wBAAwB,CAAC,IAAI,CAACpB,KAAK,CAACqB,EAAE,CAAC,EAAE;MACvFC,IAAI,EAAE;QACJb,IAAI;QACJc,UAAU,EAAEb,SAAS;QACrBc,YAAY,EAAEb,WAAW;QACzBc,gBAAgB,EAAEb,eAAe,IAAI;UACnCc,cAAc,EAAEd,eAAe,CAACe,aAAa;UAC7CC,cAAc,EAAEhB,eAAe,CAACiB,aAAa;UAC7CC,OAAO,EAAElB,eAAe,CAACkB,OAAO;UAChCC,UAAU,EAAEnB,eAAe,CAACoB,SAAS;UACrCC,mBAAmB,EAAErB,eAAe,CAACsB,iBAAiB;UACtDC,+BAA+B,EAAEvB,eAAe,CAACwB;QACnD,CAAC;QACDvB,OAAO,EAAEA,OAAO,CAACwB,GAAG,CAACC,MAAM,KAAK;UAC9BC,IAAI,EAAED,MAAM,CAACC,IAAI;UACjBC,QAAQ,EAAE;YACRC,gBAAgB,EAAEH,MAAM,CAACE,QAAQ,EAAEE,eAAe;YAClDC,UAAU,EAAEL,MAAM,CAACE,QAAQ,EAAEI,OAAO,IAAI,IAAI,CAAC5C,KAAK,CAAC6C,QAAQ,CAACC,SAAS,CAACR,MAAM,CAACE,QAAQ,CAACI,OAAO,CAAC;YAC9FG,cAAc,EAAET,MAAM,CAACE,QAAQ,EAAEQ;UACnC;QACF,CAAC,CAAC,CAAC;QACHlC,OAAO;QACPmC,YAAY,EAAElC,WAAW,EAAEsB,GAAG,CAACa,UAAU,IAAI,IAAI,CAAClD,KAAK,CAACmD,KAAK,CAACL,SAAS,CAACI,UAAU,CAAC,CAAC;QACpFE,eAAe,EAAEpC,cAAc,EAAEqB,GAAG,CAACgB,aAAa,IAAI,IAAI,CAACrD,KAAK,CAAC6C,QAAQ,CAACC,SAAS,CAACO,aAAa,CAAC;MACpG,CAAC;MACDpC;IACF,CAAC,CAAC;IAEF,OAAO,IAAI,CAACd,IAAI,CAACC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;EACE,MAAMkD,IAAIA,CACRC,kBAAkB,EAAAC,KAAA,EAElB;IAAA,IADA;MAAE/C,IAAI;MAAEC,SAAS;MAAEE,eAAe;MAAEC,OAAO;MAAEC,OAAO;MAAEC,WAAW;MAAEC,cAAc;MAAEC;IAAO,CAAC,GAAAuC,KAAA;IAE3F,MAAMC,oBAAoB,GAAG,IAAI,CAACX,SAAS,CAACS,kBAAkB,CAAC;IAE/D,MAAMnD,IAAI,GAAG,MAAM,IAAI,CAACF,MAAM,CAACgB,IAAI,CAACwC,KAAK,CAAC/D,MAAM,CAACgE,uBAAuB,CAAC,IAAI,CAAC3D,KAAK,CAACqB,EAAE,EAAEoC,oBAAoB,CAAC,EAAE;MAC7GnC,IAAI,EAAE;QACJb,IAAI;QACJc,UAAU,EAAEb,SAAS;QACrBe,gBAAgB,EAAEb,eAAe,IAAI;UACnCc,cAAc,EAAEd,eAAe,CAACe,aAAa;UAC7CC,cAAc,EAAEhB,eAAe,CAACiB,aAAa;UAC7CC,OAAO,EAAElB,eAAe,CAACkB,OAAO;UAChCC,UAAU,EAAEnB,eAAe,CAACoB,SAAS;UACrCC,mBAAmB,EAAErB,eAAe,CAACsB,iBAAiB;UACtDC,+BAA+B,EAAEvB,eAAe,CAACwB;QACnD,CAAC;QACDvB,OAAO,EAAEA,OAAO,EAAEwB,GAAG,CAACC,MAAM,KAAK;UAC/BC,IAAI,EAAED,MAAM,CAACC,IAAI;UACjBC,QAAQ,EAAE;YACRC,gBAAgB,EAAEH,MAAM,CAACE,QAAQ,EAAEE,eAAe;YAClDC,UAAU,EAAEL,MAAM,CAACE,QAAQ,EAAEI,OAAO,IAAI,IAAI,CAAC5C,KAAK,CAAC6C,QAAQ,CAACC,SAAS,CAACR,MAAM,CAACE,QAAQ,CAACI,OAAO,CAAC;YAC9FG,cAAc,EAAET,MAAM,CAACE,QAAQ,EAAEQ;UACnC;QACF,CAAC,CAAC,CAAC;QACHlC,OAAO;QACPmC,YAAY,EAAElC,WAAW,EAAEsB,GAAG,CAACa,UAAU,IAAI,IAAI,CAAClD,KAAK,CAACmD,KAAK,CAACL,SAAS,CAACI,UAAU,CAAC,CAAC;QACpFE,eAAe,EAAEpC,cAAc,EAAEqB,GAAG,CAACgB,aAAa,IAAI,IAAI,CAACrD,KAAK,CAAC6C,QAAQ,CAACC,SAAS,CAACO,aAAa,CAAC;MACpG,CAAC;MACDpC;IACF,CAAC,CAAC;IAEF,OAAO,IAAI,CAACd,IAAI,CAACC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwD,KAAKA,CAACC,OAAO,EAAE;IACb,IAAI,CAACA,OAAO,EAAE,OAAO,IAAI,CAACC,UAAU,EAAE;IACtC,MAAM;MAAEP,kBAAkB;MAAElD,KAAK;MAAE0D;IAAM,CAAC,GAAGF,OAAO;IACpD,MAAMG,0BAA0B,GAAG,IAAI,CAAClB,SAAS,CAACS,kBAAkB,IAAIM,OAAO,CAAC;IAChF,IAAIG,0BAA0B,EAAE;MAC9B,OAAO,IAAI,CAACC,YAAY,CAAC;QAAEV,kBAAkB,EAAES,0BAA0B;QAAE3D,KAAK;QAAE0D;MAAM,CAAC,CAAC;IAC5F;IACA,OAAO,IAAI,CAACD,UAAU,CAACD,OAAO,CAAC;EACjC;EAEA,MAAMI,YAAYA,CAAAC,KAAA,EAA+C;IAAA,IAA9C;MAAEX,kBAAkB;MAAElD,KAAK;MAAE0D,KAAK,GAAG;IAAM,CAAC,GAAAG,KAAA;IAC7D,IAAI,CAACH,KAAK,EAAE;MACV,MAAMI,QAAQ,GAAG,IAAI,CAAC9D,KAAK,CAAC+D,GAAG,CAACb,kBAAkB,CAAC;MACnD,IAAIY,QAAQ,EAAE,OAAOA,QAAQ;IAC/B;IAEA,MAAM/D,IAAI,GAAG,MAAM,IAAI,CAACF,MAAM,CAACgB,IAAI,CAACkD,GAAG,CAACzE,MAAM,CAACgE,uBAAuB,CAAC,IAAI,CAAC3D,KAAK,CAACqB,EAAE,EAAEkC,kBAAkB,CAAC,CAAC;IAC1G,OAAO,IAAI,CAACpD,IAAI,CAACC,IAAI,EAAEC,KAAK,CAAC;EAC/B;EAEA,MAAMyD,UAAUA,CAAA,EAAe;IAAA,IAAdD,OAAO,GAAAQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAC3B,MAAMjE,IAAI,GAAG,MAAM,IAAI,CAACF,MAAM,CAACgB,IAAI,CAACkD,GAAG,CAACzE,MAAM,CAACyB,wBAAwB,CAAC,IAAI,CAACpB,KAAK,CAACqB,EAAE,CAAC,CAAC;IAEvF,OAAOjB,IAAI,CAACoE,MAAM,CAChB,CAACC,GAAG,EAAElB,kBAAkB,KAAKkB,GAAG,CAACC,GAAG,CAACnB,kBAAkB,CAAClC,EAAE,EAAE,IAAI,CAAClB,IAAI,CAACoD,kBAAkB,EAAEM,OAAO,CAACxD,KAAK,CAAC,CAAC,EACzG,IAAIZ,UAAU,EAAE,CACjB;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMkF,MAAMA,CAACpB,kBAAkB,EAAEtC,MAAM,EAAE;IACvC,MAAMwC,oBAAoB,GAAG,IAAI,CAACX,SAAS,CAACS,kBAAkB,CAAC;IAC/D,MAAM,IAAI,CAACrD,MAAM,CAACgB,IAAI,CAACyD,MAAM,CAAChF,MAAM,CAACgE,uBAAuB,CAAC,IAAI,CAAC3D,KAAK,CAACqB,EAAE,EAAEoC,oBAAoB,CAAC,EAAE;MAAExC;IAAO,CAAC,CAAC;EAChH;AACF;AAEA2D,MAAM,CAACC,OAAO,GAAG/E,yBAAyB"},"metadata":{},"sourceType":"script","externalDependencies":[]}