{"ast":null,"code":"'use strict';\n\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  PermissionFlagsBits\n} = require('discord-api-types/v10');\nconst Base = require('./Base');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst PermissionsBitField = require('../util/PermissionsBitField');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The icon hash of the role\n     * @type {?string}\n     */\n    this.icon = null;\n\n    /**\n     * The unicode emoji for the role\n     * @type {?string}\n     */\n    this.unicodeEmoji = null;\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The role's id (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    if ('name' in data) {\n      /**\n       * The name of the role\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n    if ('color' in data) {\n      /**\n       * The base 10 color of the role\n       * @type {number}\n       */\n      this.color = data.color;\n    }\n    if ('hoist' in data) {\n      /**\n       * If true, users that are part of this role will appear in a separate category in the users list\n       * @type {boolean}\n       */\n      this.hoist = data.hoist;\n    }\n    if ('position' in data) {\n      /**\n       * The raw position of the role from the API\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n    if ('permissions' in data) {\n      /**\n       * The permissions of the role\n       * @type {Readonly<PermissionsBitField>}\n       */\n      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();\n    }\n    if ('managed' in data) {\n      /**\n       * Whether or not the role is managed by an external service\n       * @type {boolean}\n       */\n      this.managed = data.managed;\n    }\n    if ('mentionable' in data) {\n      /**\n       * Whether or not the role can be mentioned by anyone\n       * @type {boolean}\n       */\n      this.mentionable = data.mentionable;\n    }\n    if ('icon' in data) this.icon = data.icon;\n    if ('unicode_emoji' in data) this.unicodeEmoji = data.unicode_emoji;\n\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botId] The id of the bot this role belongs to\n     * @property {Snowflake|string} [integrationId] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     * @property {Snowflake} [subscriptionListingId] The id of this role's subscription SKU and listing\n     * @property {true} [availableForPurchase] Whether this role is available for purchase\n     * @property {true} [guildConnections] Whether this role is a guild's linked role\n     */\n    this.tags = data.tags ? {} : null;\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botId = data.tags.bot_id;\n      }\n      if ('integration_id' in data.tags) {\n        this.tags.integrationId = data.tags.integration_id;\n      }\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n      if ('subscription_listing_id' in data.tags) {\n        this.tags.subscriptionListingId = data.tags.subscription_listing_id;\n      }\n      if ('available_for_purchase' in data.tags) {\n        this.tags.availableForPurchase = true;\n      }\n      if ('guild_connections' in data.tags) {\n        this.tags.guildConnections = true;\n      }\n    }\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return DiscordSnowflake.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    return this.guild.roles.cache.reduce((acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) > BigInt(role.id) : this.rawPosition > role.rawPosition), 0);\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   * @example\n   * // Compare the position of a role to another\n   * const roleCompare = role.comparePositionTo(otherRole);\n   * if (roleCompare >= 1) console.log(`${role.name} is higher than ${otherRole.name}`);\n   */\n  comparePositionTo(role) {\n    return this.guild.roles.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleEditOptions} options The options to provide\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    return this.guild.roles.edit(this, options);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {GuildChannel|Snowflake} channel The guild channel to use as context\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   */\n  permissionsIn(channel) {\n    let checkAdmin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    return channel.rolePermissions(this, checkAdmin);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({\n      color,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} [hoist=true] Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist() {\n    let hoist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      hoist,\n      reason\n    });\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([PermissionFlagsBits.KickMembers, PermissionFlagsBits.BanMembers])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} [mentionable=true] Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable() {\n    let mentionable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      mentionable,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new icon for the role.\n   * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @param {string} [reason] Reason for changing the role's icon\n   * @returns {Promise<Role>}\n   */\n  setIcon(icon, reason) {\n    return this.edit({\n      icon,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new unicode emoji for the role.\n   * @param {?string} unicodeEmoji The new unicode emoji for the role\n   * @param {string} [reason] Reason for changing the role's unicode emoji\n   * @returns {Promise<Role>}\n   * @example\n   * // Set a new unicode emoji for the role\n   * role.setUnicodeEmoji('🤖')\n   *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))\n   *   .catch(console.error);\n   */\n  setUnicodeEmoji(unicodeEmoji, reason) {\n    return this.edit({\n      unicodeEmoji,\n      reason\n    });\n  }\n\n  /**\n   * Options used to set the position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.guild.roles.setPosition(this, position, options);\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.roles.delete(this.id, reason);\n    return this;\n  }\n\n  /**\n   * A link to the role's icon\n   * @param {ImageURLOptions} [options={}] Options for the image URL\n   * @returns {?string}\n   */\n  iconURL() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON({\n        createdTimestamp: true\n      }),\n      permissions: this.permissions.toJSON()\n    };\n  }\n}\nexports.Role = Role;\n\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */","map":{"version":3,"names":["DiscordSnowflake","require","PermissionFlagsBits","Base","DiscordjsError","ErrorCodes","PermissionsBitField","Role","constructor","client","data","guild","icon","unicodeEmoji","_patch","id","name","color","hoist","rawPosition","position","permissions","BigInt","freeze","managed","mentionable","unicode_emoji","tags","botId","bot_id","integrationId","integration_id","premiumSubscriberRole","subscriptionListingId","subscription_listing_id","availableForPurchase","guildConnections","createdTimestamp","timestampFrom","createdAt","Date","hexColor","toString","padStart","members","cache","filter","m","roles","has","editable","clientMember","resolve","user","ManageRoles","highest","comparePositionTo","reduce","acc","role","comparePositions","edit","options","permissionsIn","channel","checkAdmin","arguments","length","undefined","channels","GuildChannelResolve","rolePermissions","setName","reason","setColor","setHoist","setPermissions","setMentionable","setIcon","setUnicodeEmoji","setPosition","delete","iconURL","rest","cdn","roleIcon","equals","bitfield","toJSON","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/structures/Role.js"],"sourcesContent":["'use strict';\n\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst { PermissionFlagsBits } = require('discord-api-types/v10');\nconst Base = require('./Base');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst PermissionsBitField = require('../util/PermissionsBitField');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The icon hash of the role\n     * @type {?string}\n     */\n    this.icon = null;\n\n    /**\n     * The unicode emoji for the role\n     * @type {?string}\n     */\n    this.unicodeEmoji = null;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The role's id (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    if ('name' in data) {\n      /**\n       * The name of the role\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('color' in data) {\n      /**\n       * The base 10 color of the role\n       * @type {number}\n       */\n      this.color = data.color;\n    }\n\n    if ('hoist' in data) {\n      /**\n       * If true, users that are part of this role will appear in a separate category in the users list\n       * @type {boolean}\n       */\n      this.hoist = data.hoist;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the role from the API\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('permissions' in data) {\n      /**\n       * The permissions of the role\n       * @type {Readonly<PermissionsBitField>}\n       */\n      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();\n    }\n\n    if ('managed' in data) {\n      /**\n       * Whether or not the role is managed by an external service\n       * @type {boolean}\n       */\n      this.managed = data.managed;\n    }\n\n    if ('mentionable' in data) {\n      /**\n       * Whether or not the role can be mentioned by anyone\n       * @type {boolean}\n       */\n      this.mentionable = data.mentionable;\n    }\n\n    if ('icon' in data) this.icon = data.icon;\n\n    if ('unicode_emoji' in data) this.unicodeEmoji = data.unicode_emoji;\n\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botId] The id of the bot this role belongs to\n     * @property {Snowflake|string} [integrationId] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     * @property {Snowflake} [subscriptionListingId] The id of this role's subscription SKU and listing\n     * @property {true} [availableForPurchase] Whether this role is available for purchase\n     * @property {true} [guildConnections] Whether this role is a guild's linked role\n     */\n    this.tags = data.tags ? {} : null;\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botId = data.tags.bot_id;\n      }\n      if ('integration_id' in data.tags) {\n        this.tags.integrationId = data.tags.integration_id;\n      }\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n      if ('subscription_listing_id' in data.tags) {\n        this.tags.subscriptionListingId = data.tags.subscription_listing_id;\n      }\n      if ('available_for_purchase' in data.tags) {\n        this.tags.availableForPurchase = true;\n      }\n      if ('guild_connections' in data.tags) {\n        this.tags.guildConnections = true;\n      }\n    }\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return DiscordSnowflake.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    return this.guild.roles.cache.reduce(\n      (acc, role) =>\n        acc +\n        (this.rawPosition === role.rawPosition\n          ? BigInt(this.id) > BigInt(role.id)\n          : this.rawPosition > role.rawPosition),\n      0,\n    );\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   * @example\n   * // Compare the position of a role to another\n   * const roleCompare = role.comparePositionTo(otherRole);\n   * if (roleCompare >= 1) console.log(`${role.name} is higher than ${otherRole.name}`);\n   */\n  comparePositionTo(role) {\n    return this.guild.roles.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleEditOptions} options The options to provide\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    return this.guild.roles.edit(this, options);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {GuildChannel|Snowflake} channel The guild channel to use as context\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   */\n  permissionsIn(channel, checkAdmin = true) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    return channel.rolePermissions(this, checkAdmin);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name, reason });\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({ color, reason });\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} [hoist=true] Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist(hoist = true, reason) {\n    return this.edit({ hoist, reason });\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([PermissionFlagsBits.KickMembers, PermissionFlagsBits.BanMembers])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({ permissions, reason });\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} [mentionable=true] Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable(mentionable = true, reason) {\n    return this.edit({ mentionable, reason });\n  }\n\n  /**\n   * Sets a new icon for the role.\n   * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @param {string} [reason] Reason for changing the role's icon\n   * @returns {Promise<Role>}\n   */\n  setIcon(icon, reason) {\n    return this.edit({ icon, reason });\n  }\n\n  /**\n   * Sets a new unicode emoji for the role.\n   * @param {?string} unicodeEmoji The new unicode emoji for the role\n   * @param {string} [reason] Reason for changing the role's unicode emoji\n   * @returns {Promise<Role>}\n   * @example\n   * // Set a new unicode emoji for the role\n   * role.setUnicodeEmoji('🤖')\n   *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))\n   *   .catch(console.error);\n   */\n  setUnicodeEmoji(unicodeEmoji, reason) {\n    return this.edit({ unicodeEmoji, reason });\n  }\n\n  /**\n   * Options used to set the position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, options = {}) {\n    return this.guild.roles.setPosition(this, position, options);\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.roles.delete(this.id, reason);\n    return this;\n  }\n\n  /**\n   * A link to the role's icon\n   * @param {ImageURLOptions} [options={}] Options for the image URL\n   * @returns {?string}\n   */\n  iconURL(options = {}) {\n    return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return (\n      role &&\n      this.id === role.id &&\n      this.name === role.name &&\n      this.color === role.color &&\n      this.hoist === role.hoist &&\n      this.position === role.position &&\n      this.permissions.bitfield === role.permissions.bitfield &&\n      this.managed === role.managed &&\n      this.icon === role.icon &&\n      this.unicodeEmoji === role.unicodeEmoji\n    );\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return {\n      ...super.toJSON({ createdTimestamp: true }),\n      permissions: this.permissions.toJSON(),\n    };\n  }\n}\n\nexports.Role = Role;\n\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}