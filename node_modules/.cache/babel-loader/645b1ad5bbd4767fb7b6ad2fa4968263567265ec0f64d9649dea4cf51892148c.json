{"ast":null,"code":"'use strict';\n\nconst {\n  isJSONEncodable\n} = require('@discordjs/util');\nconst {\n  InteractionResponseType,\n  MessageFlags,\n  Routes,\n  InteractionType\n} = require('discord-api-types/v10');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../../errors');\nconst InteractionCollector = require('../InteractionCollector');\nconst InteractionResponse = require('../InteractionResponse');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * @typedef {Object} ModalComponentData\n * @property {string} title The title of the modal\n * @property {string} customId The custom id of the modal\n * @property {ActionRow[]} components The components within this modal\n */\n\n/**\n * Interface for classes that support shared interaction response types.\n * @interface\n */\nclass InteractionResponses {\n  /**\n   * Options for deferring the reply to an {@link BaseInteraction}.\n   * @typedef {Object} InteractionDeferReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.\n   * @typedef {Object} InteractionDeferUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for a reply to a {@link BaseInteraction}.\n   * @typedef {BaseMessageOptions} InteractionReplyOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>\n   */\n\n  /**\n   * Options for updating the message received from a {@link MessageComponentInteraction}.\n   * @typedef {MessageEditOptions} InteractionUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Defers the reply to this interaction.\n   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer the reply to this interaction\n   * interaction.deferReply()\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Defer to send an ephemeral reply later\n   * interaction.deferReply({ ephemeral: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferReply() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredChannelMessageWithSource,\n        data: {\n          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined\n        }\n      },\n      auth: false\n    });\n    this.deferred = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Creates a reply to this interaction.\n   * <info>Use the `fetchReply` option to get the bot's reply message.</info>\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Reply to the interaction and fetch the response\n   * interaction.reply({ content: 'Pong!', fetchReply: true })\n   *   .then((message) => console.log(`Reply sent with content ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Create an ephemeral reply with an embed\n   * const embed = new EmbedBuilder().setDescription('Pong!');\n   *\n   * interaction.reply({ embeds: [embed], ephemeral: true })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   */\n  async reply(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      body: data,\n      files\n    } = await messagePayload.resolveBody().resolveFiles();\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.ChannelMessageWithSource,\n        data\n      },\n      files,\n      auth: false\n    });\n    this.replied = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Fetches a reply to this interaction.\n   * @see Webhook#fetchMessage\n   * @param {Snowflake|'@original'} [message='@original'] The response to fetch\n   * @returns {Promise<Message>}\n   * @example\n   * // Fetch the initial reply to this interaction\n   * interaction.fetchReply()\n   *   .then(reply => console.log(`Replied with ${reply.content}`))\n   *   .catch(console.error);\n   */\n  fetchReply() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '@original';\n    return this.webhook.fetchMessage(message);\n  }\n\n  /**\n   * Options that can be passed into {@link InteractionResponses#editReply}.\n   * @typedef {WebhookMessageEditOptions} InteractionEditReplyOptions\n   * @property {MessageResolvable|'@original'} [message='@original'] The response to edit\n   */\n\n  /**\n   * Edits a reply to this interaction.\n   * @see Webhook#editMessage\n   * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message\n   * @returns {Promise<Message>}\n   * @example\n   * // Edit the initial reply to this interaction\n   * interaction.editReply('New content')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async editReply(options) {\n    if (!this.deferred && !this.replied) throw new DiscordjsError(ErrorCodes.InteractionNotReplied);\n    const msg = await this.webhook.editMessage(options.message ?? '@original', options);\n    this.replied = true;\n    return msg;\n  }\n\n  /**\n   * Deletes a reply to this interaction.\n   * @see Webhook#deleteMessage\n   * @param {MessageResolvable|'@original'} [message='@original'] The response to delete\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the initial reply to this interaction\n   * interaction.deleteReply()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deleteReply() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '@original';\n    await this.webhook.deleteMessage(message);\n  }\n\n  /**\n   * Send a follow-up message to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message>}\n   */\n  followUp(options) {\n    if (!this.deferred && !this.replied) return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));\n    return this.webhook.send(options);\n  }\n\n  /**\n   * Defers an update to the message to which the component was attached.\n   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer updating and reset the component's loading state\n   * interaction.deferUpdate()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferUpdate() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredMessageUpdate\n      },\n      auth: false\n    });\n    this.deferred = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);\n  }\n\n  /**\n   * Updates the original message of the component on which the interaction was received on.\n   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message\n   * @returns {Promise<Message|void>}\n   * @example\n   * // Remove the components from the message\n   * interaction.update({\n   *   content: \"A component interaction was received\",\n   *   components: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async update(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      body: data,\n      files\n    } = await messagePayload.resolveBody().resolveFiles();\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.UpdateMessage,\n        data\n      },\n      files,\n      auth: false\n    });\n    this.replied = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);\n  }\n\n  /**\n   * Shows a modal component\n   * @param {ModalBuilder|ModalComponentData|APIModalInteractionResponseCallbackData} modal The modal to show\n   * @returns {Promise<void>}\n   */\n  async showModal(modal) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.Modal,\n        data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)\n      },\n      auth: false\n    });\n    this.replied = true;\n  }\n\n  /**\n   * An object containing the same properties as {@link CollectorOptions}, but a few less:\n   * @typedef {Object} AwaitModalSubmitOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} time Time in milliseconds to wait for an interaction before rejecting\n   */\n\n  /**\n   * Collects a single modal submit interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitModalSubmitOptions} options Options to pass to the internal collector\n   * @returns {Promise<ModalSubmitInteraction>}\n   * @example\n   * // Collect a modal submit interaction\n   * const filter = (interaction) => interaction.customId === 'modal';\n   * interaction.awaitModalSubmit({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was submitted!`))\n   *   .catch(console.error);\n   */\n  awaitModalSubmit(options) {\n    if (typeof options.time !== 'number') throw new DiscordjsError(ErrorCodes.InvalidType, 'time', 'number');\n    const _options = {\n      ...options,\n      max: 1,\n      interactionType: InteractionType.ModalSubmit\n    };\n    return new Promise((resolve, reject) => {\n      const collector = new InteractionCollector(this.client, _options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n  static applyToClass(structure) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const props = ['deferReply', 'reply', 'fetchReply', 'editReply', 'deleteReply', 'followUp', 'deferUpdate', 'update', 'showModal', 'awaitModalSubmit'];\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));\n    }\n  }\n}\nmodule.exports = InteractionResponses;","map":{"version":3,"names":["isJSONEncodable","require","InteractionResponseType","MessageFlags","Routes","InteractionType","DiscordjsError","ErrorCodes","InteractionCollector","InteractionResponse","MessagePayload","InteractionResponses","deferReply","options","arguments","length","undefined","deferred","replied","InteractionAlreadyReplied","ephemeral","client","rest","post","interactionCallback","id","token","body","type","DeferredChannelMessageWithSource","data","flags","Ephemeral","auth","fetchReply","reply","messagePayload","create","files","resolveBody","resolveFiles","ChannelMessageWithSource","message","webhook","fetchMessage","editReply","InteractionNotReplied","msg","editMessage","deleteReply","deleteMessage","followUp","Promise","reject","send","deferUpdate","DeferredMessageUpdate","interaction","update","UpdateMessage","showModal","modal","Modal","toJSON","jsonTransformer","awaitModalSubmit","time","InvalidType","_options","max","interactionType","ModalSubmit","resolve","collector","once","interactions","reason","first","InteractionCollectorError","applyToClass","structure","ignore","props","prop","includes","Object","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/structures/interfaces/InteractionResponses.js"],"sourcesContent":["'use strict';\n\nconst { isJSONEncodable } = require('@discordjs/util');\nconst { InteractionResponseType, MessageFlags, Routes, InteractionType } = require('discord-api-types/v10');\nconst { DiscordjsError, ErrorCodes } = require('../../errors');\nconst InteractionCollector = require('../InteractionCollector');\nconst InteractionResponse = require('../InteractionResponse');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * @typedef {Object} ModalComponentData\n * @property {string} title The title of the modal\n * @property {string} customId The custom id of the modal\n * @property {ActionRow[]} components The components within this modal\n */\n\n/**\n * Interface for classes that support shared interaction response types.\n * @interface\n */\nclass InteractionResponses {\n  /**\n   * Options for deferring the reply to an {@link BaseInteraction}.\n   * @typedef {Object} InteractionDeferReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.\n   * @typedef {Object} InteractionDeferUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for a reply to a {@link BaseInteraction}.\n   * @typedef {BaseMessageOptions} InteractionReplyOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>\n   */\n\n  /**\n   * Options for updating the message received from a {@link MessageComponentInteraction}.\n   * @typedef {MessageEditOptions} InteractionUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Defers the reply to this interaction.\n   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer the reply to this interaction\n   * interaction.deferReply()\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Defer to send an ephemeral reply later\n   * interaction.deferReply({ ephemeral: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferReply(options = {}) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredChannelMessageWithSource,\n        data: {\n          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined,\n        },\n      },\n      auth: false,\n    });\n    this.deferred = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Creates a reply to this interaction.\n   * <info>Use the `fetchReply` option to get the bot's reply message.</info>\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Reply to the interaction and fetch the response\n   * interaction.reply({ content: 'Pong!', fetchReply: true })\n   *   .then((message) => console.log(`Reply sent with content ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Create an ephemeral reply with an embed\n   * const embed = new EmbedBuilder().setDescription('Pong!');\n   *\n   * interaction.reply({ embeds: [embed], ephemeral: true })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   */\n  async reply(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { body: data, files } = await messagePayload.resolveBody().resolveFiles();\n\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.ChannelMessageWithSource,\n        data,\n      },\n      files,\n      auth: false,\n    });\n    this.replied = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Fetches a reply to this interaction.\n   * @see Webhook#fetchMessage\n   * @param {Snowflake|'@original'} [message='@original'] The response to fetch\n   * @returns {Promise<Message>}\n   * @example\n   * // Fetch the initial reply to this interaction\n   * interaction.fetchReply()\n   *   .then(reply => console.log(`Replied with ${reply.content}`))\n   *   .catch(console.error);\n   */\n  fetchReply(message = '@original') {\n    return this.webhook.fetchMessage(message);\n  }\n\n  /**\n   * Options that can be passed into {@link InteractionResponses#editReply}.\n   * @typedef {WebhookMessageEditOptions} InteractionEditReplyOptions\n   * @property {MessageResolvable|'@original'} [message='@original'] The response to edit\n   */\n\n  /**\n   * Edits a reply to this interaction.\n   * @see Webhook#editMessage\n   * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message\n   * @returns {Promise<Message>}\n   * @example\n   * // Edit the initial reply to this interaction\n   * interaction.editReply('New content')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async editReply(options) {\n    if (!this.deferred && !this.replied) throw new DiscordjsError(ErrorCodes.InteractionNotReplied);\n    const msg = await this.webhook.editMessage(options.message ?? '@original', options);\n    this.replied = true;\n    return msg;\n  }\n\n  /**\n   * Deletes a reply to this interaction.\n   * @see Webhook#deleteMessage\n   * @param {MessageResolvable|'@original'} [message='@original'] The response to delete\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the initial reply to this interaction\n   * interaction.deleteReply()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deleteReply(message = '@original') {\n    await this.webhook.deleteMessage(message);\n  }\n\n  /**\n   * Send a follow-up message to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message>}\n   */\n  followUp(options) {\n    if (!this.deferred && !this.replied) return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));\n    return this.webhook.send(options);\n  }\n\n  /**\n   * Defers an update to the message to which the component was attached.\n   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer updating and reset the component's loading state\n   * interaction.deferUpdate()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferUpdate(options = {}) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredMessageUpdate,\n      },\n      auth: false,\n    });\n    this.deferred = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);\n  }\n\n  /**\n   * Updates the original message of the component on which the interaction was received on.\n   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message\n   * @returns {Promise<Message|void>}\n   * @example\n   * // Remove the components from the message\n   * interaction.update({\n   *   content: \"A component interaction was received\",\n   *   components: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async update(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { body: data, files } = await messagePayload.resolveBody().resolveFiles();\n\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.UpdateMessage,\n        data,\n      },\n      files,\n      auth: false,\n    });\n    this.replied = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);\n  }\n\n  /**\n   * Shows a modal component\n   * @param {ModalBuilder|ModalComponentData|APIModalInteractionResponseCallbackData} modal The modal to show\n   * @returns {Promise<void>}\n   */\n  async showModal(modal) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.Modal,\n        data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal),\n      },\n      auth: false,\n    });\n    this.replied = true;\n  }\n\n  /**\n   * An object containing the same properties as {@link CollectorOptions}, but a few less:\n   * @typedef {Object} AwaitModalSubmitOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} time Time in milliseconds to wait for an interaction before rejecting\n   */\n\n  /**\n   * Collects a single modal submit interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitModalSubmitOptions} options Options to pass to the internal collector\n   * @returns {Promise<ModalSubmitInteraction>}\n   * @example\n   * // Collect a modal submit interaction\n   * const filter = (interaction) => interaction.customId === 'modal';\n   * interaction.awaitModalSubmit({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was submitted!`))\n   *   .catch(console.error);\n   */\n  awaitModalSubmit(options) {\n    if (typeof options.time !== 'number') throw new DiscordjsError(ErrorCodes.InvalidType, 'time', 'number');\n    const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };\n    return new Promise((resolve, reject) => {\n      const collector = new InteractionCollector(this.client, _options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  static applyToClass(structure, ignore = []) {\n    const props = [\n      'deferReply',\n      'reply',\n      'fetchReply',\n      'editReply',\n      'deleteReply',\n      'followUp',\n      'deferUpdate',\n      'update',\n      'showModal',\n      'awaitModalSubmit',\n    ];\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = InteractionResponses;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}