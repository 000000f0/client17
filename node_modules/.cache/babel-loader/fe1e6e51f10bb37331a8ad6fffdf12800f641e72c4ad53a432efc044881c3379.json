{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  CloseCodes: () => CloseCodes,\n  CompressionMethod: () => CompressionMethod,\n  DefaultDeviceProperty: () => DefaultDeviceProperty,\n  DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,\n  Encoding: () => Encoding,\n  ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,\n  SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,\n  SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,\n  SimpleShardingStrategy: () => SimpleShardingStrategy,\n  WebSocketManager: () => WebSocketManager,\n  WebSocketShard: () => WebSocketShard,\n  WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,\n  WebSocketShardEvents: () => WebSocketShardEvents,\n  WebSocketShardStatus: () => WebSocketShardStatus,\n  WorkerBootstrapper: () => WorkerBootstrapper,\n  WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,\n  WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,\n  WorkerSendPayloadOp: () => WorkerSendPayloadOp,\n  WorkerShardingStrategy: () => WorkerShardingStrategy,\n  getInitialSendRateLimitState: () => getInitialSendRateLimitState,\n  managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,\n  version: () => version\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/strategies/context/IContextFetchingStrategy.ts\nasync function managerToFetchingStrategyOptions(manager) {\n  const {\n    buildIdentifyThrottler,\n    buildStrategy,\n    retrieveSessionInfo,\n    updateSessionInfo,\n    shardCount,\n    shardIds,\n    rest,\n    ...managerOptions\n  } = manager.options;\n  return {\n    ...managerOptions,\n    gatewayInformation: await manager.fetchGatewayInformation(),\n    shardCount: await manager.getShardCount()\n  };\n}\n__name(managerToFetchingStrategyOptions, \"managerToFetchingStrategyOptions\");\n\n// src/strategies/context/SimpleContextFetchingStrategy.ts\nvar _SimpleContextFetchingStrategy = class {\n  constructor(manager, options) {\n    this.manager = manager;\n    this.options = options;\n  }\n  static async ensureThrottler(manager) {\n    const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);\n    if (throttler) {\n      return throttler;\n    }\n    const newThrottler = await manager.options.buildIdentifyThrottler(manager);\n    _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);\n    return newThrottler;\n  }\n  async retrieveSessionInfo(shardId) {\n    return this.manager.options.retrieveSessionInfo(shardId);\n  }\n  updateSessionInfo(shardId, sessionInfo) {\n    return this.manager.options.updateSessionInfo(shardId, sessionInfo);\n  }\n  async waitForIdentify(shardId, signal) {\n    const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);\n    await throttler.waitForIdentify(shardId, signal);\n  }\n};\nvar SimpleContextFetchingStrategy = _SimpleContextFetchingStrategy;\n__name(SimpleContextFetchingStrategy, \"SimpleContextFetchingStrategy\");\n// This strategy assumes every shard is running under the same process - therefore we need a single\n// IdentifyThrottler per manager.\n__publicField(SimpleContextFetchingStrategy, \"throttlerCache\", /* @__PURE__ */new WeakMap());\n\n// src/strategies/context/WorkerContextFetchingStrategy.ts\nvar import_node_worker_threads2 = require(\"worker_threads\");\nvar import_collection2 = require(\"@discordjs/collection\");\n\n// src/strategies/sharding/WorkerShardingStrategy.ts\nvar import_node_events = require(\"events\");\nvar import_node_path = require(\"path\");\nvar import_node_worker_threads = require(\"worker_threads\");\nvar import_collection = require(\"@discordjs/collection\");\nvar WorkerSendPayloadOp = /* @__PURE__ */(WorkerSendPayloadOp2 => {\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"Connect\"] = 0] = \"Connect\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"Destroy\"] = 1] = \"Destroy\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"Send\"] = 2] = \"Send\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"SessionInfoResponse\"] = 3] = \"SessionInfoResponse\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"ShardIdentifyResponse\"] = 4] = \"ShardIdentifyResponse\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"FetchStatus\"] = 5] = \"FetchStatus\";\n  return WorkerSendPayloadOp2;\n})(WorkerSendPayloadOp || {});\nvar WorkerReceivePayloadOp = /* @__PURE__ */(WorkerReceivePayloadOp2 => {\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"Connected\"] = 0] = \"Connected\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"Destroyed\"] = 1] = \"Destroyed\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"Event\"] = 2] = \"Event\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"RetrieveSessionInfo\"] = 3] = \"RetrieveSessionInfo\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"UpdateSessionInfo\"] = 4] = \"UpdateSessionInfo\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"WaitForIdentify\"] = 5] = \"WaitForIdentify\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"FetchStatusResponse\"] = 6] = \"FetchStatusResponse\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"WorkerReady\"] = 7] = \"WorkerReady\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"CancelIdentify\"] = 8] = \"CancelIdentify\";\n  return WorkerReceivePayloadOp2;\n})(WorkerReceivePayloadOp || {});\nvar WorkerShardingStrategy = class {\n  manager;\n  options;\n  #workers = [];\n  #workerByShardId = new import_collection.Collection();\n  connectPromises = new import_collection.Collection();\n  destroyPromises = new import_collection.Collection();\n  fetchStatusPromises = new import_collection.Collection();\n  waitForIdentifyControllers = new import_collection.Collection();\n  throttler;\n  constructor(manager, options) {\n    this.manager = manager;\n    this.options = options;\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.spawn}\n   */\n  async spawn(shardIds) {\n    const shardsPerWorker = this.options.shardsPerWorker === \"all\" ? shardIds.length : this.options.shardsPerWorker;\n    const strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n    const loops = Math.ceil(shardIds.length / shardsPerWorker);\n    const promises = [];\n    for (let idx = 0; idx < loops; idx++) {\n      const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);\n      const workerData2 = {\n        ...strategyOptions,\n        shardIds: slice\n      };\n      promises.push(this.setupWorker(workerData2));\n    }\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.connect}\n   */\n  async connect() {\n    const promises = [];\n    for (const [shardId, worker] of this.#workerByShardId.entries()) {\n      const payload = {\n        op: 0 /* Connect */,\n        shardId\n      };\n      const promise = new Promise(resolve2 => this.connectPromises.set(shardId, resolve2));\n      worker.postMessage(payload);\n      promises.push(promise);\n    }\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.destroy}\n   */\n  async destroy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const promises = [];\n    for (const [shardId, worker] of this.#workerByShardId.entries()) {\n      const payload = {\n        op: 1 /* Destroy */,\n        shardId,\n        options\n      };\n      promises.push(\n      // eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then\n      new Promise(resolve2 => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));\n      worker.postMessage(payload);\n    }\n    this.#workers = [];\n    this.#workerByShardId.clear();\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.send}\n   */\n  send(shardId, data) {\n    const worker = this.#workerByShardId.get(shardId);\n    if (!worker) {\n      throw new Error(`No worker found for shard ${shardId}`);\n    }\n    const payload = {\n      op: 2 /* Send */,\n      shardId,\n      payload: data\n    };\n    worker.postMessage(payload);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.fetchStatus}\n   */\n  async fetchStatus() {\n    const statuses = new import_collection.Collection();\n    for (const [shardId, worker] of this.#workerByShardId.entries()) {\n      const nonce = Math.random();\n      const payload = {\n        op: 5 /* FetchStatus */,\n        shardId,\n        nonce\n      };\n      const promise = new Promise(resolve2 => this.fetchStatusPromises.set(nonce, resolve2));\n      worker.postMessage(payload);\n      const status = await promise;\n      statuses.set(shardId, status);\n    }\n    return statuses;\n  }\n  async setupWorker(workerData2) {\n    const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), {\n      workerData: workerData2\n    });\n    await (0, import_node_events.once)(worker, \"online\");\n    await this.waitForWorkerReady(worker);\n    worker.on(\"error\", err => {\n      throw err;\n    }).on(\"messageerror\", err => {\n      throw err;\n    }).on(\"message\", async payload => this.onMessage(worker, payload));\n    this.#workers.push(worker);\n    for (const shardId of workerData2.shardIds) {\n      this.#workerByShardId.set(shardId, worker);\n    }\n  }\n  resolveWorkerPath() {\n    const path = this.options.workerPath;\n    if (!path) {\n      return (0, import_node_path.join)(__dirname, \"defaultWorker.js\");\n    }\n    if ((0, import_node_path.isAbsolute)(path)) {\n      return path;\n    }\n    if (/^\\.\\.?[/\\\\]/.test(path)) {\n      return (0, import_node_path.resolve)(path);\n    }\n    try {\n      return require.resolve(path);\n    } catch {\n      return (0, import_node_path.resolve)(path);\n    }\n  }\n  async waitForWorkerReady(worker) {\n    return new Promise(resolve2 => {\n      const handler = /* @__PURE__ */__name(payload => {\n        if (payload.op === 7 /* WorkerReady */) {\n          resolve2();\n          worker.off(\"message\", handler);\n        }\n      }, \"handler\");\n      worker.on(\"message\", handler);\n    });\n  }\n  async onMessage(worker, payload) {\n    switch (payload.op) {\n      case 0 /* Connected */:\n        {\n          this.connectPromises.get(payload.shardId)?.();\n          this.connectPromises.delete(payload.shardId);\n          break;\n        }\n      case 1 /* Destroyed */:\n        {\n          this.destroyPromises.get(payload.shardId)?.();\n          this.destroyPromises.delete(payload.shardId);\n          break;\n        }\n      case 2 /* Event */:\n        {\n          this.manager.emit(payload.event, {\n            ...payload.data,\n            shardId: payload.shardId\n          });\n          break;\n        }\n      case 3 /* RetrieveSessionInfo */:\n        {\n          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);\n          const response = {\n            op: 3 /* SessionInfoResponse */,\n            nonce: payload.nonce,\n            session\n          };\n          worker.postMessage(response);\n          break;\n        }\n      case 4 /* UpdateSessionInfo */:\n        {\n          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);\n          break;\n        }\n      case 5 /* WaitForIdentify */:\n        {\n          const throttler = await this.ensureThrottler();\n          try {\n            const controller = new AbortController();\n            this.waitForIdentifyControllers.set(payload.nonce, controller);\n            await throttler.waitForIdentify(payload.shardId, controller.signal);\n          } catch {\n            return;\n          }\n          const response = {\n            op: 4 /* ShardIdentifyResponse */,\n            nonce: payload.nonce,\n            ok: true\n          };\n          worker.postMessage(response);\n          break;\n        }\n      case 6 /* FetchStatusResponse */:\n        {\n          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);\n          this.fetchStatusPromises.delete(payload.nonce);\n          break;\n        }\n      case 7 /* WorkerReady */:\n        {\n          break;\n        }\n      case 8 /* CancelIdentify */:\n        {\n          this.waitForIdentifyControllers.get(payload.nonce)?.abort();\n          this.waitForIdentifyControllers.delete(payload.nonce);\n          const response = {\n            op: 4 /* ShardIdentifyResponse */,\n            nonce: payload.nonce,\n            ok: false\n          };\n          worker.postMessage(response);\n          break;\n        }\n    }\n  }\n  async ensureThrottler() {\n    this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);\n    return this.throttler;\n  }\n};\n__name(WorkerShardingStrategy, \"WorkerShardingStrategy\");\n\n// src/strategies/context/WorkerContextFetchingStrategy.ts\nvar WorkerContextFetchingStrategy = class {\n  constructor(options) {\n    this.options = options;\n    if (import_node_worker_threads2.isMainThread) {\n      throw new Error(\"Cannot instantiate WorkerContextFetchingStrategy on the main thread\");\n    }\n    import_node_worker_threads2.parentPort.on(\"message\", payload => {\n      if (payload.op === 3 /* SessionInfoResponse */) {\n        this.sessionPromises.get(payload.nonce)?.(payload.session);\n        this.sessionPromises.delete(payload.nonce);\n      }\n      if (payload.op === 4 /* ShardIdentifyResponse */) {\n        const promise = this.waitForIdentifyPromises.get(payload.nonce);\n        if (payload.ok) {\n          promise?.resolve();\n        } else {\n          promise?.reject();\n        }\n        this.waitForIdentifyPromises.delete(payload.nonce);\n      }\n    });\n  }\n  sessionPromises = new import_collection2.Collection();\n  waitForIdentifyPromises = new import_collection2.Collection();\n  async retrieveSessionInfo(shardId) {\n    const nonce = Math.random();\n    const payload = {\n      op: 3 /* RetrieveSessionInfo */,\n      shardId,\n      nonce\n    };\n    const promise = new Promise(resolve2 => this.sessionPromises.set(nonce, resolve2));\n    import_node_worker_threads2.parentPort.postMessage(payload);\n    return promise;\n  }\n  updateSessionInfo(shardId, sessionInfo) {\n    const payload = {\n      op: 4 /* UpdateSessionInfo */,\n      shardId,\n      session: sessionInfo\n    };\n    import_node_worker_threads2.parentPort.postMessage(payload);\n  }\n  async waitForIdentify(shardId, signal) {\n    const nonce = Math.random();\n    const payload = {\n      op: 5 /* WaitForIdentify */,\n      nonce,\n      shardId\n    };\n    const promise = new Promise((resolve2, reject) =>\n    // eslint-disable-next-line no-promise-executor-return\n    this.waitForIdentifyPromises.set(nonce, {\n      resolve: resolve2,\n      reject\n    }));\n    import_node_worker_threads2.parentPort.postMessage(payload);\n    const listener = /* @__PURE__ */__name(() => {\n      const payload2 = {\n        op: 8 /* CancelIdentify */,\n        nonce\n      };\n      import_node_worker_threads2.parentPort.postMessage(payload2);\n    }, \"listener\");\n    signal.addEventListener(\"abort\", listener);\n    try {\n      await promise;\n    } finally {\n      signal.removeEventListener(\"abort\", listener);\n    }\n  }\n};\n__name(WorkerContextFetchingStrategy, \"WorkerContextFetchingStrategy\");\n\n// src/strategies/sharding/SimpleShardingStrategy.ts\nvar import_collection6 = require(\"@discordjs/collection\");\n\n// src/ws/WebSocketShard.ts\nvar import_node_buffer = require(\"buffer\");\nvar import_node_events2 = require(\"events\");\nvar import_node_timers = require(\"timers\");\nvar import_promises2 = require(\"timers/promises\");\nvar import_node_url = require(\"url\");\nvar import_node_util = require(\"util\");\nvar import_node_zlib = require(\"zlib\");\nvar import_collection5 = require(\"@discordjs/collection\");\nvar import_util2 = require(\"@discordjs/util\");\nvar import_async_queue2 = require(\"@sapphire/async-queue\");\nvar import_async_event_emitter = require(\"@vladfrangu/async_event_emitter\");\nvar import_v102 = require(\"discord-api-types/v10\");\nvar import_ws = require(\"ws\");\n\n// src/utils/constants.ts\nvar import_node_process = __toESM(require(\"process\"));\nvar import_collection4 = require(\"@discordjs/collection\");\nvar import_util = require(\"@discordjs/util\");\nvar import_v10 = require(\"discord-api-types/v10\");\n\n// src/throttling/SimpleIdentifyThrottler.ts\nvar import_promises = require(\"timers/promises\");\nvar import_collection3 = require(\"@discordjs/collection\");\nvar import_async_queue = require(\"@sapphire/async-queue\");\nvar SimpleIdentifyThrottler = class {\n  constructor(maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  states = new import_collection3.Collection();\n  /**\n   * {@inheritDoc IIdentifyThrottler.waitForIdentify}\n   */\n  async waitForIdentify(shardId, signal) {\n    const key = shardId % this.maxConcurrency;\n    const state = this.states.ensure(key, () => {\n      return {\n        queue: new import_async_queue.AsyncQueue(),\n        resetsAt: Number.POSITIVE_INFINITY\n      };\n    });\n    await state.queue.wait({\n      signal\n    });\n    try {\n      const diff = state.resetsAt - Date.now();\n      if (diff <= 5e3) {\n        const time = diff + Math.random() * 1500;\n        await (0, import_promises.setTimeout)(time);\n      }\n      state.resetsAt = Date.now() + 5e3;\n    } finally {\n      state.queue.shift();\n    }\n  }\n};\n__name(SimpleIdentifyThrottler, \"SimpleIdentifyThrottler\");\n\n// src/utils/constants.ts\nvar Encoding = /* @__PURE__ */(Encoding2 => {\n  Encoding2[\"JSON\"] = \"json\";\n  return Encoding2;\n})(Encoding || {});\nvar CompressionMethod = /* @__PURE__ */(CompressionMethod2 => {\n  CompressionMethod2[\"ZlibStream\"] = \"zlib-stream\";\n  return CompressionMethod2;\n})(CompressionMethod || {});\nvar DefaultDeviceProperty = `@discordjs/ws 0.8.3`;\nvar getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection());\nvar DefaultWebSocketManagerOptions = {\n  async buildIdentifyThrottler(manager) {\n    const info = await manager.fetchGatewayInformation();\n    return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);\n  },\n  buildStrategy: manager => new SimpleShardingStrategy(manager),\n  shardCount: null,\n  shardIds: null,\n  largeThreshold: null,\n  initialPresence: null,\n  identifyProperties: {\n    browser: DefaultDeviceProperty,\n    device: DefaultDeviceProperty,\n    os: import_node_process.default.platform\n  },\n  version: import_v10.APIVersion,\n  encoding: \"json\" /* JSON */,\n  compression: null,\n  retrieveSessionInfo(shardId) {\n    const store = getDefaultSessionStore();\n    return store.get(shardId) ?? null;\n  },\n  updateSessionInfo(shardId, info) {\n    const store = getDefaultSessionStore();\n    if (info) {\n      store.set(shardId, info);\n    } else {\n      store.delete(shardId);\n    }\n  },\n  handshakeTimeout: 3e4,\n  helloTimeout: 6e4,\n  readyTimeout: 15e3\n};\nvar ImportantGatewayOpcodes = /* @__PURE__ */new Set([import_v10.GatewayOpcodes.Heartbeat, import_v10.GatewayOpcodes.Identify, import_v10.GatewayOpcodes.Resume]);\nfunction getInitialSendRateLimitState() {\n  return {\n    remaining: 120,\n    resetAt: Date.now() + 6e4\n  };\n}\n__name(getInitialSendRateLimitState, \"getInitialSendRateLimitState\");\n\n// src/ws/WebSocketShard.ts\nvar getZlibSync = (0, import_util2.lazy)(async () => import(\"zlib-sync\").then(mod => mod.default).catch(() => null));\nvar WebSocketShardEvents = /* @__PURE__ */(WebSocketShardEvents2 => {\n  WebSocketShardEvents2[\"Closed\"] = \"closed\";\n  WebSocketShardEvents2[\"Debug\"] = \"debug\";\n  WebSocketShardEvents2[\"Dispatch\"] = \"dispatch\";\n  WebSocketShardEvents2[\"Error\"] = \"error\";\n  WebSocketShardEvents2[\"HeartbeatComplete\"] = \"heartbeat\";\n  WebSocketShardEvents2[\"Hello\"] = \"hello\";\n  WebSocketShardEvents2[\"Ready\"] = \"ready\";\n  WebSocketShardEvents2[\"Resumed\"] = \"resumed\";\n  return WebSocketShardEvents2;\n})(WebSocketShardEvents || {});\nvar WebSocketShardStatus = /* @__PURE__ */(WebSocketShardStatus2 => {\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Idle\"] = 0] = \"Idle\";\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Connecting\"] = 1] = \"Connecting\";\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Resuming\"] = 2] = \"Resuming\";\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Ready\"] = 3] = \"Ready\";\n  return WebSocketShardStatus2;\n})(WebSocketShardStatus || {});\nvar WebSocketShardDestroyRecovery = /* @__PURE__ */(WebSocketShardDestroyRecovery2 => {\n  WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2[\"Reconnect\"] = 0] = \"Reconnect\";\n  WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2[\"Resume\"] = 1] = \"Resume\";\n  return WebSocketShardDestroyRecovery2;\n})(WebSocketShardDestroyRecovery || {});\nvar CloseCodes = /* @__PURE__ */(CloseCodes2 => {\n  CloseCodes2[CloseCodes2[\"Normal\"] = 1e3] = \"Normal\";\n  CloseCodes2[CloseCodes2[\"Resuming\"] = 4200] = \"Resuming\";\n  return CloseCodes2;\n})(CloseCodes || {});\nvar WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {\n  connection = null;\n  useIdentifyCompress = false;\n  inflate = null;\n  textDecoder = new import_node_util.TextDecoder();\n  replayedEvents = 0;\n  isAck = true;\n  sendRateLimitState = getInitialSendRateLimitState();\n  initialHeartbeatTimeoutController = null;\n  heartbeatInterval = null;\n  lastHeartbeatAt = -1;\n  // Indicates whether the shard has already resolved its original connect() call\n  initialConnectResolved = false;\n  // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)\n  failedToConnectDueToNetworkError = false;\n  sendQueue = new import_async_queue2.AsyncQueue();\n  timeoutAbortControllers = new import_collection5.Collection();\n  strategy;\n  id;\n  #status = 0 /* Idle */;\n  get status() {\n    return this.#status;\n  }\n  constructor(strategy, id) {\n    super();\n    this.strategy = strategy;\n    this.id = id;\n  }\n  async connect() {\n    const promise = this.initialConnectResolved ? Promise.resolve() : (0, import_node_events2.once)(this, \"ready\" /* Ready */);\n    void this.internalConnect();\n    await promise;\n    this.initialConnectResolved = true;\n  }\n  async internalConnect() {\n    if (this.#status !== 0 /* Idle */) {\n      throw new Error(\"Tried to connect a shard that wasn't idle\");\n    }\n    const {\n      version: version2,\n      encoding,\n      compression\n    } = this.strategy.options;\n    const params = new import_node_url.URLSearchParams({\n      v: version2,\n      encoding\n    });\n    if (compression) {\n      const zlib = await getZlibSync();\n      if (zlib) {\n        params.append(\"compress\", compression);\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          to: \"string\"\n        });\n      } else if (!this.useIdentifyCompress) {\n        this.useIdentifyCompress = true;\n        console.warn(\"WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress\");\n      }\n    }\n    const session = await this.strategy.retrieveSessionInfo(this.id);\n    const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;\n    this.debug([`Connecting to ${url}`]);\n    const connection = new import_ws.WebSocket(url, {\n      handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0\n    }).on(\"message\", this.onMessage.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", this.onClose.bind(this));\n    connection.binaryType = \"arraybuffer\";\n    this.connection = connection;\n    this.#status = 1 /* Connecting */;\n    this.sendRateLimitState = getInitialSendRateLimitState();\n    const {\n      ok\n    } = await this.waitForEvent(\"hello\" /* Hello */, this.strategy.options.helloTimeout);\n    if (!ok) {\n      return;\n    }\n    if (session?.shardCount === this.strategy.options.shardCount) {\n      await this.resume(session);\n    } else {\n      await this.identify();\n    }\n  }\n  async destroy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.#status === 0 /* Idle */) {\n      this.debug([\"Tried to destroy a shard that was idle\"]);\n      return;\n    }\n    if (!options.code) {\n      options.code = options.recover === 1 /* Resume */ ? 4200 /* Resuming */ : 1e3 /* Normal */;\n    }\n\n    this.debug([\"Destroying shard\", `Reason: ${options.reason ?? \"none\"}`, `Code: ${options.code}`, `Recover: ${options.recover === void 0 ? \"none\" : WebSocketShardDestroyRecovery[options.recover]}`]);\n    this.isAck = true;\n    if (this.heartbeatInterval) {\n      (0, import_node_timers.clearInterval)(this.heartbeatInterval);\n    }\n    if (this.initialHeartbeatTimeoutController) {\n      this.initialHeartbeatTimeoutController.abort();\n      this.initialHeartbeatTimeoutController = null;\n    }\n    this.lastHeartbeatAt = -1;\n    for (const controller of this.timeoutAbortControllers.values()) {\n      controller.abort();\n    }\n    this.timeoutAbortControllers.clear();\n    this.failedToConnectDueToNetworkError = false;\n    if (options.recover !== 1 /* Resume */) {\n      await this.strategy.updateSessionInfo(this.id, null);\n    }\n    if (this.connection) {\n      this.connection.removeAllListeners(\"message\");\n      this.connection.removeAllListeners(\"close\");\n      const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;\n      this.debug([\"Connection status during destroy\", `Needs closing: ${shouldClose}`, `Ready state: ${this.connection.readyState}`]);\n      if (shouldClose) {\n        this.connection.close(options.code, options.reason);\n        await (0, import_node_events2.once)(this.connection, \"close\");\n        this.emit(\"closed\" /* Closed */, {\n          code: options.code\n        });\n      }\n      this.connection.removeAllListeners(\"error\");\n    } else {\n      this.debug([\"Destroying a shard that has no connection; please open an issue on GitHub\"]);\n    }\n    this.#status = 0 /* Idle */;\n    if (options.recover !== void 0) {\n      await (0, import_promises2.setTimeout)(500);\n      return this.internalConnect();\n    }\n  }\n  async waitForEvent(event, timeoutDuration) {\n    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : \"indefinitely\"}`]);\n    const timeoutController = new AbortController();\n    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;\n    this.timeoutAbortControllers.set(event, timeoutController);\n    const closeController = new AbortController();\n    try {\n      const closed = await Promise.race([(0, import_node_events2.once)(this, event, {\n        signal: timeoutController.signal\n      }).then(() => false), (0, import_node_events2.once)(this, \"closed\" /* Closed */, {\n        signal: closeController.signal\n      }).then(() => true)]);\n      return {\n        ok: !closed\n      };\n    } catch {\n      void this.destroy({\n        code: 1e3 /* Normal */,\n        reason: \"Something timed out or went wrong while waiting for an event\",\n        recover: 0 /* Reconnect */\n      });\n\n      return {\n        ok: false\n      };\n    } finally {\n      if (timeout) {\n        (0, import_node_timers.clearTimeout)(timeout);\n      }\n      this.timeoutAbortControllers.delete(event);\n      if (!closeController.signal.aborted) {\n        closeController.abort();\n      }\n    }\n  }\n  async send(payload) {\n    if (!this.connection) {\n      throw new Error(\"WebSocketShard wasn't connected\");\n    }\n    if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {\n      this.debug([\"Tried to send a non-crucial payload before the shard was ready, waiting\"]);\n      try {\n        await (0, import_node_events2.once)(this, \"ready\" /* Ready */);\n      } catch {\n        return this.send(payload);\n      }\n    }\n    await this.sendQueue.wait();\n    if (--this.sendRateLimitState.remaining <= 0) {\n      const now = Date.now();\n      if (this.sendRateLimitState.resetAt > now) {\n        const sleepFor = this.sendRateLimitState.resetAt - now;\n        this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);\n        const controller = new AbortController();\n        const interrupted = await Promise.race([(0, import_promises2.setTimeout)(sleepFor).then(() => false), (0, import_node_events2.once)(this, \"closed\" /* Closed */, {\n          signal: controller.signal\n        }).then(() => true)]);\n        if (interrupted) {\n          this.debug([\"Connection closed while waiting for the send rate limit to reset, re-queueing payload\"]);\n          this.sendQueue.shift();\n          return this.send(payload);\n        }\n        controller.abort();\n      }\n      this.sendRateLimitState = getInitialSendRateLimitState();\n    }\n    this.sendQueue.shift();\n    this.connection.send(JSON.stringify(payload));\n  }\n  async identify() {\n    this.debug([\"Waiting for identify throttle\"]);\n    const controller = new AbortController();\n    const closeHandler = /* @__PURE__ */__name(() => {\n      controller.abort();\n    }, \"closeHandler\");\n    this.on(\"closed\" /* Closed */, closeHandler);\n    try {\n      await this.strategy.waitForIdentify(this.id, controller.signal);\n    } catch {\n      this.debug([\"Was waiting for an identify, but the shard closed in the meantime\"]);\n      return;\n    } finally {\n      this.off(\"closed\" /* Closed */, closeHandler);\n    }\n    this.debug([\"Identifying\", `shard id: ${this.id.toString()}`, `shard count: ${this.strategy.options.shardCount}`, `intents: ${this.strategy.options.intents}`, `compression: ${this.inflate ? \"zlib-stream\" : this.useIdentifyCompress ? \"identify\" : \"none\"}`]);\n    const d = {\n      token: this.strategy.options.token,\n      properties: this.strategy.options.identifyProperties,\n      intents: this.strategy.options.intents,\n      compress: this.useIdentifyCompress,\n      shard: [this.id, this.strategy.options.shardCount]\n    };\n    if (this.strategy.options.largeThreshold) {\n      d.large_threshold = this.strategy.options.largeThreshold;\n    }\n    if (this.strategy.options.initialPresence) {\n      d.presence = this.strategy.options.initialPresence;\n    }\n    await this.send({\n      op: import_v102.GatewayOpcodes.Identify,\n      d\n    });\n    await this.waitForEvent(\"ready\" /* Ready */, this.strategy.options.readyTimeout);\n  }\n  async resume(session) {\n    this.debug([\"Resuming session\", `resume url: ${session.resumeURL}`, `sequence: ${session.sequence}`, `shard id: ${this.id.toString()}`]);\n    this.#status = 2 /* Resuming */;\n    this.replayedEvents = 0;\n    return this.send({\n      op: import_v102.GatewayOpcodes.Resume,\n      d: {\n        token: this.strategy.options.token,\n        seq: session.sequence,\n        session_id: session.sessionId\n      }\n    });\n  }\n  async heartbeat() {\n    let requested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.isAck && !requested) {\n      return this.destroy({\n        reason: \"Zombie connection\",\n        recover: 1 /* Resume */\n      });\n    }\n\n    const session = await this.strategy.retrieveSessionInfo(this.id);\n    await this.send({\n      op: import_v102.GatewayOpcodes.Heartbeat,\n      d: session?.sequence ?? null\n    });\n    this.lastHeartbeatAt = Date.now();\n    this.isAck = false;\n  }\n  async unpackMessage(data, isBinary) {\n    const decompressable = new Uint8Array(data);\n    if (!isBinary) {\n      return JSON.parse(this.textDecoder.decode(decompressable));\n    }\n    if (this.useIdentifyCompress) {\n      return new Promise((resolve2, reject) => {\n        (0, import_node_zlib.inflate)(decompressable, {\n          chunkSize: 65535\n        }, (err, result) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve2(JSON.parse(this.textDecoder.decode(result)));\n        });\n      });\n    }\n    if (this.inflate) {\n      const l = decompressable.length;\n      const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;\n      const zlib = await getZlibSync();\n      this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);\n      if (this.inflate.err) {\n        this.emit(\"error\" /* Error */, {\n          error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : \"\"}`)\n        });\n      }\n      if (!flush) {\n        return null;\n      }\n      const {\n        result\n      } = this.inflate;\n      if (!result) {\n        return null;\n      }\n      return JSON.parse(typeof result === \"string\" ? result : this.textDecoder.decode(result));\n    }\n    this.debug([\"Received a message we were unable to decompress\", `isBinary: ${isBinary.toString()}`, `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`, `inflate: ${Boolean(this.inflate).toString()}`]);\n    return null;\n  }\n  async onMessage(data, isBinary) {\n    const payload = await this.unpackMessage(data, isBinary);\n    if (!payload) {\n      return;\n    }\n    switch (payload.op) {\n      case import_v102.GatewayOpcodes.Dispatch:\n        {\n          if (this.#status === 2 /* Resuming */) {\n            this.replayedEvents++;\n          }\n          switch (payload.t) {\n            case import_v102.GatewayDispatchEvents.Ready:\n              {\n                this.#status = 3 /* Ready */;\n                const session2 = {\n                  sequence: payload.s,\n                  sessionId: payload.d.session_id,\n                  shardId: this.id,\n                  shardCount: this.strategy.options.shardCount,\n                  resumeURL: payload.d.resume_gateway_url\n                };\n                await this.strategy.updateSessionInfo(this.id, session2);\n                this.emit(\"ready\" /* Ready */, {\n                  data: payload.d\n                });\n                break;\n              }\n            case import_v102.GatewayDispatchEvents.Resumed:\n              {\n                this.#status = 3 /* Ready */;\n                this.debug([`Resumed and replayed ${this.replayedEvents} events`]);\n                this.emit(\"resumed\" /* Resumed */);\n                break;\n              }\n            default:\n              {\n                break;\n              }\n          }\n          const session = await this.strategy.retrieveSessionInfo(this.id);\n          if (session) {\n            if (payload.s > session.sequence) {\n              await this.strategy.updateSessionInfo(this.id, {\n                ...session,\n                sequence: payload.s\n              });\n            }\n          } else {\n            this.debug([`Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`]);\n          }\n          this.emit(\"dispatch\" /* Dispatch */, {\n            data: payload\n          });\n          break;\n        }\n      case import_v102.GatewayOpcodes.Heartbeat:\n        {\n          await this.heartbeat(true);\n          break;\n        }\n      case import_v102.GatewayOpcodes.Reconnect:\n        {\n          await this.destroy({\n            reason: \"Told to reconnect by Discord\",\n            recover: 1 /* Resume */\n          });\n\n          break;\n        }\n      case import_v102.GatewayOpcodes.InvalidSession:\n        {\n          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);\n          const session = await this.strategy.retrieveSessionInfo(this.id);\n          if (payload.d && session) {\n            await this.resume(session);\n          } else {\n            await this.destroy({\n              reason: \"Invalid session\",\n              recover: 0 /* Reconnect */\n            });\n          }\n\n          break;\n        }\n      case import_v102.GatewayOpcodes.Hello:\n        {\n          this.emit(\"hello\" /* Hello */);\n          const jitter = Math.random();\n          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);\n          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);\n          try {\n            const controller = new AbortController();\n            this.initialHeartbeatTimeoutController = controller;\n            await (0, import_promises2.setTimeout)(firstWait, void 0, {\n              signal: controller.signal\n            });\n          } catch {\n            this.debug([\"Cancelled initial heartbeat due to #destroy being called\"]);\n            return;\n          } finally {\n            this.initialHeartbeatTimeoutController = null;\n          }\n          await this.heartbeat();\n          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);\n          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);\n          break;\n        }\n      case import_v102.GatewayOpcodes.HeartbeatAck:\n        {\n          this.isAck = true;\n          const ackAt = Date.now();\n          this.emit(\"heartbeat\" /* HeartbeatComplete */, {\n            ackAt,\n            heartbeatAt: this.lastHeartbeatAt,\n            latency: ackAt - this.lastHeartbeatAt\n          });\n          break;\n        }\n    }\n  }\n  onError(error) {\n    if (\"code\" in error && [\"ECONNRESET\", \"ECONNREFUSED\"].includes(error.code)) {\n      this.debug([\"Failed to connect to the gateway URL specified due to a network error\"]);\n      this.failedToConnectDueToNetworkError = true;\n      return;\n    }\n    this.emit(\"error\" /* Error */, {\n      error\n    });\n  }\n  async onClose(code) {\n    this.emit(\"closed\" /* Closed */, {\n      code\n    });\n    switch (code) {\n      case 1e3 /* Normal */:\n        {\n          return this.destroy({\n            code,\n            reason: \"Got disconnected by Discord\",\n            recover: 0 /* Reconnect */\n          });\n        }\n\n      case 4200 /* Resuming */:\n        {\n          break;\n        }\n      case import_v102.GatewayCloseCodes.UnknownError:\n        {\n          this.debug([`An unknown error occurred: ${code}`]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.UnknownOpcode:\n        {\n          this.debug([\"An invalid opcode was sent to Discord.\"]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.DecodeError:\n        {\n          this.debug([\"An invalid payload was sent to Discord.\"]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.NotAuthenticated:\n        {\n          this.debug([\"A request was somehow sent before the identify/resume payload.\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.AuthenticationFailed:\n        {\n          throw new Error(\"Authentication failed\");\n        }\n      case import_v102.GatewayCloseCodes.AlreadyAuthenticated:\n        {\n          this.debug([\"More than one auth payload was sent.\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.InvalidSeq:\n        {\n          this.debug([\"An invalid sequence was sent.\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.RateLimited:\n        {\n          this.debug([\"The WebSocket rate limit has been hit, this should never happen\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.SessionTimedOut:\n        {\n          this.debug([\"Session timed out.\"]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n\n      case import_v102.GatewayCloseCodes.InvalidShard:\n        {\n          throw new Error(\"Invalid shard\");\n        }\n      case import_v102.GatewayCloseCodes.ShardingRequired:\n        {\n          throw new Error(\"Sharding is required\");\n        }\n      case import_v102.GatewayCloseCodes.InvalidAPIVersion:\n        {\n          throw new Error(\"Used an invalid API version\");\n        }\n      case import_v102.GatewayCloseCodes.InvalidIntents:\n        {\n          throw new Error(\"Used invalid intents\");\n        }\n      case import_v102.GatewayCloseCodes.DisallowedIntents:\n        {\n          throw new Error(\"Used disallowed intents\");\n        }\n      default:\n        {\n          this.debug([`The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? \"reconnect\" : \"resume\"}.`]);\n          return this.destroy({\n            code,\n            recover: this.failedToConnectDueToNetworkError ? 0 /* Reconnect */ : 1 /* Resume */\n          });\n        }\n    }\n  }\n\n  debug(messages) {\n    const message = `${messages[0]}${messages.length > 1 ? `\n${messages.slice(1).map(m => `\t${m}`).join(\"\\n\")}` : \"\"}`;\n    this.emit(\"debug\" /* Debug */, {\n      message\n    });\n  }\n};\n__name(WebSocketShard, \"WebSocketShard\");\n\n// src/strategies/sharding/SimpleShardingStrategy.ts\nvar SimpleShardingStrategy = class {\n  manager;\n  shards = new import_collection6.Collection();\n  constructor(manager) {\n    this.manager = manager;\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.spawn}\n   */\n  async spawn(shardIds) {\n    const strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n    for (const shardId of shardIds) {\n      const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);\n      const shard = new WebSocketShard(strategy, shardId);\n      for (const event of Object.values(WebSocketShardEvents)) {\n        shard.on(event, payload => this.manager.emit(event, {\n          ...payload,\n          shardId\n        }));\n      }\n      this.shards.set(shardId, shard);\n    }\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.connect}\n   */\n  async connect() {\n    const promises = [];\n    for (const shard of this.shards.values()) {\n      promises.push(shard.connect());\n    }\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.destroy}\n   */\n  async destroy(options) {\n    const promises = [];\n    for (const shard of this.shards.values()) {\n      promises.push(shard.destroy(options));\n    }\n    await Promise.all(promises);\n    this.shards.clear();\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.send}\n   */\n  async send(shardId, payload) {\n    const shard = this.shards.get(shardId);\n    if (!shard) {\n      throw new RangeError(`Shard ${shardId} not found`);\n    }\n    return shard.send(payload);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.fetchStatus}\n   */\n  async fetchStatus() {\n    return this.shards.mapValues(shard => shard.status);\n  }\n};\n__name(SimpleShardingStrategy, \"SimpleShardingStrategy\");\n\n// src/utils/WorkerBootstrapper.ts\nvar import_node_worker_threads3 = require(\"worker_threads\");\nvar import_collection7 = require(\"@discordjs/collection\");\nvar WorkerBootstrapper = class {\n  /**\n   * The data passed to the worker thread\n   */\n  data = import_node_worker_threads3.workerData;\n  /**\n   * The shards that are managed by this worker\n   */\n  shards = new import_collection7.Collection();\n  constructor() {\n    if (import_node_worker_threads3.isMainThread) {\n      throw new Error(\"Expected WorkerBootstrap to not be used within the main thread\");\n    }\n  }\n  /**\n   * Helper method to initiate a shard's connection process\n   */\n  async connect(shardId) {\n    const shard = this.shards.get(shardId);\n    if (!shard) {\n      throw new RangeError(`Shard ${shardId} does not exist`);\n    }\n    await shard.connect();\n  }\n  /**\n   * Helper method to destroy a shard\n   */\n  async destroy(shardId, options) {\n    const shard = this.shards.get(shardId);\n    if (!shard) {\n      throw new RangeError(`Shard ${shardId} does not exist`);\n    }\n    await shard.destroy(options);\n  }\n  /**\n   * Helper method to attach event listeners to the parentPort\n   */\n  setupThreadEvents() {\n    import_node_worker_threads3.parentPort.on(\"messageerror\", err => {\n      throw err;\n    }).on(\"message\", async payload => {\n      switch (payload.op) {\n        case 0 /* Connect */:\n          {\n            await this.connect(payload.shardId);\n            const response = {\n              op: 0 /* Connected */,\n              shardId: payload.shardId\n            };\n            import_node_worker_threads3.parentPort.postMessage(response);\n            break;\n          }\n        case 1 /* Destroy */:\n          {\n            await this.destroy(payload.shardId, payload.options);\n            const response = {\n              op: 1 /* Destroyed */,\n              shardId: payload.shardId\n            };\n            import_node_worker_threads3.parentPort.postMessage(response);\n            break;\n          }\n        case 2 /* Send */:\n          {\n            const shard = this.shards.get(payload.shardId);\n            if (!shard) {\n              throw new RangeError(`Shard ${payload.shardId} does not exist`);\n            }\n            await shard.send(payload.payload);\n            break;\n          }\n        case 3 /* SessionInfoResponse */:\n          {\n            break;\n          }\n        case 4 /* ShardIdentifyResponse */:\n          {\n            break;\n          }\n        case 5 /* FetchStatus */:\n          {\n            const shard = this.shards.get(payload.shardId);\n            if (!shard) {\n              throw new Error(`Shard ${payload.shardId} does not exist`);\n            }\n            const response = {\n              op: 6 /* FetchStatusResponse */,\n              status: shard.status,\n              nonce: payload.nonce\n            };\n            import_node_worker_threads3.parentPort.postMessage(response);\n            break;\n          }\n      }\n    });\n  }\n  /**\n   * Bootstraps the worker thread with the provided options\n   */\n  async bootstrap() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    for (const shardId of this.data.shardIds) {\n      const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);\n      for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {\n        shard.on(event, data => {\n          const payload = {\n            op: 2 /* Event */,\n            event,\n            data,\n            shardId\n          };\n          import_node_worker_threads3.parentPort.postMessage(payload);\n        });\n      }\n      await options.shardCallback?.(shard);\n      this.shards.set(shardId, shard);\n    }\n    this.setupThreadEvents();\n    const message = {\n      op: 7 /* WorkerReady */\n    };\n\n    import_node_worker_threads3.parentPort.postMessage(message);\n  }\n};\n__name(WorkerBootstrapper, \"WorkerBootstrapper\");\n\n// src/ws/WebSocketManager.ts\nvar import_util3 = require(\"@discordjs/util\");\nvar import_async_event_emitter2 = require(\"@vladfrangu/async_event_emitter\");\nvar import_v103 = require(\"discord-api-types/v10\");\nvar WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {\n  /**\n   * The options being used by this manager\n   */\n  options;\n  /**\n   * Internal cache for a GET /gateway/bot result\n   */\n  gatewayInformation = null;\n  /**\n   * Internal cache for the shard ids\n   */\n  shardIds = null;\n  /**\n   * Strategy used to manage shards\n   *\n   * @defaultValue `SimpleShardingStrategy`\n   */\n  strategy;\n  constructor(options) {\n    super();\n    this.options = {\n      ...DefaultWebSocketManagerOptions,\n      ...options\n    };\n    this.strategy = this.options.buildStrategy(this);\n  }\n  /**\n   * Fetches the gateway information from Discord - or returns it from cache if available\n   *\n   * @param force - Whether to ignore the cache and force a fresh fetch\n   */\n  async fetchGatewayInformation() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.gatewayInformation) {\n      if (this.gatewayInformation.expiresAt <= Date.now()) {\n        this.gatewayInformation = null;\n      } else if (!force) {\n        return this.gatewayInformation.data;\n      }\n    }\n    const data = await this.options.rest.get(import_v103.Routes.gatewayBot());\n    this.gatewayInformation = {\n      data,\n      expiresAt: Date.now() + data.session_start_limit.reset_after\n    };\n    return this.gatewayInformation.data;\n  }\n  /**\n   * Updates your total shard count on-the-fly, spawning shards as needed\n   *\n   * @param shardCount - The new shard count to use\n   */\n  async updateShardCount(shardCount) {\n    await this.strategy.destroy({\n      reason: \"User is adjusting their shards\"\n    });\n    this.options.shardCount = shardCount;\n    const shardIds = await this.getShardIds(true);\n    await this.strategy.spawn(shardIds);\n    return this;\n  }\n  /**\n   * Yields the total number of shards across for your bot, accounting for Discord recommendations\n   */\n  async getShardCount() {\n    if (this.options.shardCount) {\n      return this.options.shardCount;\n    }\n    const shardIds = await this.getShardIds();\n    return Math.max(...shardIds) + 1;\n  }\n  /**\n   * Yields the ids of the shards this manager should manage\n   */\n  async getShardIds() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.shardIds && !force) {\n      return this.shardIds;\n    }\n    let shardIds;\n    if (this.options.shardIds) {\n      if (Array.isArray(this.options.shardIds)) {\n        shardIds = this.options.shardIds;\n      } else {\n        const {\n          start,\n          end\n        } = this.options.shardIds;\n        shardIds = [...(0, import_util3.range)({\n          start,\n          end: end + 1\n        })];\n      }\n    } else {\n      const data = await this.fetchGatewayInformation();\n      shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];\n    }\n    this.shardIds = shardIds;\n    return shardIds;\n  }\n  async connect() {\n    const shardCount = await this.getShardCount();\n    const data = await this.fetchGatewayInformation();\n    if (data.session_start_limit.remaining < shardCount) {\n      throw new Error(`Not enough sessions remaining to spawn ${shardCount} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);\n    }\n    await this.updateShardCount(shardCount);\n    await this.strategy.connect();\n  }\n  destroy(options) {\n    return this.strategy.destroy(options);\n  }\n  send(shardId, payload) {\n    return this.strategy.send(shardId, payload);\n  }\n  fetchStatus() {\n    return this.strategy.fetchStatus();\n  }\n};\n__name(WebSocketManager, \"WebSocketManager\");\n\n// src/index.ts\nvar version = \"0.8.3\";\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  CloseCodes,\n  CompressionMethod,\n  DefaultDeviceProperty,\n  DefaultWebSocketManagerOptions,\n  Encoding,\n  ImportantGatewayOpcodes,\n  SimpleContextFetchingStrategy,\n  SimpleIdentifyThrottler,\n  SimpleShardingStrategy,\n  WebSocketManager,\n  WebSocketShard,\n  WebSocketShardDestroyRecovery,\n  WebSocketShardEvents,\n  WebSocketShardStatus,\n  WorkerBootstrapper,\n  WorkerContextFetchingStrategy,\n  WorkerReceivePayloadOp,\n  WorkerSendPayloadOp,\n  WorkerShardingStrategy,\n  getInitialSendRateLimitState,\n  managerToFetchingStrategyOptions,\n  version\n});","map":{"version":3,"names":["src_exports","__export","CloseCodes","CompressionMethod","DefaultDeviceProperty","DefaultWebSocketManagerOptions","Encoding","ImportantGatewayOpcodes","SimpleContextFetchingStrategy","SimpleIdentifyThrottler","SimpleShardingStrategy","WebSocketManager","WebSocketShard","WebSocketShardDestroyRecovery","WebSocketShardEvents","WebSocketShardStatus","WorkerBootstrapper","WorkerContextFetchingStrategy","WorkerReceivePayloadOp","WorkerSendPayloadOp","WorkerShardingStrategy","getInitialSendRateLimitState","managerToFetchingStrategyOptions","version","module","exports","__toCommonJS","manager","buildIdentifyThrottler","buildStrategy","retrieveSessionInfo","updateSessionInfo","shardCount","shardIds","rest","managerOptions","options","gatewayInformation","fetchGatewayInformation","getShardCount","__name","_SimpleContextFetchingStrategy","constructor","ensureThrottler","throttler","throttlerCache","get","newThrottler","set","shardId","sessionInfo","waitForIdentify","signal","__publicField","WeakMap","import_node_worker_threads2","require","import_collection2","import_node_events","import_node_path","import_node_worker_threads","import_collection","WorkerSendPayloadOp2","WorkerReceivePayloadOp2","workers","workerByShardId","Collection","connectPromises","destroyPromises","fetchStatusPromises","waitForIdentifyControllers","spawn","shardsPerWorker","length","strategyOptions","loops","Math","ceil","promises","idx","slice","workerData2","push","setupWorker","Promise","all","connect","worker","entries","payload","op","promise","resolve2","postMessage","destroy","arguments","undefined","then","terminate","clear","send","data","Error","fetchStatus","statuses","nonce","random","status","Worker","resolveWorkerPath","workerData","once","waitForWorkerReady","on","err","onMessage","path","workerPath","join","__dirname","isAbsolute","test","resolve","handler","off","delete","emit","event","session","response","controller","AbortController","ok","abort","isMainThread","parentPort","sessionPromises","waitForIdentifyPromises","reject","listener","payload2","addEventListener","removeEventListener","import_collection6","import_node_buffer","import_node_events2","import_node_timers","import_promises2","import_node_url","import_node_util","import_node_zlib","import_collection5","import_util2","import_async_queue2","import_async_event_emitter","import_v102","import_ws","import_node_process","__toESM","import_collection4","import_util","import_v10","import_promises","import_collection3","import_async_queue","maxConcurrency","states","key","state","ensure","queue","AsyncQueue","resetsAt","Number","POSITIVE_INFINITY","wait","diff","Date","now","time","setTimeout","shift","Encoding2","CompressionMethod2","getDefaultSessionStore","lazy","info","session_start_limit","max_concurrency","largeThreshold","initialPresence","identifyProperties","browser","device","os","default","platform","APIVersion","encoding","compression","store","handshakeTimeout","helloTimeout","readyTimeout","Set","GatewayOpcodes","Heartbeat","Identify","Resume","remaining","resetAt","getZlibSync","mod","catch","WebSocketShardEvents2","WebSocketShardStatus2","WebSocketShardDestroyRecovery2","CloseCodes2","AsyncEventEmitter","connection","useIdentifyCompress","inflate","textDecoder","TextDecoder","replayedEvents","isAck","sendRateLimitState","initialHeartbeatTimeoutController","heartbeatInterval","lastHeartbeatAt","initialConnectResolved","failedToConnectDueToNetworkError","sendQueue","timeoutAbortControllers","strategy","id","internalConnect","version2","params","URLSearchParams","v","zlib","append","Inflate","chunkSize","to","console","warn","url","resumeURL","toString","debug","WebSocket","bind","onError","onClose","binaryType","waitForEvent","resume","identify","code","recover","reason","clearInterval","values","removeAllListeners","shouldClose","readyState","OPEN","close","timeoutDuration","timeoutController","timeout","unref","closeController","closed","race","clearTimeout","aborted","has","sleepFor","interrupted","JSON","stringify","closeHandler","intents","d","token","properties","compress","shard","large_threshold","presence","sequence","seq","session_id","sessionId","heartbeat","requested","unpackMessage","isBinary","decompressable","Uint8Array","parse","decode","result","l","flush","Buffer","from","Z_SYNC_FLUSH","Z_NO_FLUSH","error","msg","Boolean","Dispatch","t","GatewayDispatchEvents","Ready","session2","s","resume_gateway_url","Resumed","Reconnect","InvalidSession","Hello","jitter","firstWait","floor","heartbeat_interval","setInterval","HeartbeatAck","ackAt","heartbeatAt","latency","includes","GatewayCloseCodes","UnknownError","UnknownOpcode","DecodeError","NotAuthenticated","AuthenticationFailed","AlreadyAuthenticated","InvalidSeq","RateLimited","SessionTimedOut","InvalidShard","ShardingRequired","InvalidAPIVersion","InvalidIntents","DisallowedIntents","messages","message","map","m","shards","Object","RangeError","mapValues","import_node_worker_threads3","import_collection7","setupThreadEvents","bootstrap","forwardEvents","shardCallback","import_util3","import_async_event_emitter2","import_v103","force","expiresAt","Routes","gatewayBot","reset_after","updateShardCount","getShardIds","max","Array","isArray","start","end","range","toISOString"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/index.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/strategies/context/IContextFetchingStrategy.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/strategies/context/SimpleContextFetchingStrategy.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/strategies/context/WorkerContextFetchingStrategy.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/strategies/sharding/WorkerShardingStrategy.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/strategies/sharding/SimpleShardingStrategy.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/ws/WebSocketShard.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/utils/constants.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/throttling/SimpleIdentifyThrottler.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/utils/WorkerBootstrapper.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/ws/src/ws/WebSocketManager.ts"],"sourcesContent":["export * from './strategies/context/IContextFetchingStrategy.js';\nexport * from './strategies/context/SimpleContextFetchingStrategy.js';\nexport * from './strategies/context/WorkerContextFetchingStrategy.js';\n\nexport * from './strategies/sharding/IShardingStrategy.js';\nexport * from './strategies/sharding/SimpleShardingStrategy.js';\nexport * from './strategies/sharding/WorkerShardingStrategy.js';\n\nexport * from './throttling/IIdentifyThrottler.js';\nexport * from './throttling/SimpleIdentifyThrottler.js';\n\nexport * from './utils/constants.js';\nexport * from './utils/WorkerBootstrapper.js';\n\nexport * from './ws/WebSocketManager.js';\nexport * from './ws/WebSocketShard.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/ws/#readme | @discordjs/ws} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\nexport const version = '0.8.3' as string;\n","import type { Awaitable } from '@discordjs/util';\nimport type { APIGatewayBotInfo } from 'discord-api-types/v10';\nimport type { SessionInfo, WebSocketManager, WebSocketManagerOptions } from '../../ws/WebSocketManager.js';\n\nexport interface FetchingStrategyOptions\n\textends Omit<\n\t\tWebSocketManagerOptions,\n\t\t| 'buildIdentifyThrottler'\n\t\t| 'buildStrategy'\n\t\t| 'rest'\n\t\t| 'retrieveSessionInfo'\n\t\t| 'shardCount'\n\t\t| 'shardIds'\n\t\t| 'updateSessionInfo'\n\t> {\n\treadonly gatewayInformation: APIGatewayBotInfo;\n\treadonly shardCount: number;\n}\n\n/**\n * Strategies responsible solely for making manager information accessible\n */\nexport interface IContextFetchingStrategy {\n\treadonly options: FetchingStrategyOptions;\n\tretrieveSessionInfo(shardId: number): Awaitable<SessionInfo | null>;\n\tupdateSessionInfo(shardId: number, sessionInfo: SessionInfo | null): Awaitable<void>;\n\t/**\n\t * Resolves once the given shard should be allowed to identify, or rejects if the operation was aborted\n\t */\n\twaitForIdentify(shardId: number, signal: AbortSignal): Promise<void>;\n}\n\nexport async function managerToFetchingStrategyOptions(manager: WebSocketManager): Promise<FetchingStrategyOptions> {\n\t/* eslint-disable @typescript-eslint/unbound-method */\n\tconst {\n\t\tbuildIdentifyThrottler,\n\t\tbuildStrategy,\n\t\tretrieveSessionInfo,\n\t\tupdateSessionInfo,\n\t\tshardCount,\n\t\tshardIds,\n\t\trest,\n\t\t...managerOptions\n\t} = manager.options;\n\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\treturn {\n\t\t...managerOptions,\n\t\tgatewayInformation: await manager.fetchGatewayInformation(),\n\t\tshardCount: await manager.getShardCount(),\n\t};\n}\n","import type { IIdentifyThrottler } from '../../throttling/IIdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\nexport class SimpleContextFetchingStrategy implements IContextFetchingStrategy {\n\t// This strategy assumes every shard is running under the same process - therefore we need a single\n\t// IdentifyThrottler per manager.\n\tprivate static throttlerCache = new WeakMap<WebSocketManager, IIdentifyThrottler>();\n\n\tprivate static async ensureThrottler(manager: WebSocketManager): Promise<IIdentifyThrottler> {\n\t\tconst throttler = SimpleContextFetchingStrategy.throttlerCache.get(manager);\n\t\tif (throttler) {\n\t\t\treturn throttler;\n\t\t}\n\n\t\tconst newThrottler = await manager.options.buildIdentifyThrottler(manager);\n\t\tSimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);\n\n\t\treturn newThrottler;\n\t}\n\n\tpublic constructor(private readonly manager: WebSocketManager, public readonly options: FetchingStrategyOptions) {}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\treturn this.manager.options.retrieveSessionInfo(shardId);\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\treturn this.manager.options.updateSessionInfo(shardId, sessionInfo);\n\t}\n\n\tpublic async waitForIdentify(shardId: number, signal: AbortSignal): Promise<void> {\n\t\tconst throttler = await SimpleContextFetchingStrategy.ensureThrottler(this.manager);\n\t\tawait throttler.waitForIdentify(shardId, signal);\n\t}\n}\n","import { isMainThread, parentPort } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { SessionInfo } from '../../ws/WebSocketManager.js';\nimport {\n\tWorkerReceivePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerReceivePayload,\n\ttype WorkerSendPayload,\n} from '../sharding/WorkerShardingStrategy.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\n// Because the global types are incomplete for whatever reason\ninterface PolyFillAbortSignal {\n\treadonly aborted: boolean;\n\taddEventListener(type: 'abort', listener: () => void): void;\n\tremoveEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport class WorkerContextFetchingStrategy implements IContextFetchingStrategy {\n\tprivate readonly sessionPromises = new Collection<number, (session: SessionInfo | null) => void>();\n\n\tprivate readonly waitForIdentifyPromises = new Collection<number, { reject(): void; resolve(): void }>();\n\n\tpublic constructor(public readonly options: FetchingStrategyOptions) {\n\t\tif (isMainThread) {\n\t\t\tthrow new Error('Cannot instantiate WorkerContextFetchingStrategy on the main thread');\n\t\t}\n\n\t\tparentPort!.on('message', (payload: WorkerSendPayload) => {\n\t\t\tif (payload.op === WorkerSendPayloadOp.SessionInfoResponse) {\n\t\t\t\tthis.sessionPromises.get(payload.nonce)?.(payload.session);\n\t\t\t\tthis.sessionPromises.delete(payload.nonce);\n\t\t\t}\n\n\t\t\tif (payload.op === WorkerSendPayloadOp.ShardIdentifyResponse) {\n\t\t\t\tconst promise = this.waitForIdentifyPromises.get(payload.nonce);\n\t\t\t\tif (payload.ok) {\n\t\t\t\t\tpromise?.resolve();\n\t\t\t\t} else {\n\t\t\t\t\tpromise?.reject();\n\t\t\t\t}\n\n\t\t\t\tthis.waitForIdentifyPromises.delete(payload.nonce);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\tconst nonce = Math.random();\n\t\tconst payload: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.RetrieveSessionInfo,\n\t\t\tshardId,\n\t\t\tnonce,\n\t\t};\n\t\t// eslint-disable-next-line no-promise-executor-return\n\t\tconst promise = new Promise<SessionInfo | null>((resolve) => this.sessionPromises.set(nonce, resolve));\n\t\tparentPort!.postMessage(payload);\n\t\treturn promise;\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\tconst payload: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.UpdateSessionInfo,\n\t\t\tshardId,\n\t\t\tsession: sessionInfo,\n\t\t};\n\t\tparentPort!.postMessage(payload);\n\t}\n\n\tpublic async waitForIdentify(shardId: number, signal: AbortSignal): Promise<void> {\n\t\tconst nonce = Math.random();\n\n\t\tconst payload: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.WaitForIdentify,\n\t\t\tnonce,\n\t\t\tshardId,\n\t\t};\n\t\tconst promise = new Promise<void>((resolve, reject) =>\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tthis.waitForIdentifyPromises.set(nonce, { resolve, reject }),\n\t\t);\n\n\t\tparentPort!.postMessage(payload);\n\n\t\tconst listener = () => {\n\t\t\tconst payload: WorkerReceivePayload = {\n\t\t\t\top: WorkerReceivePayloadOp.CancelIdentify,\n\t\t\t\tnonce,\n\t\t\t};\n\n\t\t\tparentPort!.postMessage(payload);\n\t\t};\n\n\t\t(signal as unknown as PolyFillAbortSignal).addEventListener('abort', listener);\n\n\t\ttry {\n\t\t\tawait promise;\n\t\t} finally {\n\t\t\t(signal as unknown as PolyFillAbortSignal).removeEventListener('abort', listener);\n\t\t}\n\t}\n}\n","import { once } from 'node:events';\nimport { join, isAbsolute, resolve } from 'node:path';\nimport { Worker } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport type { IIdentifyThrottler } from '../../throttling/IIdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager.js';\nimport type {\n\tWebSocketShardDestroyOptions,\n\tWebSocketShardEvents,\n\tWebSocketShardStatus,\n} from '../../ws/WebSocketShard.js';\nimport { managerToFetchingStrategyOptions, type FetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\nexport interface WorkerData extends FetchingStrategyOptions {\n\tshardIds: number[];\n}\n\nexport enum WorkerSendPayloadOp {\n\tConnect,\n\tDestroy,\n\tSend,\n\tSessionInfoResponse,\n\tShardIdentifyResponse,\n\tFetchStatus,\n}\n\nexport type WorkerSendPayload =\n\t| { nonce: number; ok: boolean; op: WorkerSendPayloadOp.ShardIdentifyResponse }\n\t| { nonce: number; op: WorkerSendPayloadOp.FetchStatus; shardId: number }\n\t| { nonce: number; op: WorkerSendPayloadOp.SessionInfoResponse; session: SessionInfo | null }\n\t| { op: WorkerSendPayloadOp.Connect; shardId: number }\n\t| { op: WorkerSendPayloadOp.Destroy; options?: WebSocketShardDestroyOptions; shardId: number }\n\t| { op: WorkerSendPayloadOp.Send; payload: GatewaySendPayload; shardId: number };\n\nexport enum WorkerReceivePayloadOp {\n\tConnected,\n\tDestroyed,\n\tEvent,\n\tRetrieveSessionInfo,\n\tUpdateSessionInfo,\n\tWaitForIdentify,\n\tFetchStatusResponse,\n\tWorkerReady,\n\tCancelIdentify,\n}\n\nexport type WorkerReceivePayload =\n\t// Can't seem to get a type-safe union based off of the event, so I'm sadly leaving data as any for now\n\t| { data: any; event: WebSocketShardEvents; op: WorkerReceivePayloadOp.Event; shardId: number }\n\t| { nonce: number; op: WorkerReceivePayloadOp.CancelIdentify }\n\t| { nonce: number; op: WorkerReceivePayloadOp.FetchStatusResponse; status: WebSocketShardStatus }\n\t| { nonce: number; op: WorkerReceivePayloadOp.RetrieveSessionInfo; shardId: number }\n\t| { nonce: number; op: WorkerReceivePayloadOp.WaitForIdentify; shardId: number }\n\t| { op: WorkerReceivePayloadOp.Connected; shardId: number }\n\t| { op: WorkerReceivePayloadOp.Destroyed; shardId: number }\n\t| { op: WorkerReceivePayloadOp.UpdateSessionInfo; session: SessionInfo | null; shardId: number }\n\t| { op: WorkerReceivePayloadOp.WorkerReady };\n\n/**\n * Options for a {@link WorkerShardingStrategy}\n */\nexport interface WorkerShardingStrategyOptions {\n\t/**\n\t * Dictates how many shards should be spawned per worker thread.\n\t */\n\tshardsPerWorker: number | 'all';\n\t/**\n\t * Path to the worker file to use. The worker requires quite a bit of setup, it is recommended you leverage the {@link WorkerBootstrapper} class.\n\t */\n\tworkerPath?: string;\n}\n\n/**\n * Strategy used to spawn threads in worker_threads\n */\nexport class WorkerShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly options: WorkerShardingStrategyOptions;\n\n\t#workers: Worker[] = [];\n\n\treadonly #workerByShardId = new Collection<number, Worker>();\n\n\tprivate readonly connectPromises = new Collection<number, () => void>();\n\n\tprivate readonly destroyPromises = new Collection<number, () => void>();\n\n\tprivate readonly fetchStatusPromises = new Collection<number, (status: WebSocketShardStatus) => void>();\n\n\tprivate readonly waitForIdentifyControllers = new Collection<number, AbortController>();\n\n\tprivate throttler?: IIdentifyThrottler;\n\n\tpublic constructor(manager: WebSocketManager, options: WorkerShardingStrategyOptions) {\n\t\tthis.manager = manager;\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst shardsPerWorker = this.options.shardsPerWorker === 'all' ? shardIds.length : this.options.shardsPerWorker;\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\n\t\tconst loops = Math.ceil(shardIds.length / shardsPerWorker);\n\t\tconst promises: Promise<void>[] = [];\n\n\t\tfor (let idx = 0; idx < loops; idx++) {\n\t\t\tconst slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);\n\t\t\tconst workerData: WorkerData = {\n\t\t\t\t...strategyOptions,\n\t\t\t\tshardIds: slice,\n\t\t\t};\n\n\t\t\tpromises.push(this.setupWorker(workerData));\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload: WorkerSendPayload = {\n\t\t\t\top: WorkerSendPayloadOp.Connect,\n\t\t\t\tshardId,\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tconst promise = new Promise<void>((resolve) => this.connectPromises.set(shardId, resolve));\n\t\t\tworker.postMessage(payload);\n\t\t\tpromises.push(promise);\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options: Omit<WebSocketShardDestroyOptions, 'recover'> = {}) {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload: WorkerSendPayload = {\n\t\t\t\top: WorkerSendPayloadOp.Destroy,\n\t\t\t\tshardId,\n\t\t\t\toptions,\n\t\t\t};\n\n\t\t\tpromises.push(\n\t\t\t\t// eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then\n\t\t\t\tnew Promise<void>((resolve) => this.destroyPromises.set(shardId, resolve)).then(async () => worker.terminate()),\n\t\t\t);\n\t\t\tworker.postMessage(payload);\n\t\t}\n\n\t\tthis.#workers = [];\n\t\tthis.#workerByShardId.clear();\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic send(shardId: number, data: GatewaySendPayload) {\n\t\tconst worker = this.#workerByShardId.get(shardId);\n\t\tif (!worker) {\n\t\t\tthrow new Error(`No worker found for shard ${shardId}`);\n\t\t}\n\n\t\tconst payload: WorkerSendPayload = {\n\t\t\top: WorkerSendPayloadOp.Send,\n\t\t\tshardId,\n\t\t\tpayload: data,\n\t\t};\n\t\tworker.postMessage(payload);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.fetchStatus}\n\t */\n\tpublic async fetchStatus() {\n\t\tconst statuses = new Collection<number, WebSocketShardStatus>();\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst nonce = Math.random();\n\t\t\tconst payload: WorkerSendPayload = {\n\t\t\t\top: WorkerSendPayloadOp.FetchStatus,\n\t\t\t\tshardId,\n\t\t\t\tnonce,\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tconst promise = new Promise<WebSocketShardStatus>((resolve) => this.fetchStatusPromises.set(nonce, resolve));\n\t\t\tworker.postMessage(payload);\n\n\t\t\tconst status = await promise;\n\t\t\tstatuses.set(shardId, status);\n\t\t}\n\n\t\treturn statuses;\n\t}\n\n\tprivate async setupWorker(workerData: WorkerData) {\n\t\tconst worker = new Worker(this.resolveWorkerPath(), { workerData });\n\n\t\tawait once(worker, 'online');\n\t\t// We do this in case the user has any potentially long running code in their worker\n\t\tawait this.waitForWorkerReady(worker);\n\n\t\tworker\n\t\t\t.on('error', (err) => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t\t.on('messageerror', (err) => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t\t.on('message', async (payload: WorkerReceivePayload) => this.onMessage(worker, payload));\n\n\t\tthis.#workers.push(worker);\n\t\tfor (const shardId of workerData.shardIds) {\n\t\t\tthis.#workerByShardId.set(shardId, worker);\n\t\t}\n\t}\n\n\tprivate resolveWorkerPath(): string {\n\t\tconst path = this.options.workerPath;\n\n\t\tif (!path) {\n\t\t\treturn join(__dirname, 'defaultWorker.js');\n\t\t}\n\n\t\tif (isAbsolute(path)) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (/^\\.\\.?[/\\\\]/.test(path)) {\n\t\t\treturn resolve(path);\n\t\t}\n\n\t\ttry {\n\t\t\treturn require.resolve(path);\n\t\t} catch {\n\t\t\treturn resolve(path);\n\t\t}\n\t}\n\n\tprivate async waitForWorkerReady(worker: Worker): Promise<void> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst handler = (payload: WorkerReceivePayload) => {\n\t\t\t\tif (payload.op === WorkerReceivePayloadOp.WorkerReady) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tworker.off('message', handler);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tworker.on('message', handler);\n\t\t});\n\t}\n\n\tprivate async onMessage(worker: Worker, payload: WorkerReceivePayload) {\n\t\tswitch (payload.op) {\n\t\t\tcase WorkerReceivePayloadOp.Connected: {\n\t\t\t\tthis.connectPromises.get(payload.shardId)?.();\n\t\t\t\tthis.connectPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.Destroyed: {\n\t\t\t\tthis.destroyPromises.get(payload.shardId)?.();\n\t\t\t\tthis.destroyPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.Event: {\n\t\t\t\tthis.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.RetrieveSessionInfo: {\n\t\t\t\tconst session = await this.manager.options.retrieveSessionInfo(payload.shardId);\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.SessionInfoResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tsession,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.UpdateSessionInfo: {\n\t\t\t\tawait this.manager.options.updateSessionInfo(payload.shardId, payload.session);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.WaitForIdentify: {\n\t\t\t\tconst throttler = await this.ensureThrottler();\n\n\t\t\t\t// If this rejects it means we aborted, in which case we reply elsewhere.\n\t\t\t\ttry {\n\t\t\t\t\tconst controller = new AbortController();\n\t\t\t\t\tthis.waitForIdentifyControllers.set(payload.nonce, controller);\n\t\t\t\t\tawait throttler.waitForIdentify(payload.shardId, controller.signal);\n\t\t\t\t} catch {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.ShardIdentifyResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tok: true,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.FetchStatusResponse: {\n\t\t\t\tthis.fetchStatusPromises.get(payload.nonce)?.(payload.status);\n\t\t\t\tthis.fetchStatusPromises.delete(payload.nonce);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.WorkerReady: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.CancelIdentify: {\n\t\t\t\tthis.waitForIdentifyControllers.get(payload.nonce)?.abort();\n\t\t\t\tthis.waitForIdentifyControllers.delete(payload.nonce);\n\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.ShardIdentifyResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tok: false,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async ensureThrottler(): Promise<IIdentifyThrottler> {\n\t\tthis.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);\n\t\treturn this.throttler;\n\t}\n}\n","import { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport type { WebSocketManager } from '../../ws/WebSocketManager.js';\nimport { WebSocketShard, WebSocketShardEvents, type WebSocketShardDestroyOptions } from '../../ws/WebSocketShard.js';\nimport { managerToFetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport { SimpleContextFetchingStrategy } from '../context/SimpleContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\n/**\n * Simple strategy that just spawns shards in the current process\n */\nexport class SimpleShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly shards = new Collection<number, WebSocketShard>();\n\n\tpublic constructor(manager: WebSocketManager) {\n\t\tthis.manager = manager;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\n\t\tfor (const shardId of shardIds) {\n\t\t\tconst strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);\n\t\t\tconst shard = new WebSocketShard(strategy, shardId);\n\t\t\tfor (const event of Object.values(WebSocketShardEvents)) {\n\t\t\t\t// @ts-expect-error: Intentional\n\t\t\t\tshard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));\n\t\t\t}\n\n\t\t\tthis.shards.set(shardId, shard);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const shard of this.shards.values()) {\n\t\t\tpromises.push(shard.connect());\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options?: Omit<WebSocketShardDestroyOptions, 'recover'>) {\n\t\tconst promises = [];\n\n\t\tfor (const shard of this.shards.values()) {\n\t\t\tpromises.push(shard.destroy(options));\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t\tthis.shards.clear();\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic async send(shardId: number, payload: GatewaySendPayload) {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) {\n\t\t\tthrow new RangeError(`Shard ${shardId} not found`);\n\t\t}\n\n\t\treturn shard.send(payload);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.fetchStatus}\n\t */\n\tpublic async fetchStatus() {\n\t\treturn this.shards.mapValues((shard) => shard.status);\n\t}\n}\n","/* eslint-disable id-length */\nimport { Buffer } from 'node:buffer';\nimport { once } from 'node:events';\nimport { clearInterval, clearTimeout, setInterval, setTimeout } from 'node:timers';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport { URLSearchParams } from 'node:url';\nimport { TextDecoder } from 'node:util';\nimport { inflate } from 'node:zlib';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tGatewayCloseCodes,\n\tGatewayDispatchEvents,\n\tGatewayOpcodes,\n\ttype GatewayDispatchPayload,\n\ttype GatewayIdentifyData,\n\ttype GatewayReadyDispatchData,\n\ttype GatewayReceivePayload,\n\ttype GatewaySendPayload,\n} from 'discord-api-types/v10';\nimport { WebSocket, type RawData } from 'ws';\nimport type { Inflate } from 'zlib-sync';\nimport type { IContextFetchingStrategy } from '../strategies/context/IContextFetchingStrategy.js';\nimport { ImportantGatewayOpcodes, getInitialSendRateLimitState } from '../utils/constants.js';\nimport type { SessionInfo } from './WebSocketManager.js';\n\n// eslint-disable-next-line promise/prefer-await-to-then\nconst getZlibSync = lazy(async () => import('zlib-sync').then((mod) => mod.default).catch(() => null));\n\nexport enum WebSocketShardEvents {\n\tClosed = 'closed',\n\tDebug = 'debug',\n\tDispatch = 'dispatch',\n\tError = 'error',\n\tHeartbeatComplete = 'heartbeat',\n\tHello = 'hello',\n\tReady = 'ready',\n\tResumed = 'resumed',\n}\n\nexport enum WebSocketShardStatus {\n\tIdle,\n\tConnecting,\n\tResuming,\n\tReady,\n}\n\nexport enum WebSocketShardDestroyRecovery {\n\tReconnect,\n\tResume,\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport type WebSocketShardEventsMap = {\n\t[WebSocketShardEvents.Closed]: [{ code: number }];\n\t[WebSocketShardEvents.Debug]: [payload: { message: string }];\n\t[WebSocketShardEvents.Dispatch]: [payload: { data: GatewayDispatchPayload }];\n\t[WebSocketShardEvents.Error]: [payload: { error: Error }];\n\t[WebSocketShardEvents.Hello]: [];\n\t[WebSocketShardEvents.Ready]: [payload: { data: GatewayReadyDispatchData }];\n\t[WebSocketShardEvents.Resumed]: [];\n\t[WebSocketShardEvents.HeartbeatComplete]: [payload: { ackAt: number; heartbeatAt: number; latency: number }];\n};\n\nexport interface WebSocketShardDestroyOptions {\n\tcode?: number;\n\treason?: string;\n\trecover?: WebSocketShardDestroyRecovery;\n}\n\nexport enum CloseCodes {\n\tNormal = 1_000,\n\tResuming = 4_200,\n}\n\nexport interface SendRateLimitState {\n\tremaining: number;\n\tresetAt: number;\n}\n\nexport class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap> {\n\tprivate connection: WebSocket | null = null;\n\n\tprivate useIdentifyCompress = false;\n\n\tprivate inflate: Inflate | null = null;\n\n\tprivate readonly textDecoder = new TextDecoder();\n\n\tprivate replayedEvents = 0;\n\n\tprivate isAck = true;\n\n\tprivate sendRateLimitState: SendRateLimitState = getInitialSendRateLimitState();\n\n\tprivate initialHeartbeatTimeoutController: AbortController | null = null;\n\n\tprivate heartbeatInterval: NodeJS.Timer | null = null;\n\n\tprivate lastHeartbeatAt = -1;\n\n\t// Indicates whether the shard has already resolved its original connect() call\n\tprivate initialConnectResolved = false;\n\n\t// Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)\n\tprivate failedToConnectDueToNetworkError = false;\n\n\tprivate readonly sendQueue = new AsyncQueue();\n\n\tprivate readonly timeoutAbortControllers = new Collection<WebSocketShardEvents, AbortController>();\n\n\tprivate readonly strategy: IContextFetchingStrategy;\n\n\tpublic readonly id: number;\n\n\t#status: WebSocketShardStatus = WebSocketShardStatus.Idle;\n\n\tpublic get status(): WebSocketShardStatus {\n\t\treturn this.#status;\n\t}\n\n\tpublic constructor(strategy: IContextFetchingStrategy, id: number) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t\tthis.id = id;\n\t}\n\n\tpublic async connect() {\n\t\tconst promise = this.initialConnectResolved ? Promise.resolve() : once(this, WebSocketShardEvents.Ready);\n\t\tvoid this.internalConnect();\n\n\t\tawait promise;\n\t\tthis.initialConnectResolved = true;\n\t}\n\n\tprivate async internalConnect() {\n\t\tif (this.#status !== WebSocketShardStatus.Idle) {\n\t\t\tthrow new Error(\"Tried to connect a shard that wasn't idle\");\n\t\t}\n\n\t\tconst { version, encoding, compression } = this.strategy.options;\n\t\tconst params = new URLSearchParams({ v: version, encoding });\n\t\tif (compression) {\n\t\t\tconst zlib = await getZlibSync();\n\t\t\tif (zlib) {\n\t\t\t\tparams.append('compress', compression);\n\t\t\t\tthis.inflate = new zlib.Inflate({\n\t\t\t\t\tchunkSize: 65_535,\n\t\t\t\t\tto: 'string',\n\t\t\t\t});\n\t\t\t} else if (!this.useIdentifyCompress) {\n\t\t\t\tthis.useIdentifyCompress = true;\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\n\t\tconst url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;\n\t\tthis.debug([`Connecting to ${url}`]);\n\t\tconst connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined })\n\t\t\t.on('message', this.onMessage.bind(this))\n\t\t\t.on('error', this.onError.bind(this))\n\t\t\t.on('close', this.onClose.bind(this));\n\n\t\tconnection.binaryType = 'arraybuffer';\n\t\tthis.connection = connection;\n\n\t\tthis.#status = WebSocketShardStatus.Connecting;\n\n\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\n\t\tconst { ok } = await this.waitForEvent(WebSocketShardEvents.Hello, this.strategy.options.helloTimeout);\n\t\tif (!ok) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (session?.shardCount === this.strategy.options.shardCount) {\n\t\t\tawait this.resume(session);\n\t\t} else {\n\t\t\tawait this.identify();\n\t\t}\n\t}\n\n\tpublic async destroy(options: WebSocketShardDestroyOptions = {}) {\n\t\tif (this.#status === WebSocketShardStatus.Idle) {\n\t\t\tthis.debug(['Tried to destroy a shard that was idle']);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.code) {\n\t\t\toptions.code = options.recover === WebSocketShardDestroyRecovery.Resume ? CloseCodes.Resuming : CloseCodes.Normal;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Destroying shard',\n\t\t\t`Reason: ${options.reason ?? 'none'}`,\n\t\t\t`Code: ${options.code}`,\n\t\t\t`Recover: ${options.recover === undefined ? 'none' : WebSocketShardDestroyRecovery[options.recover]!}`,\n\t\t]);\n\n\t\t// Reset state\n\t\tthis.isAck = true;\n\t\tif (this.heartbeatInterval) {\n\t\t\tclearInterval(this.heartbeatInterval);\n\t\t}\n\n\t\tif (this.initialHeartbeatTimeoutController) {\n\t\t\tthis.initialHeartbeatTimeoutController.abort();\n\t\t\tthis.initialHeartbeatTimeoutController = null;\n\t\t}\n\n\t\tthis.lastHeartbeatAt = -1;\n\n\t\tfor (const controller of this.timeoutAbortControllers.values()) {\n\t\t\tcontroller.abort();\n\t\t}\n\n\t\tthis.timeoutAbortControllers.clear();\n\n\t\tthis.failedToConnectDueToNetworkError = false;\n\n\t\t// Clear session state if applicable\n\t\tif (options.recover !== WebSocketShardDestroyRecovery.Resume) {\n\t\t\tawait this.strategy.updateSessionInfo(this.id, null);\n\t\t}\n\n\t\tif (this.connection) {\n\t\t\t// No longer need to listen to messages\n\t\t\tthis.connection.removeAllListeners('message');\n\t\t\t// Prevent a reconnection loop by unbinding the main close event\n\t\t\tthis.connection.removeAllListeners('close');\n\n\t\t\tconst shouldClose = this.connection.readyState === WebSocket.OPEN;\n\n\t\t\tthis.debug([\n\t\t\t\t'Connection status during destroy',\n\t\t\t\t`Needs closing: ${shouldClose}`,\n\t\t\t\t`Ready state: ${this.connection.readyState}`,\n\t\t\t]);\n\n\t\t\tif (shouldClose) {\n\t\t\t\tthis.connection.close(options.code, options.reason);\n\t\t\t\tawait once(this.connection, 'close');\n\t\t\t\tthis.emit(WebSocketShardEvents.Closed, { code: options.code });\n\t\t\t}\n\n\t\t\t// Lastly, remove the error event.\n\t\t\t// Doing this earlier would cause a hard crash in case an error event fired on our `close` call\n\t\t\tthis.connection.removeAllListeners('error');\n\t\t} else {\n\t\t\tthis.debug(['Destroying a shard that has no connection; please open an issue on GitHub']);\n\t\t}\n\n\t\tthis.#status = WebSocketShardStatus.Idle;\n\n\t\tif (options.recover !== undefined) {\n\t\t\t// There's cases (like no internet connection) where we immediately fail to connect,\n\t\t\t// causing a very fast and draining reconnection loop.\n\t\t\tawait sleep(500);\n\t\t\treturn this.internalConnect();\n\t\t}\n\t}\n\n\tprivate async waitForEvent(event: WebSocketShardEvents, timeoutDuration?: number | null): Promise<{ ok: boolean }> {\n\t\tthis.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : 'indefinitely'}`]);\n\t\tconst timeoutController = new AbortController();\n\t\tconst timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration).unref() : null;\n\n\t\tthis.timeoutAbortControllers.set(event, timeoutController);\n\n\t\tconst closeController = new AbortController();\n\n\t\ttry {\n\t\t\t// If the first promise resolves, all is well. If the 2nd promise resolves,\n\t\t\t// the shard has meanwhile closed. In that case, a destroy is already ongoing, so we just need to\n\t\t\t// return false. Meanwhile, if something rejects (error event) or the first controller is aborted,\n\t\t\t// we enter the catch block and trigger a destroy there.\n\t\t\tconst closed = await Promise.race<boolean>([\n\t\t\t\tonce(this, event, { signal: timeoutController.signal }).then(() => false),\n\t\t\t\tonce(this, WebSocketShardEvents.Closed, { signal: closeController.signal }).then(() => true),\n\t\t\t]);\n\n\t\t\treturn { ok: !closed };\n\t\t} catch {\n\t\t\t// If we're here because of other reasons, we need to destroy the shard\n\t\t\tvoid this.destroy({\n\t\t\t\tcode: CloseCodes.Normal,\n\t\t\t\treason: 'Something timed out or went wrong while waiting for an event',\n\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t});\n\n\t\t\treturn { ok: false };\n\t\t} finally {\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\n\t\t\tthis.timeoutAbortControllers.delete(event);\n\n\t\t\t// Clean up the close listener to not leak memory\n\t\t\tif (!closeController.signal.aborted) {\n\t\t\t\tcloseController.abort();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async send(payload: GatewaySendPayload): Promise<void> {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"WebSocketShard wasn't connected\");\n\t\t}\n\n\t\tif (this.#status !== WebSocketShardStatus.Ready && !ImportantGatewayOpcodes.has(payload.op)) {\n\t\t\tthis.debug(['Tried to send a non-crucial payload before the shard was ready, waiting']);\n\t\t\t// This will throw if the shard throws an error event in the meantime, just requeue the payload\n\t\t\ttry {\n\t\t\t\tawait once(this, WebSocketShardEvents.Ready);\n\t\t\t} catch {\n\t\t\t\treturn this.send(payload);\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendQueue.wait();\n\n\t\tif (--this.sendRateLimitState.remaining <= 0) {\n\t\t\tconst now = Date.now();\n\n\t\t\tif (this.sendRateLimitState.resetAt > now) {\n\t\t\t\tconst sleepFor = this.sendRateLimitState.resetAt - now;\n\n\t\t\t\tthis.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);\n\t\t\t\tconst controller = new AbortController();\n\n\t\t\t\t// Sleep for the remaining time, but if the connection closes in the meantime, we shouldn't wait the remainder to avoid blocking the new conn\n\t\t\t\tconst interrupted = await Promise.race([\n\t\t\t\t\tsleep(sleepFor).then(() => false),\n\t\t\t\t\tonce(this, WebSocketShardEvents.Closed, { signal: controller.signal }).then(() => true),\n\t\t\t\t]);\n\n\t\t\t\tif (interrupted) {\n\t\t\t\t\tthis.debug(['Connection closed while waiting for the send rate limit to reset, re-queueing payload']);\n\t\t\t\t\tthis.sendQueue.shift();\n\t\t\t\t\treturn this.send(payload);\n\t\t\t\t}\n\n\t\t\t\t// This is so the listener from the `once` call is removed\n\t\t\t\tcontroller.abort();\n\t\t\t}\n\n\t\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\t\t}\n\n\t\tthis.sendQueue.shift();\n\t\tthis.connection.send(JSON.stringify(payload));\n\t}\n\n\tprivate async identify() {\n\t\tthis.debug(['Waiting for identify throttle']);\n\n\t\tconst controller = new AbortController();\n\t\tconst closeHandler = () => {\n\t\t\tcontroller.abort();\n\t\t};\n\n\t\tthis.on(WebSocketShardEvents.Closed, closeHandler);\n\n\t\ttry {\n\t\t\tawait this.strategy.waitForIdentify(this.id, controller.signal);\n\t\t} catch {\n\t\t\tthis.debug(['Was waiting for an identify, but the shard closed in the meantime']);\n\t\t\treturn;\n\t\t} finally {\n\t\t\tthis.off(WebSocketShardEvents.Closed, closeHandler);\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Identifying',\n\t\t\t`shard id: ${this.id.toString()}`,\n\t\t\t`shard count: ${this.strategy.options.shardCount}`,\n\t\t\t`intents: ${this.strategy.options.intents}`,\n\t\t\t`compression: ${this.inflate ? 'zlib-stream' : this.useIdentifyCompress ? 'identify' : 'none'}`,\n\t\t]);\n\n\t\tconst d: GatewayIdentifyData = {\n\t\t\ttoken: this.strategy.options.token,\n\t\t\tproperties: this.strategy.options.identifyProperties,\n\t\t\tintents: this.strategy.options.intents,\n\t\t\tcompress: this.useIdentifyCompress,\n\t\t\tshard: [this.id, this.strategy.options.shardCount],\n\t\t};\n\n\t\tif (this.strategy.options.largeThreshold) {\n\t\t\td.large_threshold = this.strategy.options.largeThreshold;\n\t\t}\n\n\t\tif (this.strategy.options.initialPresence) {\n\t\t\td.presence = this.strategy.options.initialPresence;\n\t\t}\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Identify,\n\t\t\td,\n\t\t});\n\n\t\tawait this.waitForEvent(WebSocketShardEvents.Ready, this.strategy.options.readyTimeout);\n\t}\n\n\tprivate async resume(session: SessionInfo) {\n\t\tthis.debug([\n\t\t\t'Resuming session',\n\t\t\t`resume url: ${session.resumeURL}`,\n\t\t\t`sequence: ${session.sequence}`,\n\t\t\t`shard id: ${this.id.toString()}`,\n\t\t]);\n\n\t\tthis.#status = WebSocketShardStatus.Resuming;\n\t\tthis.replayedEvents = 0;\n\t\treturn this.send({\n\t\t\top: GatewayOpcodes.Resume,\n\t\t\td: {\n\t\t\t\ttoken: this.strategy.options.token,\n\t\t\t\tseq: session.sequence,\n\t\t\t\tsession_id: session.sessionId,\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate async heartbeat(requested = false) {\n\t\tif (!this.isAck && !requested) {\n\t\t\treturn this.destroy({ reason: 'Zombie connection', recover: WebSocketShardDestroyRecovery.Resume });\n\t\t}\n\n\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Heartbeat,\n\t\t\td: session?.sequence ?? null,\n\t\t});\n\n\t\tthis.lastHeartbeatAt = Date.now();\n\t\tthis.isAck = false;\n\t}\n\n\tprivate async unpackMessage(data: ArrayBuffer | Buffer, isBinary: boolean): Promise<GatewayReceivePayload | null> {\n\t\tconst decompressable = new Uint8Array(data);\n\n\t\t// Deal with no compression\n\t\tif (!isBinary) {\n\t\t\treturn JSON.parse(this.textDecoder.decode(decompressable)) as GatewayReceivePayload;\n\t\t}\n\n\t\t// Deal with identify compress\n\t\tif (this.useIdentifyCompress) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tinflate(decompressable, { chunkSize: 65_535 }, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(JSON.parse(this.textDecoder.decode(result)) as GatewayReceivePayload);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Deal with gw wide zlib-stream compression\n\t\tif (this.inflate) {\n\t\t\tconst l = decompressable.length;\n\t\t\tconst flush =\n\t\t\t\tl >= 4 &&\n\t\t\t\tdecompressable[l - 4] === 0x00 &&\n\t\t\t\tdecompressable[l - 3] === 0x00 &&\n\t\t\t\tdecompressable[l - 2] === 0xff &&\n\t\t\t\tdecompressable[l - 1] === 0xff;\n\n\t\t\tconst zlib = (await getZlibSync())!;\n\t\t\tthis.inflate.push(Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);\n\n\t\t\tif (this.inflate.err) {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ''}`),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!flush) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst { result } = this.inflate;\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn JSON.parse(typeof result === 'string' ? result : this.textDecoder.decode(result)) as GatewayReceivePayload;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Received a message we were unable to decompress',\n\t\t\t`isBinary: ${isBinary.toString()}`,\n\t\t\t`useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,\n\t\t\t`inflate: ${Boolean(this.inflate).toString()}`,\n\t\t]);\n\n\t\treturn null;\n\t}\n\n\tprivate async onMessage(data: RawData, isBinary: boolean) {\n\t\tconst payload = await this.unpackMessage(data as ArrayBuffer | Buffer, isBinary);\n\t\tif (!payload) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (payload.op) {\n\t\t\tcase GatewayOpcodes.Dispatch: {\n\t\t\t\tif (this.#status === WebSocketShardStatus.Resuming) {\n\t\t\t\t\tthis.replayedEvents++;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line sonarjs/no-nested-switch\n\t\t\t\tswitch (payload.t) {\n\t\t\t\t\tcase GatewayDispatchEvents.Ready: {\n\t\t\t\t\t\tthis.#status = WebSocketShardStatus.Ready;\n\n\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\tsequence: payload.s,\n\t\t\t\t\t\t\tsessionId: payload.d.session_id,\n\t\t\t\t\t\t\tshardId: this.id,\n\t\t\t\t\t\t\tshardCount: this.strategy.options.shardCount,\n\t\t\t\t\t\t\tresumeURL: payload.d.resume_gateway_url,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, session);\n\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Ready, { data: payload.d });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase GatewayDispatchEvents.Resumed: {\n\t\t\t\t\t\tthis.#status = WebSocketShardStatus.Ready;\n\t\t\t\t\t\tthis.debug([`Resumed and replayed ${this.replayedEvents} events`]);\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Resumed);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\t\t\t\tif (session) {\n\t\t\t\t\tif (payload.s > session.sequence) {\n\t\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.debug([\n\t\t\t\t\t\t`Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`,\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tthis.emit(WebSocketShardEvents.Dispatch, { data: payload });\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Heartbeat: {\n\t\t\t\tawait this.heartbeat(true);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Reconnect: {\n\t\t\t\tawait this.destroy({\n\t\t\t\t\treason: 'Told to reconnect by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Resume,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.InvalidSession: {\n\t\t\t\tthis.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);\n\t\t\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\t\t\t\tif (payload.d && session) {\n\t\t\t\t\tawait this.resume(session);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.destroy({\n\t\t\t\t\t\treason: 'Invalid session',\n\t\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Hello: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Hello);\n\t\t\t\tconst jitter = Math.random();\n\t\t\t\tconst firstWait = Math.floor(payload.d.heartbeat_interval * jitter);\n\t\t\t\tthis.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst controller = new AbortController();\n\t\t\t\t\tthis.initialHeartbeatTimeoutController = controller;\n\t\t\t\t\tawait sleep(firstWait, undefined, { signal: controller.signal });\n\t\t\t\t} catch {\n\t\t\t\t\tthis.debug(['Cancelled initial heartbeat due to #destroy being called']);\n\t\t\t\t\treturn;\n\t\t\t\t} finally {\n\t\t\t\t\tthis.initialHeartbeatTimeoutController = null;\n\t\t\t\t}\n\n\t\t\t\tawait this.heartbeat();\n\n\t\t\t\tthis.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);\n\t\t\t\tthis.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.HeartbeatAck: {\n\t\t\t\tthis.isAck = true;\n\n\t\t\t\tconst ackAt = Date.now();\n\t\t\t\tthis.emit(WebSocketShardEvents.HeartbeatComplete, {\n\t\t\t\t\tackAt,\n\t\t\t\t\theartbeatAt: this.lastHeartbeatAt,\n\t\t\t\t\tlatency: ackAt - this.lastHeartbeatAt,\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onError(error: Error) {\n\t\tif ('code' in error && ['ECONNRESET', 'ECONNREFUSED'].includes(error.code as string)) {\n\t\t\tthis.debug(['Failed to connect to the gateway URL specified due to a network error']);\n\t\t\tthis.failedToConnectDueToNetworkError = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.emit(WebSocketShardEvents.Error, { error });\n\t}\n\n\tprivate async onClose(code: number) {\n\t\tthis.emit(WebSocketShardEvents.Closed, { code });\n\n\t\tswitch (code) {\n\t\t\tcase CloseCodes.Normal: {\n\t\t\t\treturn this.destroy({\n\t\t\t\t\tcode,\n\t\t\t\t\treason: 'Got disconnected by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcase CloseCodes.Resuming: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownError: {\n\t\t\t\tthis.debug([`An unknown error occurred: ${code}`]);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownOpcode: {\n\t\t\t\tthis.debug(['An invalid opcode was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DecodeError: {\n\t\t\t\tthis.debug(['An invalid payload was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.NotAuthenticated: {\n\t\t\t\tthis.debug(['A request was somehow sent before the identify/resume payload.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AuthenticationFailed: {\n\t\t\t\tthrow new Error('Authentication failed');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AlreadyAuthenticated: {\n\t\t\t\tthis.debug(['More than one auth payload was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidSeq: {\n\t\t\t\tthis.debug(['An invalid sequence was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.RateLimited: {\n\t\t\t\tthis.debug(['The WebSocket rate limit has been hit, this should never happen']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.SessionTimedOut: {\n\t\t\t\tthis.debug(['Session timed out.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidShard: {\n\t\t\t\tthrow new Error('Invalid shard');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.ShardingRequired: {\n\t\t\t\tthrow new Error('Sharding is required');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidAPIVersion: {\n\t\t\t\tthrow new Error('Used an invalid API version');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidIntents: {\n\t\t\t\tthrow new Error('Used invalid intents');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DisallowedIntents: {\n\t\t\t\tthrow new Error('Used disallowed intents');\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tthis.debug([\n\t\t\t\t\t`The gateway closed with an unexpected code ${code}, attempting to ${\n\t\t\t\t\t\tthis.failedToConnectDueToNetworkError ? 'reconnect' : 'resume'\n\t\t\t\t\t}.`,\n\t\t\t\t]);\n\t\t\t\treturn this.destroy({\n\t\t\t\t\tcode,\n\t\t\t\t\trecover: this.failedToConnectDueToNetworkError\n\t\t\t\t\t\t? WebSocketShardDestroyRecovery.Reconnect\n\t\t\t\t\t\t: WebSocketShardDestroyRecovery.Resume,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate debug(messages: [string, ...string[]]) {\n\t\tconst message = `${messages[0]}${\n\t\t\tmessages.length > 1\n\t\t\t\t? `\\n${messages\n\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t.map((m) => `\t${m}`)\n\t\t\t\t\t\t.join('\\n')}`\n\t\t\t\t: ''\n\t\t}`;\n\n\t\tthis.emit(WebSocketShardEvents.Debug, { message });\n\t}\n}\n","import process from 'node:process';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { APIVersion, GatewayOpcodes } from 'discord-api-types/v10';\nimport { SimpleShardingStrategy } from '../strategies/sharding/SimpleShardingStrategy.js';\nimport { SimpleIdentifyThrottler } from '../throttling/SimpleIdentifyThrottler.js';\nimport type { SessionInfo, OptionalWebSocketManagerOptions, WebSocketManager } from '../ws/WebSocketManager.js';\nimport type { SendRateLimitState } from '../ws/WebSocketShard.js';\n\n/**\n * Valid encoding types\n */\nexport enum Encoding {\n\tJSON = 'json',\n}\n\n/**\n * Valid compression methods\n */\nexport enum CompressionMethod {\n\tZlibStream = 'zlib-stream',\n}\n\nexport const DefaultDeviceProperty = `@discordjs/ws 0.8.3` as `@discordjs/ws ${string}`;\n\nconst getDefaultSessionStore = lazy(() => new Collection<number, SessionInfo | null>());\n\n/**\n * Default options used by the manager\n */\nexport const DefaultWebSocketManagerOptions = {\n\tasync buildIdentifyThrottler(manager: WebSocketManager) {\n\t\tconst info = await manager.fetchGatewayInformation();\n\t\treturn new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);\n\t},\n\tbuildStrategy: (manager) => new SimpleShardingStrategy(manager),\n\tshardCount: null,\n\tshardIds: null,\n\tlargeThreshold: null,\n\tinitialPresence: null,\n\tidentifyProperties: {\n\t\tbrowser: DefaultDeviceProperty,\n\t\tdevice: DefaultDeviceProperty,\n\t\tos: process.platform,\n\t},\n\tversion: APIVersion,\n\tencoding: Encoding.JSON,\n\tcompression: null,\n\tretrieveSessionInfo(shardId) {\n\t\tconst store = getDefaultSessionStore();\n\t\treturn store.get(shardId) ?? null;\n\t},\n\tupdateSessionInfo(shardId: number, info: SessionInfo | null) {\n\t\tconst store = getDefaultSessionStore();\n\t\tif (info) {\n\t\t\tstore.set(shardId, info);\n\t\t} else {\n\t\t\tstore.delete(shardId);\n\t\t}\n\t},\n\thandshakeTimeout: 30_000,\n\thelloTimeout: 60_000,\n\treadyTimeout: 15_000,\n} as const satisfies OptionalWebSocketManagerOptions;\n\nexport const ImportantGatewayOpcodes = new Set([\n\tGatewayOpcodes.Heartbeat,\n\tGatewayOpcodes.Identify,\n\tGatewayOpcodes.Resume,\n]);\n\nexport function getInitialSendRateLimitState(): SendRateLimitState {\n\treturn {\n\t\tremaining: 120,\n\t\tresetAt: Date.now() + 60_000,\n\t};\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport { Collection } from '@discordjs/collection';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport type { IIdentifyThrottler } from './IIdentifyThrottler.js';\n\n/**\n * The state of a rate limit key's identify queue.\n */\nexport interface IdentifyState {\n\tqueue: AsyncQueue;\n\tresetsAt: number;\n}\n\n/**\n * Local, in-memory identify throttler.\n */\nexport class SimpleIdentifyThrottler implements IIdentifyThrottler {\n\tprivate readonly states = new Collection<number, IdentifyState>();\n\n\tpublic constructor(private readonly maxConcurrency: number) {}\n\n\t/**\n\t * {@inheritDoc IIdentifyThrottler.waitForIdentify}\n\t */\n\tpublic async waitForIdentify(shardId: number, signal: AbortSignal): Promise<void> {\n\t\tconst key = shardId % this.maxConcurrency;\n\n\t\tconst state = this.states.ensure(key, () => {\n\t\t\treturn {\n\t\t\t\tqueue: new AsyncQueue(),\n\t\t\t\tresetsAt: Number.POSITIVE_INFINITY,\n\t\t\t};\n\t\t});\n\n\t\tawait state.queue.wait({ signal });\n\n\t\ttry {\n\t\t\tconst diff = state.resetsAt - Date.now();\n\t\t\tif (diff <= 5_000) {\n\t\t\t\t// To account for the latency the IDENTIFY payload goes through, we add a bit more wait time\n\t\t\t\tconst time = diff + Math.random() * 1_500;\n\t\t\t\tawait sleep(time);\n\t\t\t}\n\n\t\t\tstate.resetsAt = Date.now() + 5_000;\n\t\t} finally {\n\t\t\tstate.queue.shift();\n\t\t}\n\t}\n}\n","import { isMainThread, parentPort, workerData } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { Awaitable } from '@discordjs/util';\nimport { WorkerContextFetchingStrategy } from '../strategies/context/WorkerContextFetchingStrategy.js';\nimport {\n\tWorkerReceivePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerData,\n\ttype WorkerReceivePayload,\n\ttype WorkerSendPayload,\n} from '../strategies/sharding/WorkerShardingStrategy.js';\nimport type { WebSocketShardDestroyOptions } from '../ws/WebSocketShard.js';\nimport { WebSocketShardEvents, WebSocketShard } from '../ws/WebSocketShard.js';\n\n/**\n * Options for bootstrapping the worker\n */\nexport interface BootstrapOptions {\n\t/**\n\t * Shard events to just arbitrarily forward to the parent thread for the manager to emit\n\t * Note: By default, this will include ALL events\n\t * you most likely want to handle dispatch within the worker itself\n\t */\n\tforwardEvents?: WebSocketShardEvents[];\n\t/**\n\t * Function to call when a shard is created for additional setup\n\t */\n\tshardCallback?(shard: WebSocketShard): Awaitable<void>;\n}\n\n/**\n * Utility class for bootstrapping a worker thread to be used for sharding\n */\nexport class WorkerBootstrapper {\n\t/**\n\t * The data passed to the worker thread\n\t */\n\tprotected readonly data = workerData as WorkerData;\n\n\t/**\n\t * The shards that are managed by this worker\n\t */\n\tprotected readonly shards = new Collection<number, WebSocketShard>();\n\n\tpublic constructor() {\n\t\tif (isMainThread) {\n\t\t\tthrow new Error('Expected WorkerBootstrap to not be used within the main thread');\n\t\t}\n\t}\n\n\t/**\n\t * Helper method to initiate a shard's connection process\n\t */\n\tprotected async connect(shardId: number): Promise<void> {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) {\n\t\t\tthrow new RangeError(`Shard ${shardId} does not exist`);\n\t\t}\n\n\t\tawait shard.connect();\n\t}\n\n\t/**\n\t * Helper method to destroy a shard\n\t */\n\tprotected async destroy(shardId: number, options?: WebSocketShardDestroyOptions): Promise<void> {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) {\n\t\t\tthrow new RangeError(`Shard ${shardId} does not exist`);\n\t\t}\n\n\t\tawait shard.destroy(options);\n\t}\n\n\t/**\n\t * Helper method to attach event listeners to the parentPort\n\t */\n\tprotected setupThreadEvents(): void {\n\t\tparentPort!\n\t\t\t.on('messageerror', (err) => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t\t.on('message', async (payload: WorkerSendPayload) => {\n\t\t\t\tswitch (payload.op) {\n\t\t\t\t\tcase WorkerSendPayloadOp.Connect: {\n\t\t\t\t\t\tawait this.connect(payload.shardId);\n\t\t\t\t\t\tconst response: WorkerReceivePayload = {\n\t\t\t\t\t\t\top: WorkerReceivePayloadOp.Connected,\n\t\t\t\t\t\t\tshardId: payload.shardId,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.Destroy: {\n\t\t\t\t\t\tawait this.destroy(payload.shardId, payload.options);\n\t\t\t\t\t\tconst response: WorkerReceivePayload = {\n\t\t\t\t\t\t\top: WorkerReceivePayloadOp.Destroyed,\n\t\t\t\t\t\t\tshardId: payload.shardId,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.Send: {\n\t\t\t\t\t\tconst shard = this.shards.get(payload.shardId);\n\t\t\t\t\t\tif (!shard) {\n\t\t\t\t\t\t\tthrow new RangeError(`Shard ${payload.shardId} does not exist`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tawait shard.send(payload.payload);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.SessionInfoResponse: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.ShardIdentifyResponse: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.FetchStatus: {\n\t\t\t\t\t\tconst shard = this.shards.get(payload.shardId);\n\t\t\t\t\t\tif (!shard) {\n\t\t\t\t\t\t\tthrow new Error(`Shard ${payload.shardId} does not exist`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst response: WorkerReceivePayload = {\n\t\t\t\t\t\t\top: WorkerReceivePayloadOp.FetchStatusResponse,\n\t\t\t\t\t\t\tstatus: shard.status,\n\t\t\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Bootstraps the worker thread with the provided options\n\t */\n\tpublic async bootstrap(options: Readonly<BootstrapOptions> = {}): Promise<void> {\n\t\t// Start by initializing the shards\n\t\tfor (const shardId of this.data.shardIds) {\n\t\t\tconst shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);\n\t\t\tfor (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {\n\t\t\t\t// @ts-expect-error: Event types incompatible\n\t\t\t\tshard.on(event, (data) => {\n\t\t\t\t\tconst payload: WorkerReceivePayload = {\n\t\t\t\t\t\top: WorkerReceivePayloadOp.Event,\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tshardId,\n\t\t\t\t\t};\n\t\t\t\t\tparentPort!.postMessage(payload);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Any additional setup the user might want to do\n\t\t\tawait options.shardCallback?.(shard);\n\t\t\tthis.shards.set(shardId, shard);\n\t\t}\n\n\t\t// Lastly, start listening to messages from the parent thread\n\t\tthis.setupThreadEvents();\n\n\t\tconst message: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.WorkerReady,\n\t\t};\n\t\tparentPort!.postMessage(message);\n\t}\n}\n","import type { REST } from '@discordjs/rest';\nimport { range, type Awaitable } from '@discordjs/util';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tRoutes,\n\ttype APIGatewayBotInfo,\n\ttype GatewayIdentifyProperties,\n\ttype GatewayPresenceUpdateData,\n\ttype RESTGetAPIGatewayBotResult,\n\ttype GatewayIntentBits,\n\ttype GatewaySendPayload,\n} from 'discord-api-types/v10';\nimport type { IShardingStrategy } from '../strategies/sharding/IShardingStrategy.js';\nimport type { IIdentifyThrottler } from '../throttling/IIdentifyThrottler.js';\nimport { DefaultWebSocketManagerOptions, type CompressionMethod, type Encoding } from '../utils/constants.js';\nimport type { WebSocketShardDestroyOptions, WebSocketShardEventsMap } from './WebSocketShard.js';\n\n/**\n * Represents a range of shard ids\n */\nexport interface ShardRange {\n\tend: number;\n\tstart: number;\n}\n\n/**\n * Session information for a given shard, used to resume a session\n */\nexport interface SessionInfo {\n\t/**\n\t * URL to use when resuming\n\t */\n\tresumeURL: string;\n\t/**\n\t * The sequence number of the last message sent by the shard\n\t */\n\tsequence: number;\n\t/**\n\t * Session id for this shard\n\t */\n\tsessionId: string;\n\t/**\n\t * The total number of shards at the time of this shard identifying\n\t */\n\tshardCount: number;\n\t/**\n\t * The id of the shard\n\t */\n\tshardId: number;\n}\n\n/**\n * Required options for the WebSocketManager\n */\nexport interface RequiredWebSocketManagerOptions {\n\t/**\n\t * The intents to request\n\t */\n\tintents: GatewayIntentBits | 0;\n\t/**\n\t * The REST instance to use for fetching gateway information\n\t */\n\trest: REST;\n\t/**\n\t * The token to use for identifying with the gateway\n\t */\n\ttoken: string;\n}\n\n/**\n * Optional additional configuration for the WebSocketManager\n */\nexport interface OptionalWebSocketManagerOptions {\n\t/**\n\t * Builds an identify throttler to use for this manager's shards\n\t */\n\tbuildIdentifyThrottler(manager: WebSocketManager): Awaitable<IIdentifyThrottler>;\n\t/**\n\t * Builds the strategy to use for sharding\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *  token: process.env.DISCORD_TOKEN,\n\t *  intents: 0, // for no intents\n\t *  rest,\n\t *  buildStrategy: (manager) => new WorkerShardingStrategy(manager, { shardsPerWorker: 2 }),\n\t * });\n\t * ```\n\t */\n\tbuildStrategy(manager: WebSocketManager): IShardingStrategy;\n\t/**\n\t * The compression method to use\n\t *\n\t * @defaultValue `null` (no compression)\n\t */\n\tcompression: CompressionMethod | null;\n\t/**\n\t * The encoding to use\n\t *\n\t * @defaultValue `'json'`\n\t */\n\tencoding: Encoding;\n\t/**\n\t * How long to wait for a shard to connect before giving up\n\t */\n\thandshakeTimeout: number | null;\n\t/**\n\t * How long to wait for a shard's HELLO packet before giving up\n\t */\n\thelloTimeout: number | null;\n\t/**\n\t * Properties to send to the gateway when identifying\n\t */\n\tidentifyProperties: GatewayIdentifyProperties;\n\t/**\n\t * Initial presence data to send to the gateway when identifying\n\t */\n\tinitialPresence: GatewayPresenceUpdateData | null;\n\t/**\n\t * Value between 50 and 250, total number of members where the gateway will stop sending offline members in the guild member list\n\t */\n\tlargeThreshold: number | null;\n\t/**\n\t * How long to wait for a shard's READY packet before giving up\n\t */\n\treadyTimeout: number | null;\n\t/**\n\t * Function used to retrieve session information (and attempt to resume) for a given shard\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   async retrieveSessionInfo(shardId): Awaitable<SessionInfo | null> {\n\t *     // Fetch this info from redis or similar\n\t *     return { sessionId: string, sequence: number };\n\t *     // Return null if no information is found\n\t *   },\n\t * });\n\t * ```\n\t */\n\tretrieveSessionInfo(shardId: number): Awaitable<SessionInfo | null>;\n\t/**\n\t * The total number of shards across all WebsocketManagers you intend to instantiate.\n\t * Use `null` to use Discord's recommended shard count\n\t */\n\tshardCount: number | null;\n\t/**\n\t * The ids of the shards this WebSocketManager should manage.\n\t * Use `null` to simply spawn 0 through `shardCount - 1`\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   shardIds: [1, 3, 7], // spawns shard 1, 3, and 7, nothing else\n\t * });\n\t * ```\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   shardIds: {\n\t *     start: 3,\n\t *     end: 6,\n\t *   }, // spawns shards 3, 4, 5, and 6\n\t * });\n\t * ```\n\t */\n\tshardIds: number[] | ShardRange | null;\n\t/**\n\t * Function used to store session information for a given shard\n\t */\n\tupdateSessionInfo(shardId: number, sessionInfo: SessionInfo | null): Awaitable<void>;\n\t/**\n\t * The gateway version to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\nexport type WebSocketManagerOptions = OptionalWebSocketManagerOptions & RequiredWebSocketManagerOptions;\n\nexport type ManagerShardEventsMap = {\n\t[K in keyof WebSocketShardEventsMap]: [\n\t\tWebSocketShardEventsMap[K] extends [] ? { shardId: number } : WebSocketShardEventsMap[K][0] & { shardId: number },\n\t];\n};\n\nexport class WebSocketManager extends AsyncEventEmitter<ManagerShardEventsMap> {\n\t/**\n\t * The options being used by this manager\n\t */\n\tpublic readonly options: WebSocketManagerOptions;\n\n\t/**\n\t * Internal cache for a GET /gateway/bot result\n\t */\n\tprivate gatewayInformation: {\n\t\tdata: APIGatewayBotInfo;\n\t\texpiresAt: number;\n\t} | null = null;\n\n\t/**\n\t * Internal cache for the shard ids\n\t */\n\tprivate shardIds: number[] | null = null;\n\n\t/**\n\t * Strategy used to manage shards\n\t *\n\t * @defaultValue `SimpleShardingStrategy`\n\t */\n\tprivate readonly strategy: IShardingStrategy;\n\n\tpublic constructor(options: Partial<OptionalWebSocketManagerOptions> & RequiredWebSocketManagerOptions) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultWebSocketManagerOptions, ...options };\n\t\tthis.strategy = this.options.buildStrategy(this);\n\t}\n\n\t/**\n\t * Fetches the gateway information from Discord - or returns it from cache if available\n\t *\n\t * @param force - Whether to ignore the cache and force a fresh fetch\n\t */\n\tpublic async fetchGatewayInformation(force = false) {\n\t\tif (this.gatewayInformation) {\n\t\t\tif (this.gatewayInformation.expiresAt <= Date.now()) {\n\t\t\t\tthis.gatewayInformation = null;\n\t\t\t} else if (!force) {\n\t\t\t\treturn this.gatewayInformation.data;\n\t\t\t}\n\t\t}\n\n\t\tconst data = (await this.options.rest.get(Routes.gatewayBot())) as RESTGetAPIGatewayBotResult;\n\n\t\tthis.gatewayInformation = { data, expiresAt: Date.now() + data.session_start_limit.reset_after };\n\t\treturn this.gatewayInformation.data;\n\t}\n\n\t/**\n\t * Updates your total shard count on-the-fly, spawning shards as needed\n\t *\n\t * @param shardCount - The new shard count to use\n\t */\n\tpublic async updateShardCount(shardCount: number | null) {\n\t\tawait this.strategy.destroy({ reason: 'User is adjusting their shards' });\n\t\tthis.options.shardCount = shardCount;\n\n\t\tconst shardIds = await this.getShardIds(true);\n\t\tawait this.strategy.spawn(shardIds);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Yields the total number of shards across for your bot, accounting for Discord recommendations\n\t */\n\tpublic async getShardCount(): Promise<number> {\n\t\tif (this.options.shardCount) {\n\t\t\treturn this.options.shardCount;\n\t\t}\n\n\t\tconst shardIds = await this.getShardIds();\n\t\treturn Math.max(...shardIds) + 1;\n\t}\n\n\t/**\n\t * Yields the ids of the shards this manager should manage\n\t */\n\tpublic async getShardIds(force = false): Promise<number[]> {\n\t\tif (this.shardIds && !force) {\n\t\t\treturn this.shardIds;\n\t\t}\n\n\t\tlet shardIds: number[];\n\t\tif (this.options.shardIds) {\n\t\t\tif (Array.isArray(this.options.shardIds)) {\n\t\t\t\tshardIds = this.options.shardIds;\n\t\t\t} else {\n\t\t\t\tconst { start, end } = this.options.shardIds;\n\t\t\t\tshardIds = [...range({ start, end: end + 1 })];\n\t\t\t}\n\t\t} else {\n\t\t\tconst data = await this.fetchGatewayInformation();\n\t\t\tshardIds = [...range(this.options.shardCount ?? data.shards)];\n\t\t}\n\n\t\tthis.shardIds = shardIds;\n\t\treturn shardIds;\n\t}\n\n\tpublic async connect() {\n\t\tconst shardCount = await this.getShardCount();\n\n\t\tconst data = await this.fetchGatewayInformation();\n\t\tif (data.session_start_limit.remaining < shardCount) {\n\t\t\tthrow new Error(\n\t\t\t\t`Not enough sessions remaining to spawn ${shardCount} shards; only ${\n\t\t\t\t\tdata.session_start_limit.remaining\n\t\t\t\t} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`,\n\t\t\t);\n\t\t}\n\n\t\t// First, make sure all our shards are spawned\n\t\tawait this.updateShardCount(shardCount);\n\t\tawait this.strategy.connect();\n\t}\n\n\tpublic destroy(options?: Omit<WebSocketShardDestroyOptions, 'recover'>) {\n\t\treturn this.strategy.destroy(options);\n\t}\n\n\tpublic send(shardId: number, payload: GatewaySendPayload) {\n\t\treturn this.strategy.send(shardId, payload);\n\t}\n\n\tpublic fetchStatus() {\n\t\treturn this.strategy.fetchStatus();\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}