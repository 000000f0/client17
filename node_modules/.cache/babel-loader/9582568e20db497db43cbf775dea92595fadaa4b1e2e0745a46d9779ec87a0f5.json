{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,\n  ALLOWED_SIZES: () => ALLOWED_SIZES,\n  ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,\n  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,\n  CDN: () => CDN,\n  DefaultRestOptions: () => DefaultRestOptions,\n  DefaultUserAgent: () => DefaultUserAgent,\n  DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,\n  DiscordAPIError: () => DiscordAPIError,\n  HTTPError: () => HTTPError,\n  OverwrittenMimeTypes: () => OverwrittenMimeTypes,\n  REST: () => REST,\n  RESTEvents: () => RESTEvents,\n  RateLimitError: () => RateLimitError,\n  RequestManager: () => RequestManager,\n  RequestMethod: () => RequestMethod,\n  makeURLSearchParams: () => makeURLSearchParams,\n  parseResponse: () => parseResponse,\n  version: () => version\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/lib/CDN.ts\nvar import_node_url = require(\"url\");\n\n// src/lib/utils/constants.ts\nvar import_node_process = __toESM(require(\"process\"));\nvar import_v10 = require(\"discord-api-types/v10\");\nvar import_undici = require(\"undici\");\nvar DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.7.1)`;\nvar DefaultUserAgentAppendix = import_node_process.default.release?.name === \"node\" ? `Node.js/${import_node_process.default.version}` : \"\";\nvar DefaultRestOptions = {\n  get agent() {\n    return new import_undici.Agent({\n      connect: {\n        timeout: 3e4\n      }\n    });\n  },\n  api: \"https://discord.com/api\",\n  authPrefix: \"Bot\",\n  cdn: \"https://cdn.discordapp.com\",\n  headers: {},\n  invalidRequestWarningInterval: 0,\n  globalRequestsPerSecond: 50,\n  offset: 50,\n  rejectOnRateLimit: null,\n  retries: 3,\n  timeout: 15e3,\n  userAgentAppendix: DefaultUserAgentAppendix,\n  version: import_v10.APIVersion,\n  hashSweepInterval: 144e5,\n  // 4 Hours\n  hashLifetime: 864e5,\n  // 24 Hours\n  handlerSweepInterval: 36e5\n  // 1 Hour\n};\n\nvar RESTEvents = /* @__PURE__ */(RESTEvents2 => {\n  RESTEvents2[\"Debug\"] = \"restDebug\";\n  RESTEvents2[\"HandlerSweep\"] = \"handlerSweep\";\n  RESTEvents2[\"HashSweep\"] = \"hashSweep\";\n  RESTEvents2[\"InvalidRequestWarning\"] = \"invalidRequestWarning\";\n  RESTEvents2[\"RateLimited\"] = \"rateLimited\";\n  RESTEvents2[\"Response\"] = \"response\";\n  return RESTEvents2;\n})(RESTEvents || {});\nvar ALLOWED_EXTENSIONS = [\"webp\", \"png\", \"jpg\", \"jpeg\", \"gif\"];\nvar ALLOWED_STICKER_EXTENSIONS = [\"png\", \"json\", \"gif\"];\nvar ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];\nvar OverwrittenMimeTypes = {\n  // https://github.com/discordjs/discord.js/issues/8557\n  \"image/apng\": \"image/png\"\n};\nvar BurstHandlerMajorIdKey = \"burst\";\n\n// src/lib/CDN.ts\nvar CDN = class {\n  constructor() {\n    let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultRestOptions.cdn;\n    this.base = base;\n  }\n  /**\n   * Generates an app asset URL for a client's asset.\n   *\n   * @param clientId - The client id that has the asset\n   * @param assetHash - The hash provided by Discord for this asset\n   * @param options - Optional options for the asset\n   */\n  appAsset(clientId, assetHash, options) {\n    return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n  }\n  /**\n   * Generates an app icon URL for a client's icon.\n   *\n   * @param clientId - The client id that has the icon\n   * @param iconHash - The hash provided by Discord for this icon\n   * @param options - Optional options for the icon\n   */\n  appIcon(clientId, iconHash, options) {\n    return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n  }\n  /**\n   * Generates an avatar URL, e.g. for a user or a webhook.\n   *\n   * @param id - The id that has the icon\n   * @param avatarHash - The hash provided by Discord for this avatar\n   * @param options - Optional options for the avatar\n   */\n  avatar(id, avatarHash, options) {\n    return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n  }\n  /**\n   * Generates a banner URL, e.g. for a user or a guild.\n   *\n   * @param id - The id that has the banner splash\n   * @param bannerHash - The hash provided by Discord for this banner\n   * @param options - Optional options for the banner\n   */\n  banner(id, bannerHash, options) {\n    return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n  }\n  /**\n   * Generates an icon URL for a channel, e.g. a group DM.\n   *\n   * @param channelId - The channel id that has the icon\n   * @param iconHash - The hash provided by Discord for this channel\n   * @param options - Optional options for the icon\n   */\n  channelIcon(channelId, iconHash, options) {\n    return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n  }\n  /**\n   * Generates the default avatar URL for a discriminator.\n   *\n   * @param discriminator - The discriminator modulo 5\n   */\n  defaultAvatar(discriminator) {\n    return this.makeURL(`/embed/avatars/${discriminator}`, {\n      extension: \"png\"\n    });\n  }\n  /**\n   * Generates a discovery splash URL for a guild's discovery splash.\n   *\n   * @param guildId - The guild id that has the discovery splash\n   * @param splashHash - The hash provided by Discord for this splash\n   * @param options - Optional options for the splash\n   */\n  discoverySplash(guildId, splashHash, options) {\n    return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n  }\n  /**\n   * Generates an emoji's URL for an emoji.\n   *\n   * @param emojiId - The emoji id\n   * @param extension - The extension of the emoji\n   */\n  emoji(emojiId, extension) {\n    return this.makeURL(`/emojis/${emojiId}`, {\n      extension\n    });\n  }\n  /**\n   * Generates a guild member avatar URL.\n   *\n   * @param guildId - The id of the guild\n   * @param userId - The id of the user\n   * @param avatarHash - The hash provided by Discord for this avatar\n   * @param options - Optional options for the avatar\n   */\n  guildMemberAvatar(guildId, userId, avatarHash, options) {\n    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n  }\n  /**\n   * Generates a guild member banner URL.\n   *\n   * @param guildId - The id of the guild\n   * @param userId - The id of the user\n   * @param bannerHash - The hash provided by Discord for this banner\n   * @param options - Optional options for the banner\n   */\n  guildMemberBanner(guildId, userId, bannerHash, options) {\n    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n  }\n  /**\n   * Generates an icon URL, e.g. for a guild.\n   *\n   * @param id - The id that has the icon splash\n   * @param iconHash - The hash provided by Discord for this icon\n   * @param options - Optional options for the icon\n   */\n  icon(id, iconHash, options) {\n    return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n  }\n  /**\n   * Generates a URL for the icon of a role\n   *\n   * @param roleId - The id of the role that has the icon\n   * @param roleIconHash - The hash provided by Discord for this role icon\n   * @param options - Optional options for the role icon\n   */\n  roleIcon(roleId, roleIconHash, options) {\n    return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n  }\n  /**\n   * Generates a guild invite splash URL for a guild's invite splash.\n   *\n   * @param guildId - The guild id that has the invite splash\n   * @param splashHash - The hash provided by Discord for this splash\n   * @param options - Optional options for the splash\n   */\n  splash(guildId, splashHash, options) {\n    return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n  }\n  /**\n   * Generates a sticker URL.\n   *\n   * @param stickerId - The sticker id\n   * @param extension - The extension of the sticker\n   * @privateRemarks\n   * Stickers cannot have a `.webp` extension, so we default to a `.png`\n   */\n  sticker(stickerId) {\n    let extension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"png\";\n    return this.makeURL(`/stickers/${stickerId}`, {\n      allowedExtensions: ALLOWED_STICKER_EXTENSIONS,\n      extension\n    });\n  }\n  /**\n   * Generates a sticker pack banner URL.\n   *\n   * @param bannerId - The banner id\n   * @param options - Optional options for the banner\n   */\n  stickerPackBanner(bannerId, options) {\n    return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n  }\n  /**\n   * Generates a team icon URL for a team's icon.\n   *\n   * @param teamId - The team id that has the icon\n   * @param iconHash - The hash provided by Discord for this icon\n   * @param options - Optional options for the icon\n   */\n  teamIcon(teamId, iconHash, options) {\n    return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n  }\n  /**\n   * Generates a cover image for a guild scheduled event.\n   *\n   * @param scheduledEventId - The scheduled event id\n   * @param coverHash - The hash provided by discord for this cover image\n   * @param options - Optional options for the cover image\n   */\n  guildScheduledEventCover(scheduledEventId, coverHash, options) {\n    return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n  }\n  /**\n   * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n   *\n   * @param route - The base cdn route\n   * @param hash - The hash provided by Discord for this icon\n   * @param options - Optional options for the link\n   */\n  dynamicMakeURL(route, hash) {\n    let {\n      forceStatic = false,\n      ...options\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.makeURL(route, !forceStatic && hash.startsWith(\"a_\") ? {\n      ...options,\n      extension: \"gif\"\n    } : options);\n  }\n  /**\n   * Constructs the URL for the resource\n   *\n   * @param route - The base cdn route\n   * @param options - The extension/size options for the link\n   */\n  makeURL(route) {\n    let {\n      allowedExtensions = ALLOWED_EXTENSIONS,\n      extension = \"webp\",\n      size\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    extension = String(extension).toLowerCase();\n    if (!allowedExtensions.includes(extension)) {\n      throw new RangeError(`Invalid extension provided: ${extension}\nMust be one of: ${allowedExtensions.join(\", \")}`);\n    }\n    if (size && !ALLOWED_SIZES.includes(size)) {\n      throw new RangeError(`Invalid size provided: ${size}\nMust be one of: ${ALLOWED_SIZES.join(\", \")}`);\n    }\n    const url = new import_node_url.URL(`${this.base}${route}.${extension}`);\n    if (size) {\n      url.searchParams.set(\"size\", String(size));\n    }\n    return url.toString();\n  }\n};\n__name(CDN, \"CDN\");\n\n// src/lib/errors/DiscordAPIError.ts\nfunction isErrorGroupWrapper(error) {\n  return Reflect.has(error, \"_errors\");\n}\n__name(isErrorGroupWrapper, \"isErrorGroupWrapper\");\nfunction isErrorResponse(error) {\n  return typeof Reflect.get(error, \"message\") === \"string\";\n}\n__name(isErrorResponse, \"isErrorResponse\");\nvar DiscordAPIError = class extends Error {\n  /**\n   * @param rawError - The error reported by Discord\n   * @param code - The error code reported by Discord\n   * @param status - The status code of the response\n   * @param method - The method of the request that erred\n   * @param url - The url of the request that erred\n   * @param bodyData - The unparsed data for the request that errored\n   */\n  constructor(rawError, code, status, method, url, bodyData) {\n    super(DiscordAPIError.getMessage(rawError));\n    this.rawError = rawError;\n    this.code = code;\n    this.status = status;\n    this.method = method;\n    this.url = url;\n    this.requestBody = {\n      files: bodyData.files,\n      json: bodyData.body\n    };\n  }\n  requestBody;\n  /**\n   * The name of the error\n   */\n  get name() {\n    return `${DiscordAPIError.name}[${this.code}]`;\n  }\n  static getMessage(error) {\n    let flattened = \"\";\n    if (\"code\" in error) {\n      if (error.errors) {\n        flattened = [...this.flattenDiscordError(error.errors)].join(\"\\n\");\n      }\n      return error.message && flattened ? `${error.message}\n${flattened}` : error.message || flattened || \"Unknown Error\";\n    }\n    return error.error_description ?? \"No Description\";\n  }\n  static flattenDiscordError(obj) {\n    var _this = this;\n    let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return function* () {\n      if (isErrorResponse(obj)) {\n        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n      }\n      for (const [otherKey, val] of Object.entries(obj)) {\n        const nextKey = otherKey.startsWith(\"_\") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;\n        if (typeof val === \"string\") {\n          yield val;\n        } else if (isErrorGroupWrapper(val)) {\n          for (const error of val._errors) {\n            yield* _this.flattenDiscordError(error, nextKey);\n          }\n        } else {\n          yield* _this.flattenDiscordError(val, nextKey);\n        }\n      }\n    }();\n  }\n};\n__name(DiscordAPIError, \"DiscordAPIError\");\n\n// src/lib/errors/HTTPError.ts\nvar import_node_http = require(\"http\");\nvar HTTPError = class extends Error {\n  /**\n   * @param status - The status code of the response\n   * @param method - The method of the request that erred\n   * @param url - The url of the request that erred\n   * @param bodyData - The unparsed data for the request that errored\n   */\n  constructor(status, method, url, bodyData) {\n    super(import_node_http.STATUS_CODES[status]);\n    this.status = status;\n    this.method = method;\n    this.url = url;\n    this.requestBody = {\n      files: bodyData.files,\n      json: bodyData.body\n    };\n  }\n  requestBody;\n  name = HTTPError.name;\n};\n__name(HTTPError, \"HTTPError\");\n\n// src/lib/errors/RateLimitError.ts\nvar RateLimitError = class extends Error {\n  timeToReset;\n  limit;\n  method;\n  hash;\n  url;\n  route;\n  majorParameter;\n  global;\n  constructor(_ref) {\n    let {\n      timeToReset,\n      limit,\n      method,\n      hash,\n      url,\n      route,\n      majorParameter,\n      global\n    } = _ref;\n    super();\n    this.timeToReset = timeToReset;\n    this.limit = limit;\n    this.method = method;\n    this.hash = hash;\n    this.url = url;\n    this.route = route;\n    this.majorParameter = majorParameter;\n    this.global = global;\n  }\n  /**\n   * The name of the error\n   */\n  get name() {\n    return `${RateLimitError.name}[${this.route}]`;\n  }\n};\n__name(RateLimitError, \"RateLimitError\");\n\n// src/lib/RequestManager.ts\nvar import_node_buffer2 = require(\"buffer\");\nvar import_node_events = require(\"events\");\nvar import_node_timers2 = require(\"timers\");\nvar import_collection = require(\"@discordjs/collection\");\nvar import_util = require(\"@discordjs/util\");\nvar import_snowflake = require(\"@sapphire/snowflake\");\nvar import_undici4 = require(\"undici\");\n\n// src/lib/handlers/BurstHandler.ts\nvar import_promises = require(\"timers/promises\");\n\n// src/lib/utils/utils.ts\nvar import_node_buffer = require(\"buffer\");\nvar import_node_url2 = require(\"url\");\nvar import_node_util = require(\"util\");\nvar import_undici2 = require(\"undici\");\nfunction parseHeader(header) {\n  if (header === void 0 || typeof header === \"string\") {\n    return header;\n  }\n  return header.join(\";\");\n}\n__name(parseHeader, \"parseHeader\");\nfunction serializeSearchParam(value) {\n  switch (typeof value) {\n    case \"string\":\n      return value;\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n      return value.toString();\n    case \"object\":\n      if (value === null) return null;\n      if (value instanceof Date) {\n        return Number.isNaN(value.getTime()) ? null : value.toISOString();\n      }\n      if (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) return value.toString();\n      return null;\n    default:\n      return null;\n  }\n}\n__name(serializeSearchParam, \"serializeSearchParam\");\nfunction makeURLSearchParams(options) {\n  const params = new import_node_url2.URLSearchParams();\n  if (!options) return params;\n  for (const [key, value] of Object.entries(options)) {\n    const serialized = serializeSearchParam(value);\n    if (serialized !== null) params.append(key, serialized);\n  }\n  return params;\n}\n__name(makeURLSearchParams, \"makeURLSearchParams\");\nasync function parseResponse(res) {\n  const header = parseHeader(res.headers[\"content-type\"]);\n  if (header?.startsWith(\"application/json\")) {\n    return res.body.json();\n  }\n  return res.body.arrayBuffer();\n}\n__name(parseResponse, \"parseResponse\");\nfunction hasSublimit(bucketRoute, body, method) {\n  if (bucketRoute === \"/channels/:id\") {\n    if (typeof body !== \"object\" || body === null) return false;\n    if (method !== \"PATCH\" /* Patch */) return false;\n    const castedBody = body;\n    return [\"name\", \"topic\"].some(key => Reflect.has(castedBody, key));\n  }\n  return true;\n}\n__name(hasSublimit, \"hasSublimit\");\nasync function resolveBody(body) {\n  if (body == null) {\n    return null;\n  } else if (typeof body === \"string\") {\n    return body;\n  } else if (import_node_util.types.isUint8Array(body)) {\n    return body;\n  } else if (import_node_util.types.isArrayBuffer(body)) {\n    return new Uint8Array(body);\n  } else if (body instanceof import_node_url2.URLSearchParams) {\n    return body.toString();\n  } else if (body instanceof DataView) {\n    return new Uint8Array(body.buffer);\n  } else if (body instanceof import_node_buffer.Blob) {\n    return new Uint8Array(await body.arrayBuffer());\n  } else if (body instanceof import_undici2.FormData) {\n    return body;\n  } else if (body[Symbol.iterator]) {\n    const chunks = [...body];\n    const length = chunks.reduce((a, b) => a + b.length, 0);\n    const uint8 = new Uint8Array(length);\n    let lengthUsed = 0;\n    return chunks.reduce((a, b) => {\n      a.set(b, lengthUsed);\n      lengthUsed += b.length;\n      return a;\n    }, uint8);\n  } else if (body[Symbol.asyncIterator]) {\n    const chunks = [];\n    for await (const chunk of body) {\n      chunks.push(chunk);\n    }\n    return import_node_buffer.Buffer.concat(chunks);\n  }\n  throw new TypeError(`Unable to resolve body.`);\n}\n__name(resolveBody, \"resolveBody\");\nfunction shouldRetry(error) {\n  if (error.name === \"AbortError\") return true;\n  return \"code\" in error && error.code === \"ECONNRESET\" || error.message.includes(\"ECONNRESET\");\n}\n__name(shouldRetry, \"shouldRetry\");\nasync function onRateLimit(manager, rateLimitData) {\n  const {\n    options\n  } = manager;\n  if (!options.rejectOnRateLimit) return;\n  const shouldThrow = typeof options.rejectOnRateLimit === \"function\" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some(route => rateLimitData.route.startsWith(route.toLowerCase()));\n  if (shouldThrow) {\n    throw new RateLimitError(rateLimitData);\n  }\n}\n__name(onRateLimit, \"onRateLimit\");\n\n// src/lib/handlers/Shared.ts\nvar import_node_timers = require(\"timers\");\nvar import_undici3 = require(\"undici\");\nvar invalidCount = 0;\nvar invalidCountResetTime = null;\nfunction incrementInvalidCount(manager) {\n  if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n    invalidCountResetTime = Date.now() + 1e3 * 60 * 10;\n    invalidCount = 0;\n  }\n  invalidCount++;\n  const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;\n  if (emitInvalid) {\n    manager.emit(\"invalidRequestWarning\" /* InvalidRequestWarning */, {\n      count: invalidCount,\n      remainingTime: invalidCountResetTime - Date.now()\n    });\n  }\n}\n__name(incrementInvalidCount, \"incrementInvalidCount\");\nasync function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {\n  const controller = new AbortController();\n  const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), manager.options.timeout).unref();\n  if (requestData.signal) {\n    const signal = requestData.signal;\n    if (signal.aborted) controller.abort();else signal.addEventListener(\"abort\", () => controller.abort());\n  }\n  let res;\n  try {\n    res = await (0, import_undici3.request)(url, {\n      ...options,\n      signal: controller.signal\n    });\n  } catch (error) {\n    if (!(error instanceof Error)) throw error;\n    if (shouldRetry(error) && retries !== manager.options.retries) {\n      return null;\n    }\n    throw error;\n  } finally {\n    (0, import_node_timers.clearTimeout)(timeout);\n  }\n  if (manager.listenerCount(\"response\" /* Response */)) {\n    manager.emit(\"response\" /* Response */, {\n      method: options.method ?? \"get\",\n      path: routeId.original,\n      route: routeId.bucketRoute,\n      options,\n      data: requestData,\n      retries\n    }, {\n      ...res\n    });\n  }\n  return res;\n}\n__name(makeNetworkRequest, \"makeNetworkRequest\");\nasync function handleErrors(manager, res, method, url, requestData, retries) {\n  const status = res.statusCode;\n  if (status >= 500 && status < 600) {\n    if (retries !== manager.options.retries) {\n      return null;\n    }\n    throw new HTTPError(status, method, url, requestData);\n  } else {\n    if (status >= 400 && status < 500) {\n      if (status === 401 && requestData.auth) {\n        manager.setToken(null);\n      }\n      const data = await parseResponse(res);\n      throw new DiscordAPIError(data, \"code\" in data ? data.code : data.error, status, method, url, requestData);\n    }\n    return res;\n  }\n}\n__name(handleErrors, \"handleErrors\");\n\n// src/lib/handlers/BurstHandler.ts\nvar BurstHandler = class {\n  /**\n   * @param manager - The request manager\n   * @param hash - The hash that this RequestHandler handles\n   * @param majorParameter - The major parameter for this handler\n   */\n  constructor(manager, hash, majorParameter) {\n    this.manager = manager;\n    this.hash = hash;\n    this.majorParameter = majorParameter;\n    this.id = `${hash}:${majorParameter}`;\n  }\n  /**\n   * {@inheritdoc IHandler.id}\n   */\n  id;\n  /**\n   * {@inheritDoc IHandler.inactive}\n   */\n  inactive = false;\n  /**\n   * Emits a debug message\n   *\n   * @param message - The message to debug\n   */\n  debug(message) {\n    this.manager.emit(\"restDebug\" /* Debug */, `[REST ${this.id}] ${message}`);\n  }\n  /**\n   * {@inheritDoc IHandler.queueRequest}\n   */\n  async queueRequest(routeId, url, options, requestData) {\n    return this.runRequest(routeId, url, options, requestData);\n  }\n  /**\n   * The method that actually makes the request to the API, and updates info about the bucket accordingly\n   *\n   * @param routeId - The generalized API route with literal ids for major parameters\n   * @param url - The fully resolved URL to make the request to\n   * @param options - The fetch options needed to make the request\n   * @param requestData - Extra data from the user's request needed for errors and additional processing\n   * @param retries - The number of retries this request has already attempted (recursion)\n   */\n  async runRequest(routeId, url, options, requestData) {\n    let retries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const method = options.method ?? \"get\";\n    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n    if (res === null) {\n      return this.runRequest(routeId, url, options, requestData, ++retries);\n    }\n    const status = res.statusCode;\n    let retryAfter = 0;\n    const retry = parseHeader(res.headers[\"retry-after\"]);\n    if (retry) retryAfter = Number(retry) * 1e3 + this.manager.options.offset;\n    if (status === 401 || status === 403 || status === 429) {\n      incrementInvalidCount(this.manager);\n    }\n    if (status >= 200 && status < 300) {\n      return res;\n    } else if (status === 429) {\n      const isGlobal = res.headers[\"x-ratelimit-global\"] !== void 0;\n      await onRateLimit(this.manager, {\n        timeToReset: retryAfter,\n        limit: Number.POSITIVE_INFINITY,\n        method,\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      });\n      this.debug([\"Encountered unexpected 429 rate limit\", `  Global         : ${isGlobal}`, `  Method         : ${method}`, `  URL            : ${url}`, `  Bucket         : ${routeId.bucketRoute}`, `  Major parameter: ${routeId.majorParameter}`, `  Hash           : ${this.hash}`, `  Limit          : ${Number.POSITIVE_INFINITY}`, `  Retry After    : ${retryAfter}ms`, `  Sublimit       : None`].join(\"\\n\"));\n      await (0, import_promises.setTimeout)(retryAfter);\n      return this.runRequest(routeId, url, options, requestData, retries);\n    } else {\n      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n      if (handled === null) {\n        return this.runRequest(routeId, url, options, requestData, ++retries);\n      }\n      return handled;\n    }\n  }\n};\n__name(BurstHandler, \"BurstHandler\");\n\n// src/lib/handlers/SequentialHandler.ts\nvar import_promises2 = require(\"timers/promises\");\nvar import_async_queue = require(\"@sapphire/async-queue\");\nvar SequentialHandler = class {\n  /**\n   * @param manager - The request manager\n   * @param hash - The hash that this RequestHandler handles\n   * @param majorParameter - The major parameter for this handler\n   */\n  constructor(manager, hash, majorParameter) {\n    this.manager = manager;\n    this.hash = hash;\n    this.majorParameter = majorParameter;\n    this.id = `${hash}:${majorParameter}`;\n  }\n  /**\n   * {@inheritDoc IHandler.id}\n   */\n  id;\n  /**\n   * The time this rate limit bucket will reset\n   */\n  reset = -1;\n  /**\n   * The remaining requests that can be made before we are rate limited\n   */\n  remaining = 1;\n  /**\n   * The total number of requests that can be made before we are rate limited\n   */\n  limit = Number.POSITIVE_INFINITY;\n  /**\n   * The interface used to sequence async requests sequentially\n   */\n  #asyncQueue = new import_async_queue.AsyncQueue();\n  /**\n   * The interface used to sequence sublimited async requests sequentially\n   */\n  #sublimitedQueue = null;\n  /**\n   * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n   */\n  #sublimitPromise = null;\n  /**\n   * Whether the sublimit queue needs to be shifted in the finally block\n   */\n  #shiftSublimit = false;\n  /**\n   * {@inheritDoc IHandler.inactive}\n   */\n  get inactive() {\n    return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;\n  }\n  /**\n   * If the rate limit bucket is currently limited by the global limit\n   */\n  get globalLimited() {\n    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n  }\n  /**\n   * If the rate limit bucket is currently limited by its limit\n   */\n  get localLimited() {\n    return this.remaining <= 0 && Date.now() < this.reset;\n  }\n  /**\n   * If the rate limit bucket is currently limited\n   */\n  get limited() {\n    return this.globalLimited || this.localLimited;\n  }\n  /**\n   * The time until queued requests can continue\n   */\n  get timeToReset() {\n    return this.reset + this.manager.options.offset - Date.now();\n  }\n  /**\n   * Emits a debug message\n   *\n   * @param message - The message to debug\n   */\n  debug(message) {\n    this.manager.emit(\"restDebug\" /* Debug */, `[REST ${this.id}] ${message}`);\n  }\n  /**\n   * Delay all requests for the specified amount of time, handling global rate limits\n   *\n   * @param time - The amount of time to delay all requests for\n   */\n  async globalDelayFor(time) {\n    await (0, import_promises2.setTimeout)(time);\n    this.manager.globalDelay = null;\n  }\n  /**\n   * {@inheritDoc IHandler.queueRequest}\n   */\n  async queueRequest(routeId, url, options, requestData) {\n    let queue = this.#asyncQueue;\n    let queueType = 0 /* Standard */;\n    if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n      queue = this.#sublimitedQueue;\n      queueType = 1 /* Sublimit */;\n    }\n\n    await queue.wait({\n      signal: requestData.signal\n    });\n    if (queueType === 0 /* Standard */) {\n      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n        queue = this.#sublimitedQueue;\n        const wait = queue.wait();\n        this.#asyncQueue.shift();\n        await wait;\n      } else if (this.#sublimitPromise) {\n        await this.#sublimitPromise.promise;\n      }\n    }\n    try {\n      return await this.runRequest(routeId, url, options, requestData);\n    } finally {\n      queue.shift();\n      if (this.#shiftSublimit) {\n        this.#shiftSublimit = false;\n        this.#sublimitedQueue?.shift();\n      }\n      if (this.#sublimitedQueue?.remaining === 0) {\n        this.#sublimitPromise?.resolve();\n        this.#sublimitedQueue = null;\n      }\n    }\n  }\n  /**\n   * The method that actually makes the request to the api, and updates info about the bucket accordingly\n   *\n   * @param routeId - The generalized api route with literal ids for major parameters\n   * @param url - The fully resolved url to make the request to\n   * @param options - The fetch options needed to make the request\n   * @param requestData - Extra data from the user's request needed for errors and additional processing\n   * @param retries - The number of retries this request has already attempted (recursion)\n   */\n  async runRequest(routeId, url, options, requestData) {\n    let retries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    while (this.limited) {\n      const isGlobal = this.globalLimited;\n      let limit2;\n      let timeout;\n      let delay;\n      if (isGlobal) {\n        limit2 = this.manager.options.globalRequestsPerSecond;\n        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n        if (!this.manager.globalDelay) {\n          this.manager.globalDelay = this.globalDelayFor(timeout);\n        }\n        delay = this.manager.globalDelay;\n      } else {\n        limit2 = this.limit;\n        timeout = this.timeToReset;\n        delay = (0, import_promises2.setTimeout)(timeout);\n      }\n      const rateLimitData = {\n        timeToReset: timeout,\n        limit: limit2,\n        method: options.method ?? \"get\",\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      };\n      this.manager.emit(\"rateLimited\" /* RateLimited */, rateLimitData);\n      await onRateLimit(this.manager, rateLimitData);\n      if (isGlobal) {\n        this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n      } else {\n        this.debug(`Waiting ${timeout}ms for rate limit to pass`);\n      }\n      await delay;\n    }\n    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n      this.manager.globalReset = Date.now() + 1e3;\n      this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n    }\n    this.manager.globalRemaining--;\n    const method = options.method ?? \"get\";\n    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n    if (res === null) {\n      return this.runRequest(routeId, url, options, requestData, ++retries);\n    }\n    const status = res.statusCode;\n    let retryAfter = 0;\n    const limit = parseHeader(res.headers[\"x-ratelimit-limit\"]);\n    const remaining = parseHeader(res.headers[\"x-ratelimit-remaining\"]);\n    const reset = parseHeader(res.headers[\"x-ratelimit-reset-after\"]);\n    const hash = parseHeader(res.headers[\"x-ratelimit-bucket\"]);\n    const retry = parseHeader(res.headers[\"retry-after\"]);\n    this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n    this.remaining = remaining ? Number(remaining) : 1;\n    this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();\n    if (retry) retryAfter = Number(retry) * 1e3 + this.manager.options.offset;\n    if (hash && hash !== this.hash) {\n      this.debug([\"Received bucket hash update\", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join(\"\\n\"));\n      this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, {\n        value: hash,\n        lastAccess: Date.now()\n      });\n    } else if (hash) {\n      const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n      if (hashData) {\n        hashData.lastAccess = Date.now();\n      }\n    }\n    let sublimitTimeout = null;\n    if (retryAfter > 0) {\n      if (res.headers[\"x-ratelimit-global\"] !== void 0) {\n        this.manager.globalRemaining = 0;\n        this.manager.globalReset = Date.now() + retryAfter;\n      } else if (!this.localLimited) {\n        sublimitTimeout = retryAfter;\n      }\n    }\n    if (status === 401 || status === 403 || status === 429) {\n      incrementInvalidCount(this.manager);\n    }\n    if (status >= 200 && status < 300) {\n      return res;\n    } else if (status === 429) {\n      const isGlobal = this.globalLimited;\n      let limit2;\n      let timeout;\n      if (isGlobal) {\n        limit2 = this.manager.options.globalRequestsPerSecond;\n        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n      } else {\n        limit2 = this.limit;\n        timeout = this.timeToReset;\n      }\n      await onRateLimit(this.manager, {\n        timeToReset: timeout,\n        limit: limit2,\n        method,\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      });\n      this.debug([\"Encountered unexpected 429 rate limit\", `  Global         : ${isGlobal.toString()}`, `  Method         : ${method}`, `  URL            : ${url}`, `  Bucket         : ${routeId.bucketRoute}`, `  Major parameter: ${routeId.majorParameter}`, `  Hash           : ${this.hash}`, `  Limit          : ${limit2}`, `  Retry After    : ${retryAfter}ms`, `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : \"None\"}`].join(\"\\n\"));\n      if (sublimitTimeout) {\n        const firstSublimit = !this.#sublimitedQueue;\n        if (firstSublimit) {\n          this.#sublimitedQueue = new import_async_queue.AsyncQueue();\n          void this.#sublimitedQueue.wait();\n          this.#asyncQueue.shift();\n        }\n        this.#sublimitPromise?.resolve();\n        this.#sublimitPromise = null;\n        await (0, import_promises2.setTimeout)(sublimitTimeout);\n        let resolve;\n        const promise = new Promise(res2 => resolve = res2);\n        this.#sublimitPromise = {\n          promise,\n          resolve\n        };\n        if (firstSublimit) {\n          await this.#asyncQueue.wait();\n          this.#shiftSublimit = true;\n        }\n      }\n      return this.runRequest(routeId, url, options, requestData, retries);\n    } else {\n      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n      if (handled === null) {\n        return this.runRequest(routeId, url, options, requestData, ++retries);\n      }\n      return handled;\n    }\n  }\n};\n__name(SequentialHandler, \"SequentialHandler\");\n\n// src/lib/RequestManager.ts\nvar getFileType = (0, import_util.lazy)(async () => import(\"file-type\"));\nvar RequestMethod = /* @__PURE__ */(RequestMethod2 => {\n  RequestMethod2[\"Delete\"] = \"DELETE\";\n  RequestMethod2[\"Get\"] = \"GET\";\n  RequestMethod2[\"Patch\"] = \"PATCH\";\n  RequestMethod2[\"Post\"] = \"POST\";\n  RequestMethod2[\"Put\"] = \"PUT\";\n  return RequestMethod2;\n})(RequestMethod || {});\nvar RequestManager = class extends import_node_events.EventEmitter {\n  /**\n   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests\n   * performed by this manager.\n   */\n  agent = null;\n  /**\n   * The number of requests remaining in the global bucket\n   */\n  globalRemaining;\n  /**\n   * The promise used to wait out the global rate limit\n   */\n  globalDelay = null;\n  /**\n   * The timestamp at which the global bucket resets\n   */\n  globalReset = -1;\n  /**\n   * API bucket hashes that are cached from provided routes\n   */\n  hashes = new import_collection.Collection();\n  /**\n   * Request handlers created from the bucket hash and the major parameters\n   */\n  handlers = new import_collection.Collection();\n  #token = null;\n  hashTimer;\n  handlerTimer;\n  options;\n  constructor(options) {\n    super();\n    this.options = {\n      ...DefaultRestOptions,\n      ...options\n    };\n    this.options.offset = Math.max(0, this.options.offset);\n    this.globalRemaining = this.options.globalRequestsPerSecond;\n    this.agent = options.agent ?? null;\n    this.setupSweepers();\n  }\n  setupSweepers() {\n    const validateMaxInterval = /* @__PURE__ */__name(interval => {\n      if (interval > 144e5) {\n        throw new Error(\"Cannot set an interval greater than 4 hours\");\n      }\n    }, \"validateMaxInterval\");\n    if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n      validateMaxInterval(this.options.hashSweepInterval);\n      this.hashTimer = (0, import_node_timers2.setInterval)(() => {\n        const sweptHashes = new import_collection.Collection();\n        const currentDate = Date.now();\n        this.hashes.sweep((val, key) => {\n          if (val.lastAccess === -1) return false;\n          const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n          if (shouldSweep) {\n            sweptHashes.set(key, val);\n          }\n          this.emit(\"restDebug\" /* Debug */, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n          return shouldSweep;\n        });\n        this.emit(\"hashSweep\" /* HashSweep */, sweptHashes);\n      }, this.options.hashSweepInterval).unref();\n    }\n    if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n      validateMaxInterval(this.options.handlerSweepInterval);\n      this.handlerTimer = (0, import_node_timers2.setInterval)(() => {\n        const sweptHandlers = new import_collection.Collection();\n        this.handlers.sweep((val, key) => {\n          const {\n            inactive\n          } = val;\n          if (inactive) {\n            sweptHandlers.set(key, val);\n          }\n          this.emit(\"restDebug\" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);\n          return inactive;\n        });\n        this.emit(\"handlerSweep\" /* HandlerSweep */, sweptHandlers);\n      }, this.options.handlerSweepInterval).unref();\n    }\n  }\n  /**\n   * Sets the default agent to use for requests performed by this manager\n   *\n   * @param agent - The agent to use\n   */\n  setAgent(agent) {\n    this.agent = agent;\n    return this;\n  }\n  /**\n   * Sets the authorization token that should be used for requests\n   *\n   * @param token - The authorization token to use\n   */\n  setToken(token) {\n    this.#token = token;\n    return this;\n  }\n  /**\n   * Queues a request to be sent\n   *\n   * @param request - All the information needed to make a request\n   * @returns The response from the api request\n   */\n  async queueRequest(request2) {\n    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);\n    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {\n      value: `Global(${request2.method}:${routeId.bucketRoute})`,\n      lastAccess: -1\n    };\n    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);\n    const {\n      url,\n      fetchOptions\n    } = await this.resolveRequest(request2);\n    return handler.queueRequest(routeId, url, fetchOptions, {\n      body: request2.body,\n      files: request2.files,\n      auth: request2.auth !== false,\n      signal: request2.signal\n    });\n  }\n  /**\n   * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n   *\n   * @param hash - The hash for the route\n   * @param majorParameter - The major parameter for this handler\n   * @internal\n   */\n  createHandler(hash, majorParameter) {\n    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);\n    this.handlers.set(queue.id, queue);\n    return queue;\n  }\n  /**\n   * Formats the request data to a usable format for fetch\n   *\n   * @param request - The request data\n   */\n  async resolveRequest(request2) {\n    const {\n      options\n    } = this;\n    let query = \"\";\n    if (request2.query) {\n      const resolvedQuery = request2.query.toString();\n      if (resolvedQuery !== \"\") {\n        query = `?${resolvedQuery}`;\n      }\n    }\n    const headers = {\n      ...this.options.headers,\n      \"User-Agent\": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()\n    };\n    if (request2.auth !== false) {\n      if (!this.#token) {\n        throw new Error(\"Expected token to be set for this request, but none was present\");\n      }\n      headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n    }\n    if (request2.reason?.length) {\n      headers[\"X-Audit-Log-Reason\"] = encodeURIComponent(request2.reason);\n    }\n    const url = `${options.api}${request2.versioned === false ? \"\" : `/v${options.version}`}${request2.fullRoute}${query}`;\n    let finalBody;\n    let additionalHeaders = {};\n    if (request2.files?.length) {\n      const formData = new import_undici4.FormData();\n      for (const [index, file] of request2.files.entries()) {\n        const fileKey = file.key ?? `files[${index}]`;\n        if (import_node_buffer2.Buffer.isBuffer(file.data)) {\n          const {\n            fileTypeFromBuffer\n          } = await getFileType();\n          let contentType = file.contentType;\n          if (!contentType) {\n            const parsedType = (await fileTypeFromBuffer(file.data))?.mime;\n            if (parsedType) {\n              contentType = OverwrittenMimeTypes[parsedType] ?? parsedType;\n            }\n          }\n          formData.append(fileKey, new import_node_buffer2.Blob([file.data], {\n            type: contentType\n          }), file.name);\n        } else {\n          formData.append(fileKey, new import_node_buffer2.Blob([`${file.data}`], {\n            type: file.contentType\n          }), file.name);\n        }\n      }\n      if (request2.body != null) {\n        if (request2.appendToFormData) {\n          for (const [key, value] of Object.entries(request2.body)) {\n            formData.append(key, value);\n          }\n        } else {\n          formData.append(\"payload_json\", JSON.stringify(request2.body));\n        }\n      }\n      finalBody = formData;\n    } else if (request2.body != null) {\n      if (request2.passThroughBody) {\n        finalBody = request2.body;\n      } else {\n        finalBody = JSON.stringify(request2.body);\n        additionalHeaders = {\n          \"Content-Type\": \"application/json\"\n        };\n      }\n    }\n    finalBody = await resolveBody(finalBody);\n    const fetchOptions = {\n      headers: {\n        ...request2.headers,\n        ...additionalHeaders,\n        ...headers\n      },\n      method: request2.method.toUpperCase()\n    };\n    if (finalBody !== void 0) {\n      fetchOptions.body = finalBody;\n    }\n    fetchOptions.dispatcher = request2.dispatcher ?? this.agent ?? void 0;\n    return {\n      url,\n      fetchOptions\n    };\n  }\n  /**\n   * Stops the hash sweeping interval\n   */\n  clearHashSweeper() {\n    (0, import_node_timers2.clearInterval)(this.hashTimer);\n  }\n  /**\n   * Stops the request handler sweeping interval\n   */\n  clearHandlerSweeper() {\n    (0, import_node_timers2.clearInterval)(this.handlerTimer);\n  }\n  /**\n   * Generates route data for an endpoint:method\n   *\n   * @param endpoint - The raw endpoint to generalize\n   * @param method - The HTTP method this endpoint is called without\n   * @internal\n   */\n  static generateRouteData(endpoint, method) {\n    if (endpoint.startsWith(\"/interactions/\") && endpoint.endsWith(\"/callback\")) {\n      return {\n        majorParameter: BurstHandlerMajorIdKey,\n        bucketRoute: \"/interactions/:id/:token/callback\",\n        original: endpoint\n      };\n    }\n    const majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{17,19})/.exec(endpoint);\n    const majorId = majorIdMatch?.[1] ?? \"global\";\n    const baseRoute = endpoint.replaceAll(/\\d{17,19}/g, \":id\").replace(/\\/reactions\\/(.*)/, \"/reactions/:reaction\");\n    let exceptions = \"\";\n    if (method === \"DELETE\" /* Delete */ && baseRoute === \"/channels/:id/messages/:id\") {\n      const id = /\\d{17,19}$/.exec(endpoint)[0];\n      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);\n      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {\n        exceptions += \"/Delete Old Message\";\n      }\n    }\n    return {\n      majorParameter: majorId,\n      bucketRoute: baseRoute + exceptions,\n      original: endpoint\n    };\n  }\n};\n__name(RequestManager, \"RequestManager\");\n\n// src/lib/REST.ts\nvar import_node_events2 = require(\"events\");\nvar REST = class extends import_node_events2.EventEmitter {\n  cdn;\n  requestManager;\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n    this.requestManager = new RequestManager(options).on(\"restDebug\" /* Debug */, this.emit.bind(this, \"restDebug\" /* Debug */)).on(\"rateLimited\" /* RateLimited */, this.emit.bind(this, \"rateLimited\" /* RateLimited */)).on(\"invalidRequestWarning\" /* InvalidRequestWarning */, this.emit.bind(this, \"invalidRequestWarning\" /* InvalidRequestWarning */)).on(\"hashSweep\" /* HashSweep */, this.emit.bind(this, \"hashSweep\" /* HashSweep */));\n    this.on(\"newListener\", (name, listener) => {\n      if (name === \"response\" /* Response */) this.requestManager.on(name, listener);\n    });\n    this.on(\"removeListener\", (name, listener) => {\n      if (name === \"response\" /* Response */) this.requestManager.off(name, listener);\n    });\n  }\n  /**\n   * Gets the agent set for this instance\n   */\n  getAgent() {\n    return this.requestManager.agent;\n  }\n  /**\n   * Sets the default agent to use for requests performed by this instance\n   *\n   * @param agent - Sets the agent to use\n   */\n  setAgent(agent) {\n    this.requestManager.setAgent(agent);\n    return this;\n  }\n  /**\n   * Sets the authorization token that should be used for requests\n   *\n   * @param token - The authorization token to use\n   */\n  setToken(token) {\n    this.requestManager.setToken(token);\n    return this;\n  }\n  /**\n   * Runs a get request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async get(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"GET\" /* Get */\n    });\n  }\n  /**\n   * Runs a delete request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async delete(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"DELETE\" /* Delete */\n    });\n  }\n  /**\n   * Runs a post request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async post(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"POST\" /* Post */\n    });\n  }\n  /**\n   * Runs a put request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async put(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"PUT\" /* Put */\n    });\n  }\n  /**\n   * Runs a patch request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async patch(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"PATCH\" /* Patch */\n    });\n  }\n  /**\n   * Runs a request from the api\n   *\n   * @param options - Request options\n   */\n  async request(options) {\n    const response = await this.raw(options);\n    return parseResponse(response);\n  }\n  /**\n   * Runs a request from the API, yielding the raw Response object\n   *\n   * @param options - Request options\n   */\n  async raw(options) {\n    return this.requestManager.queueRequest(options);\n  }\n};\n__name(REST, \"REST\");\n\n// src/index.ts\nvar version = \"1.7.1\";\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ALLOWED_EXTENSIONS,\n  ALLOWED_SIZES,\n  ALLOWED_STICKER_EXTENSIONS,\n  BurstHandlerMajorIdKey,\n  CDN,\n  DefaultRestOptions,\n  DefaultUserAgent,\n  DefaultUserAgentAppendix,\n  DiscordAPIError,\n  HTTPError,\n  OverwrittenMimeTypes,\n  REST,\n  RESTEvents,\n  RateLimitError,\n  RequestManager,\n  RequestMethod,\n  makeURLSearchParams,\n  parseResponse,\n  version\n});","map":{"version":3,"names":["src_exports","__export","ALLOWED_EXTENSIONS","ALLOWED_SIZES","ALLOWED_STICKER_EXTENSIONS","BurstHandlerMajorIdKey","CDN","DefaultRestOptions","DefaultUserAgent","DefaultUserAgentAppendix","DiscordAPIError","HTTPError","OverwrittenMimeTypes","REST","RESTEvents","RateLimitError","RequestManager","RequestMethod","makeURLSearchParams","parseResponse","version","module","exports","__toCommonJS","import_node_url","require","import_node_process","__toESM","import_v10","import_undici","default","release","name","agent","Agent","connect","timeout","api","authPrefix","cdn","headers","invalidRequestWarningInterval","globalRequestsPerSecond","offset","rejectOnRateLimit","retries","userAgentAppendix","APIVersion","hashSweepInterval","hashLifetime","handlerSweepInterval","RESTEvents2","constructor","base","arguments","length","undefined","appAsset","clientId","assetHash","options","makeURL","appIcon","iconHash","avatar","id","avatarHash","dynamicMakeURL","banner","bannerHash","channelIcon","channelId","defaultAvatar","discriminator","extension","discoverySplash","guildId","splashHash","emoji","emojiId","guildMemberAvatar","userId","guildMemberBanner","icon","roleIcon","roleId","roleIconHash","splash","sticker","stickerId","allowedExtensions","stickerPackBanner","bannerId","teamIcon","teamId","guildScheduledEventCover","scheduledEventId","coverHash","route","hash","forceStatic","startsWith","size","String","toLowerCase","includes","RangeError","join","url","URL","searchParams","set","toString","__name","isErrorGroupWrapper","error","Reflect","has","isErrorResponse","get","Error","rawError","code","status","method","bodyData","getMessage","requestBody","files","json","body","flattened","errors","flattenDiscordError","message","error_description","obj","_this","key","trim","otherKey","val","Object","entries","nextKey","Number","isNaN","_errors","import_node_http","STATUS_CODES","timeToReset","limit","majorParameter","global","_ref","import_node_buffer2","import_node_events","import_node_timers2","import_collection","import_util","import_snowflake","import_undici4","import_promises","import_node_buffer","import_node_url2","import_node_util","import_undici2","parseHeader","header","serializeSearchParam","value","Date","getTime","toISOString","prototype","params","URLSearchParams","serialized","append","res","arrayBuffer","hasSublimit","bucketRoute","castedBody","some","resolveBody","types","isUint8Array","isArrayBuffer","Uint8Array","DataView","buffer","Blob","FormData","Symbol","iterator","chunks","reduce","a","b","uint8","lengthUsed","asyncIterator","chunk","push","Buffer","concat","TypeError","shouldRetry","onRateLimit","manager","rateLimitData","shouldThrow","import_node_timers","import_undici3","invalidCount","invalidCountResetTime","incrementInvalidCount","now","emitInvalid","emit","count","remainingTime","makeNetworkRequest","routeId","requestData","controller","AbortController","setTimeout","abort","unref","signal","aborted","addEventListener","request","clearTimeout","listenerCount","path","original","data","handleErrors","statusCode","auth","setToken","BurstHandler","inactive","debug","queueRequest","runRequest","retryAfter","retry","isGlobal","POSITIVE_INFINITY","handled","import_promises2","import_async_queue","SequentialHandler","reset","remaining","asyncQueue","AsyncQueue","sublimitedQueue","sublimitPromise","shiftSublimit","limited","globalLimited","globalRemaining","globalReset","localLimited","globalDelayFor","time","globalDelay","queue","queueType","wait","shift","promise","resolve","limit2","delay","hashes","lastAccess","hashData","sublimitTimeout","firstSublimit","Promise","res2","getFileType","lazy","RequestMethod2","EventEmitter","Collection","handlers","token","hashTimer","handlerTimer","Math","max","setupSweepers","validateMaxInterval","interval","setInterval","sweptHashes","currentDate","sweep","shouldSweep","floor","sweptHandlers","setAgent","request2","generateRouteData","fullRoute","handler","createHandler","fetchOptions","resolveRequest","query","resolvedQuery","Authorization","reason","encodeURIComponent","versioned","finalBody","additionalHeaders","formData","index","file","fileKey","isBuffer","fileTypeFromBuffer","contentType","parsedType","mime","type","appendToFormData","JSON","stringify","passThroughBody","toUpperCase","dispatcher","clearHashSweeper","clearInterval","clearHandlerSweeper","endpoint","endsWith","majorIdMatch","exec","majorId","baseRoute","replaceAll","replace","exceptions","timestamp","DiscordSnowflake","timestampFrom","import_node_events2","requestManager","on","bind","listener","off","getAgent","delete","post","put","patch","response","raw"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/index.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/CDN.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/utils/constants.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/errors/DiscordAPIError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/errors/HTTPError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/errors/RateLimitError.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/RequestManager.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/handlers/BurstHandler.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/utils/utils.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/handlers/Shared.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/handlers/SequentialHandler.ts","/Users/williedejongh/Downloads/ark3-main4/node_modules/@discordjs/rest/src/lib/REST.ts"],"sourcesContent":["export * from './lib/CDN.js';\nexport * from './lib/errors/DiscordAPIError.js';\nexport * from './lib/errors/HTTPError.js';\nexport * from './lib/errors/RateLimitError.js';\nexport * from './lib/RequestManager.js';\nexport * from './lib/REST.js';\nexport * from './lib/utils/constants.js';\nexport { makeURLSearchParams, parseResponse } from './lib/utils/utils.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/rest/#readme | @discordjs/rest} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\nexport const version = '1.7.1' as string;\n","/* eslint-disable jsdoc/check-param-names */\nimport { URL } from 'node:url';\nimport {\n\tALLOWED_EXTENSIONS,\n\tALLOWED_SIZES,\n\tALLOWED_STICKER_EXTENSIONS,\n\tDefaultRestOptions,\n\ttype ImageExtension,\n\ttype ImageSize,\n\ttype StickerExtension,\n} from './utils/constants.js';\n\n/**\n * The options used for image URLs\n */\nexport interface BaseImageURLOptions {\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: ImageExtension;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The options used for image URLs with animated content\n */\nexport interface ImageURLOptions extends BaseImageURLOptions {\n\t/**\n\t * Whether or not to prefer the static version of an image asset.\n\t */\n\tforceStatic?: boolean;\n}\n\n/**\n * The options to use when making a CDN URL\n */\nexport interface MakeURLOptions {\n\t/**\n\t * The allowed extensions that can be used\n\t */\n\tallowedExtensions?: readonly string[];\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: string | undefined;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The CDN link builder\n */\nexport class CDN {\n\tpublic constructor(private readonly base: string = DefaultRestOptions.cdn) {}\n\n\t/**\n\t * Generates an app asset URL for a client's asset.\n\t *\n\t * @param clientId - The client id that has the asset\n\t * @param assetHash - The hash provided by Discord for this asset\n\t * @param options - Optional options for the asset\n\t */\n\tpublic appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n\t}\n\n\t/**\n\t * Generates an app icon URL for a client's icon.\n\t *\n\t * @param clientId - The client id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates an avatar URL, e.g. for a user or a webhook.\n\t *\n\t * @param id - The id that has the icon\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a banner URL, e.g. for a user or a guild.\n\t *\n\t * @param id - The id that has the banner splash\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL for a channel, e.g. a group DM.\n\t *\n\t * @param channelId - The channel id that has the icon\n\t * @param iconHash - The hash provided by Discord for this channel\n\t * @param options - Optional options for the icon\n\t */\n\tpublic channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates the default avatar URL for a discriminator.\n\t *\n\t * @param discriminator - The discriminator modulo 5\n\t */\n\tpublic defaultAvatar(discriminator: number): string {\n\t\treturn this.makeURL(`/embed/avatars/${discriminator}`, { extension: 'png' });\n\t}\n\n\t/**\n\t * Generates a discovery splash URL for a guild's discovery splash.\n\t *\n\t * @param guildId - The guild id that has the discovery splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates an emoji's URL for an emoji.\n\t *\n\t * @param emojiId - The emoji id\n\t * @param extension - The extension of the emoji\n\t */\n\tpublic emoji(emojiId: string, extension?: ImageExtension): string {\n\t\treturn this.makeURL(`/emojis/${emojiId}`, { extension });\n\t}\n\n\t/**\n\t * Generates a guild member avatar URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic guildMemberAvatar(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tavatarHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a guild member banner URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic guildMemberBanner(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tbannerHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL, e.g. for a guild.\n\t *\n\t * @param id - The id that has the icon splash\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n\t}\n\n\t/**\n\t * Generates a URL for the icon of a role\n\t *\n\t * @param roleId - The id of the role that has the icon\n\t * @param roleIconHash - The hash provided by Discord for this role icon\n\t * @param options - Optional options for the role icon\n\t */\n\tpublic roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a guild invite splash URL for a guild's invite splash.\n\t *\n\t * @param guildId - The guild id that has the invite splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates a sticker URL.\n\t *\n\t * @param stickerId - The sticker id\n\t * @param extension - The extension of the sticker\n\t * @privateRemarks\n\t * Stickers cannot have a `.webp` extension, so we default to a `.png`\n\t */\n\tpublic sticker(stickerId: string, extension: StickerExtension = 'png'): string {\n\t\treturn this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });\n\t}\n\n\t/**\n\t * Generates a sticker pack banner URL.\n\t *\n\t * @param bannerId - The banner id\n\t * @param options - Optional options for the banner\n\t */\n\tpublic stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n\t}\n\n\t/**\n\t * Generates a team icon URL for a team's icon.\n\t *\n\t * @param teamId - The team id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a cover image for a guild scheduled event.\n\t *\n\t * @param scheduledEventId - The scheduled event id\n\t * @param coverHash - The hash provided by discord for this cover image\n\t * @param options - Optional options for the cover image\n\t */\n\tpublic guildScheduledEventCover(\n\t\tscheduledEventId: string,\n\t\tcoverHash: string,\n\t\toptions?: Readonly<BaseImageURLOptions>,\n\t): string {\n\t\treturn this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n\t *\n\t * @param route - The base cdn route\n\t * @param hash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the link\n\t */\n\tprivate dynamicMakeURL(\n\t\troute: string,\n\t\thash: string,\n\t\t{ forceStatic = false, ...options }: Readonly<ImageURLOptions> = {},\n\t): string {\n\t\treturn this.makeURL(route, !forceStatic && hash.startsWith('a_') ? { ...options, extension: 'gif' } : options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource\n\t *\n\t * @param route - The base cdn route\n\t * @param options - The extension/size options for the link\n\t */\n\tprivate makeURL(\n\t\troute: string,\n\t\t{ allowedExtensions = ALLOWED_EXTENSIONS, extension = 'webp', size }: Readonly<MakeURLOptions> = {},\n\t): string {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\textension = String(extension).toLowerCase();\n\n\t\tif (!allowedExtensions.includes(extension)) {\n\t\t\tthrow new RangeError(`Invalid extension provided: ${extension}\\nMust be one of: ${allowedExtensions.join(', ')}`);\n\t\t}\n\n\t\tif (size && !ALLOWED_SIZES.includes(size)) {\n\t\t\tthrow new RangeError(`Invalid size provided: ${size}\\nMust be one of: ${ALLOWED_SIZES.join(', ')}`);\n\t\t}\n\n\t\tconst url = new URL(`${this.base}${route}.${extension}`);\n\n\t\tif (size) {\n\t\t\turl.searchParams.set('size', String(size));\n\t\t}\n\n\t\treturn url.toString();\n\t}\n}\n","import process from 'node:process';\nimport { APIVersion } from 'discord-api-types/v10';\nimport { Agent } from 'undici';\nimport type { RESTOptions } from '../REST.js';\n\nexport const DefaultUserAgent =\n\t`DiscordBot (https://discord.js.org, 1.7.1)` as `DiscordBot (https://discord.js.org, ${string})`;\n\n/**\n * The default string to append onto the user agent.\n */\nexport const DefaultUserAgentAppendix = process.release?.name === 'node' ? `Node.js/${process.version}` : '';\n\nexport const DefaultRestOptions = {\n\tget agent() {\n\t\treturn new Agent({\n\t\t\tconnect: {\n\t\t\t\ttimeout: 30_000,\n\t\t\t},\n\t\t});\n\t},\n\tapi: 'https://discord.com/api',\n\tauthPrefix: 'Bot',\n\tcdn: 'https://cdn.discordapp.com',\n\theaders: {},\n\tinvalidRequestWarningInterval: 0,\n\tglobalRequestsPerSecond: 50,\n\toffset: 50,\n\trejectOnRateLimit: null,\n\tretries: 3,\n\ttimeout: 15_000,\n\tuserAgentAppendix: DefaultUserAgentAppendix,\n\tversion: APIVersion,\n\thashSweepInterval: 14_400_000, // 4 Hours\n\thashLifetime: 86_400_000, // 24 Hours\n\thandlerSweepInterval: 3_600_000, // 1 Hour\n} as const satisfies Required<RESTOptions>;\n\n/**\n * The events that the REST manager emits\n */\nexport enum RESTEvents {\n\tDebug = 'restDebug',\n\tHandlerSweep = 'handlerSweep',\n\tHashSweep = 'hashSweep',\n\tInvalidRequestWarning = 'invalidRequestWarning',\n\tRateLimited = 'rateLimited',\n\tResponse = 'response',\n}\n\nexport const ALLOWED_EXTENSIONS = ['webp', 'png', 'jpg', 'jpeg', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_STICKER_EXTENSIONS = ['png', 'json', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1_024, 2_048, 4_096] as const satisfies readonly number[];\n\nexport type ImageExtension = (typeof ALLOWED_EXTENSIONS)[number];\nexport type StickerExtension = (typeof ALLOWED_STICKER_EXTENSIONS)[number];\nexport type ImageSize = (typeof ALLOWED_SIZES)[number];\n\nexport const OverwrittenMimeTypes = {\n\t// https://github.com/discordjs/discord.js/issues/8557\n\t'image/apng': 'image/png',\n} as const satisfies Readonly<Record<string, string>>;\n\nexport const BurstHandlerMajorIdKey = 'burst';\n","import type { InternalRequest, RawFile } from '../RequestManager.js';\n\ninterface DiscordErrorFieldInformation {\n\tcode: string;\n\tmessage: string;\n}\n\ninterface DiscordErrorGroupWrapper {\n\t_errors: DiscordError[];\n}\n\ntype DiscordError = DiscordErrorFieldInformation | DiscordErrorGroupWrapper | string | { [k: string]: DiscordError };\n\nexport interface DiscordErrorData {\n\tcode: number;\n\terrors?: DiscordError;\n\tmessage: string;\n}\n\nexport interface OAuthErrorData {\n\terror: string;\n\terror_description?: string;\n}\n\nexport interface RequestBody {\n\tfiles: RawFile[] | undefined;\n\tjson: unknown | undefined;\n}\n\nfunction isErrorGroupWrapper(error: DiscordError): error is DiscordErrorGroupWrapper {\n\treturn Reflect.has(error as Record<string, unknown>, '_errors');\n}\n\nfunction isErrorResponse(error: DiscordError): error is DiscordErrorFieldInformation {\n\treturn typeof Reflect.get(error as Record<string, unknown>, 'message') === 'string';\n}\n\n/**\n * Represents an API error returned by Discord\n */\nexport class DiscordAPIError extends Error {\n\tpublic requestBody: RequestBody;\n\n\t/**\n\t * @param rawError - The error reported by Discord\n\t * @param code - The error code reported by Discord\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic rawError: DiscordErrorData | OAuthErrorData,\n\t\tpublic code: number | string,\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(DiscordAPIError.getMessage(rawError));\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${DiscordAPIError.name}[${this.code}]`;\n\t}\n\n\tprivate static getMessage(error: DiscordErrorData | OAuthErrorData) {\n\t\tlet flattened = '';\n\t\tif ('code' in error) {\n\t\t\tif (error.errors) {\n\t\t\t\tflattened = [...this.flattenDiscordError(error.errors)].join('\\n');\n\t\t\t}\n\n\t\t\treturn error.message && flattened\n\t\t\t\t? `${error.message}\\n${flattened}`\n\t\t\t\t: error.message || flattened || 'Unknown Error';\n\t\t}\n\n\t\treturn error.error_description ?? 'No Description';\n\t}\n\n\tprivate static *flattenDiscordError(obj: DiscordError, key = ''): IterableIterator<string> {\n\t\tif (isErrorResponse(obj)) {\n\t\t\treturn yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n\t\t}\n\n\t\tfor (const [otherKey, val] of Object.entries(obj)) {\n\t\t\tconst nextKey = otherKey.startsWith('_')\n\t\t\t\t? key\n\t\t\t\t: key\n\t\t\t\t? Number.isNaN(Number(otherKey))\n\t\t\t\t\t? `${key}.${otherKey}`\n\t\t\t\t\t: `${key}[${otherKey}]`\n\t\t\t\t: otherKey;\n\n\t\t\tif (typeof val === 'string') {\n\t\t\t\tyield val;\n\t\t\t} else if (isErrorGroupWrapper(val)) {\n\t\t\t\tfor (const error of val._errors) {\n\t\t\t\t\tyield* this.flattenDiscordError(error, nextKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield* this.flattenDiscordError(val, nextKey);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { STATUS_CODES } from 'node:http';\nimport type { InternalRequest } from '../RequestManager.js';\nimport type { RequestBody } from './DiscordAPIError.js';\n\n/**\n * Represents a HTTP error\n */\nexport class HTTPError extends Error {\n\tpublic requestBody: RequestBody;\n\n\tpublic override name = HTTPError.name;\n\n\t/**\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(STATUS_CODES[status]);\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n}\n","import type { RateLimitData } from '../REST.js';\n\nexport class RateLimitError extends Error implements RateLimitData {\n\tpublic timeToReset: number;\n\n\tpublic limit: number;\n\n\tpublic method: string;\n\n\tpublic hash: string;\n\n\tpublic url: string;\n\n\tpublic route: string;\n\n\tpublic majorParameter: string;\n\n\tpublic global: boolean;\n\n\tpublic constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }: RateLimitData) {\n\t\tsuper();\n\t\tthis.timeToReset = timeToReset;\n\t\tthis.limit = limit;\n\t\tthis.method = method;\n\t\tthis.hash = hash;\n\t\tthis.url = url;\n\t\tthis.route = route;\n\t\tthis.majorParameter = majorParameter;\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${RateLimitError.name}[${this.route}]`;\n\t}\n}\n","import { Blob, Buffer } from 'node:buffer';\nimport { EventEmitter } from 'node:events';\nimport { setInterval, clearInterval } from 'node:timers';\nimport type { URLSearchParams } from 'node:url';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { DiscordSnowflake } from '@sapphire/snowflake';\nimport { FormData, type RequestInit, type BodyInit, type Dispatcher, type Agent } from 'undici';\nimport type { RESTOptions, RestEvents, RequestOptions } from './REST.js';\nimport { BurstHandler } from './handlers/BurstHandler.js';\nimport type { IHandler } from './handlers/IHandler.js';\nimport { SequentialHandler } from './handlers/SequentialHandler.js';\nimport {\n\tBurstHandlerMajorIdKey,\n\tDefaultRestOptions,\n\tDefaultUserAgent,\n\tOverwrittenMimeTypes,\n\tRESTEvents,\n} from './utils/constants.js';\nimport { resolveBody } from './utils/utils.js';\n\n// Make this a lazy dynamic import as file-type is a pure ESM package\nconst getFileType = lazy(async () => import('file-type'));\n\n/**\n * Represents a file to be added to the request\n */\nexport interface RawFile {\n\t/**\n\t * Content-Type of the file\n\t */\n\tcontentType?: string;\n\t/**\n\t * The actual data for the file\n\t */\n\tdata: Buffer | boolean | number | string;\n\t/**\n\t * An explicit key to use for key of the formdata field for this file.\n\t * When not provided, the index of the file in the files array is used in the form `files[${index}]`.\n\t * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)\n\t */\n\tkey?: string;\n\t/**\n\t * The name of the file\n\t */\n\tname: string;\n}\n\n/**\n * Represents possible data to be given to an endpoint\n */\nexport interface RequestData {\n\t/**\n\t * Whether to append JSON data to form data instead of `payload_json` when sending files\n\t */\n\tappendToFormData?: boolean;\n\t/**\n\t * If this request needs the `Authorization` header\n\t *\n\t * @defaultValue `true`\n\t */\n\tauth?: boolean;\n\t/**\n\t * The authorization prefix to use for this request, useful if you use this with bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix?: 'Bearer' | 'Bot';\n\t/**\n\t * The body to send to this request.\n\t * If providing as BodyInit, set `passThroughBody: true`\n\t */\n\tbody?: BodyInit | unknown;\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} to use for the request.\n\t */\n\tdispatcher?: Agent;\n\t/**\n\t * Files to be attached to this request\n\t */\n\tfiles?: RawFile[] | undefined;\n\t/**\n\t * Additional headers to add to this request\n\t */\n\theaders?: Record<string, string>;\n\t/**\n\t * Whether to pass-through the body property directly to `fetch()`.\n\t * <warn>This only applies when files is NOT present</warn>\n\t */\n\tpassThroughBody?: boolean;\n\t/**\n\t * Query string parameters to append to the called endpoint\n\t */\n\tquery?: URLSearchParams;\n\t/**\n\t * Reason to show in the audit logs\n\t */\n\treason?: string | undefined;\n\t/**\n\t * The signal to abort the queue entry or the REST call, where applicable\n\t */\n\tsignal?: AbortSignal | undefined;\n\t/**\n\t * If this request should be versioned\n\t *\n\t * @defaultValue `true`\n\t */\n\tversioned?: boolean;\n}\n\n/**\n * Possible headers for an API call\n */\nexport interface RequestHeaders {\n\tAuthorization?: string;\n\t'User-Agent': string;\n\t'X-Audit-Log-Reason'?: string;\n}\n\n/**\n * Possible API methods to be used when doing requests\n */\nexport enum RequestMethod {\n\tDelete = 'DELETE',\n\tGet = 'GET',\n\tPatch = 'PATCH',\n\tPost = 'POST',\n\tPut = 'PUT',\n}\n\nexport type RouteLike = `/${string}`;\n\n/**\n * Internal request options\n *\n * @internal\n */\nexport interface InternalRequest extends RequestData {\n\tfullRoute: RouteLike;\n\tmethod: RequestMethod;\n}\n\nexport type HandlerRequestData = Pick<InternalRequest, 'auth' | 'body' | 'files' | 'signal'>;\n\n/**\n * Parsed route data for an endpoint\n *\n * @internal\n */\nexport interface RouteData {\n\tbucketRoute: string;\n\tmajorParameter: string;\n\toriginal: RouteLike;\n}\n\n/**\n * Represents a hash and its associated fields\n *\n * @internal\n */\nexport interface HashData {\n\tlastAccess: number;\n\tvalue: string;\n}\n\nexport interface RequestManager {\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\n/**\n * Represents the class that manages handlers for endpoints\n */\nexport class RequestManager extends EventEmitter {\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests\n\t * performed by this manager.\n\t */\n\tpublic agent: Dispatcher | null = null;\n\n\t/**\n\t * The number of requests remaining in the global bucket\n\t */\n\tpublic globalRemaining: number;\n\n\t/**\n\t * The promise used to wait out the global rate limit\n\t */\n\tpublic globalDelay: Promise<void> | null = null;\n\n\t/**\n\t * The timestamp at which the global bucket resets\n\t */\n\tpublic globalReset = -1;\n\n\t/**\n\t * API bucket hashes that are cached from provided routes\n\t */\n\tpublic readonly hashes = new Collection<string, HashData>();\n\n\t/**\n\t * Request handlers created from the bucket hash and the major parameters\n\t */\n\tpublic readonly handlers = new Collection<string, IHandler>();\n\n\t#token: string | null = null;\n\n\tprivate hashTimer!: NodeJS.Timer;\n\n\tprivate handlerTimer!: NodeJS.Timer;\n\n\tpublic readonly options: RESTOptions;\n\n\tpublic constructor(options: Partial<RESTOptions>) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultRestOptions, ...options };\n\t\tthis.options.offset = Math.max(0, this.options.offset);\n\t\tthis.globalRemaining = this.options.globalRequestsPerSecond;\n\t\tthis.agent = options.agent ?? null;\n\n\t\t// Start sweepers\n\t\tthis.setupSweepers();\n\t}\n\n\tprivate setupSweepers() {\n\t\t// eslint-disable-next-line unicorn/consistent-function-scoping\n\t\tconst validateMaxInterval = (interval: number) => {\n\t\t\tif (interval > 14_400_000) {\n\t\t\t\tthrow new Error('Cannot set an interval greater than 4 hours');\n\t\t\t}\n\t\t};\n\n\t\tif (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.hashSweepInterval);\n\t\t\tthis.hashTimer = setInterval(() => {\n\t\t\t\tconst sweptHashes = new Collection<string, HashData>();\n\t\t\t\tconst currentDate = Date.now();\n\n\t\t\t\t// Begin sweeping hash based on lifetimes\n\t\t\t\tthis.hashes.sweep((val, key) => {\n\t\t\t\t\t// `-1` indicates a global hash\n\t\t\t\t\tif (val.lastAccess === -1) return false;\n\n\t\t\t\t\t// Check if lifetime has been exceeded\n\t\t\t\t\tconst shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n\n\t\t\t\t\t// Add hash to collection of swept hashes\n\t\t\t\t\tif (shouldSweep) {\n\t\t\t\t\t\t// Add to swept hashes\n\t\t\t\t\t\tsweptHashes.set(key, val);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit debug information\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n\n\t\t\t\t\treturn shouldSweep;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HashSweep, sweptHashes);\n\t\t\t}, this.options.hashSweepInterval).unref();\n\t\t}\n\n\t\tif (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.handlerSweepInterval);\n\t\t\tthis.handlerTimer = setInterval(() => {\n\t\t\t\tconst sweptHandlers = new Collection<string, IHandler>();\n\n\t\t\t\t// Begin sweeping handlers based on activity\n\t\t\t\tthis.handlers.sweep((val, key) => {\n\t\t\t\t\tconst { inactive } = val;\n\n\t\t\t\t\t// Collect inactive handlers\n\t\t\t\t\tif (inactive) {\n\t\t\t\t\t\tsweptHandlers.set(key, val);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Handler ${val.id} for ${key} swept due to being inactive`);\n\t\t\t\t\treturn inactive;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HandlerSweep, sweptHandlers);\n\t\t\t}, this.options.handlerSweepInterval).unref();\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this manager\n\t *\n\t * @param agent - The agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.agent = agent;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.#token = token;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t *\n\t * @param request - All the information needed to make a request\n\t * @returns The response from the api request\n\t */\n\tpublic async queueRequest(request: InternalRequest): Promise<Dispatcher.ResponseData> {\n\t\t// Generalize the endpoint to its route data\n\t\tconst routeId = RequestManager.generateRouteData(request.fullRoute, request.method);\n\t\t// Get the bucket hash for the generic route, or point to a global route otherwise\n\t\tconst hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {\n\t\t\tvalue: `Global(${request.method}:${routeId.bucketRoute})`,\n\t\t\tlastAccess: -1,\n\t\t};\n\n\t\t// Get the request handler for the obtained hash, with its major parameter\n\t\tconst handler =\n\t\t\tthis.handlers.get(`${hash.value}:${routeId.majorParameter}`) ??\n\t\t\tthis.createHandler(hash.value, routeId.majorParameter);\n\n\t\t// Resolve the request into usable fetch options\n\t\tconst { url, fetchOptions } = await this.resolveRequest(request);\n\n\t\t// Queue the request\n\t\treturn handler.queueRequest(routeId, url, fetchOptions, {\n\t\t\tbody: request.body,\n\t\t\tfiles: request.files,\n\t\t\tauth: request.auth !== false,\n\t\t\tsignal: request.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n\t *\n\t * @param hash - The hash for the route\n\t * @param majorParameter - The major parameter for this handler\n\t * @internal\n\t */\n\tprivate createHandler(hash: string, majorParameter: string) {\n\t\t// Create the async request queue to handle requests\n\t\tconst queue =\n\t\t\tmajorParameter === BurstHandlerMajorIdKey\n\t\t\t\t? new BurstHandler(this, hash, majorParameter)\n\t\t\t\t: new SequentialHandler(this, hash, majorParameter);\n\t\t// Save the queue based on its id\n\t\tthis.handlers.set(queue.id, queue);\n\n\t\treturn queue;\n\t}\n\n\t/**\n\t * Formats the request data to a usable format for fetch\n\t *\n\t * @param request - The request data\n\t */\n\tprivate async resolveRequest(request: InternalRequest): Promise<{ fetchOptions: RequestOptions; url: string }> {\n\t\tconst { options } = this;\n\n\t\tlet query = '';\n\n\t\t// If a query option is passed, use it\n\t\tif (request.query) {\n\t\t\tconst resolvedQuery = request.query.toString();\n\t\t\tif (resolvedQuery !== '') {\n\t\t\t\tquery = `?${resolvedQuery}`;\n\t\t\t}\n\t\t}\n\n\t\t// Create the required headers\n\t\tconst headers: RequestHeaders = {\n\t\t\t...this.options.headers,\n\t\t\t'User-Agent': `${DefaultUserAgent} ${options.userAgentAppendix}`.trim(),\n\t\t};\n\n\t\t// If this request requires authorization (allowing non-\"authorized\" requests for webhooks)\n\t\tif (request.auth !== false) {\n\t\t\t// If we haven't received a token, throw an error\n\t\t\tif (!this.#token) {\n\t\t\t\tthrow new Error('Expected token to be set for this request, but none was present');\n\t\t\t}\n\n\t\t\theaders.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n\t\t}\n\n\t\t// If a reason was set, set it's appropriate header\n\t\tif (request.reason?.length) {\n\t\t\theaders['X-Audit-Log-Reason'] = encodeURIComponent(request.reason);\n\t\t}\n\n\t\t// Format the full request URL (api base, optional version, endpoint, optional querystring)\n\t\tconst url = `${options.api}${request.versioned === false ? '' : `/v${options.version}`}${\n\t\t\trequest.fullRoute\n\t\t}${query}`;\n\n\t\tlet finalBody: RequestInit['body'];\n\t\tlet additionalHeaders: Record<string, string> = {};\n\n\t\tif (request.files?.length) {\n\t\t\tconst formData = new FormData();\n\n\t\t\t// Attach all files to the request\n\t\t\tfor (const [index, file] of request.files.entries()) {\n\t\t\t\tconst fileKey = file.key ?? `files[${index}]`;\n\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/FormData/append#parameters\n\t\t\t\t// FormData.append only accepts a string or Blob.\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob#parameters\n\t\t\t\t// The Blob constructor accepts TypedArray/ArrayBuffer, strings, and Blobs.\n\t\t\t\tif (Buffer.isBuffer(file.data)) {\n\t\t\t\t\t// Try to infer the content type from the buffer if one isn't passed\n\t\t\t\t\tconst { fileTypeFromBuffer } = await getFileType();\n\t\t\t\t\tlet contentType = file.contentType;\n\t\t\t\t\tif (!contentType) {\n\t\t\t\t\t\tconst parsedType = (await fileTypeFromBuffer(file.data))?.mime;\n\t\t\t\t\t\tif (parsedType) {\n\t\t\t\t\t\t\tcontentType = OverwrittenMimeTypes[parsedType as keyof typeof OverwrittenMimeTypes] ?? parsedType;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tformData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);\n\t\t\t\t} else {\n\t\t\t\t\tformData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a JSON body was added as well, attach it to the form data, using payload_json unless otherwise specified\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (request.body != null) {\n\t\t\t\tif (request.appendToFormData) {\n\t\t\t\t\tfor (const [key, value] of Object.entries(request.body as Record<string, unknown>)) {\n\t\t\t\t\t\tformData.append(key, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tformData.append('payload_json', JSON.stringify(request.body));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the final body to the form data\n\t\t\tfinalBody = formData;\n\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t} else if (request.body != null) {\n\t\t\tif (request.passThroughBody) {\n\t\t\t\tfinalBody = request.body as BodyInit;\n\t\t\t} else {\n\t\t\t\t// Stringify the JSON data\n\t\t\t\tfinalBody = JSON.stringify(request.body);\n\t\t\t\t// Set the additional headers to specify the content-type\n\t\t\t\tadditionalHeaders = { 'Content-Type': 'application/json' };\n\t\t\t}\n\t\t}\n\n\t\tfinalBody = await resolveBody(finalBody);\n\n\t\tconst fetchOptions: RequestOptions = {\n\t\t\theaders: { ...request.headers, ...additionalHeaders, ...headers } as Record<string, string>,\n\t\t\tmethod: request.method.toUpperCase() as Dispatcher.HttpMethod,\n\t\t};\n\n\t\tif (finalBody !== undefined) {\n\t\t\tfetchOptions.body = finalBody as Exclude<RequestOptions['body'], undefined>;\n\t\t}\n\n\t\t// Prioritize setting an agent per request, use the agent for this instance otherwise.\n\t\tfetchOptions.dispatcher = request.dispatcher ?? this.agent ?? undefined!;\n\n\t\treturn { url, fetchOptions };\n\t}\n\n\t/**\n\t * Stops the hash sweeping interval\n\t */\n\tpublic clearHashSweeper() {\n\t\tclearInterval(this.hashTimer);\n\t}\n\n\t/**\n\t * Stops the request handler sweeping interval\n\t */\n\tpublic clearHandlerSweeper() {\n\t\tclearInterval(this.handlerTimer);\n\t}\n\n\t/**\n\t * Generates route data for an endpoint:method\n\t *\n\t * @param endpoint - The raw endpoint to generalize\n\t * @param method - The HTTP method this endpoint is called without\n\t * @internal\n\t */\n\tprivate static generateRouteData(endpoint: RouteLike, method: RequestMethod): RouteData {\n\t\tif (endpoint.startsWith('/interactions/') && endpoint.endsWith('/callback')) {\n\t\t\treturn {\n\t\t\t\tmajorParameter: BurstHandlerMajorIdKey,\n\t\t\t\tbucketRoute: '/interactions/:id/:token/callback',\n\t\t\t\toriginal: endpoint,\n\t\t\t};\n\t\t}\n\n\t\tconst majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{17,19})/.exec(endpoint);\n\n\t\t// Get the major id for this route - global otherwise\n\t\tconst majorId = majorIdMatch?.[1] ?? 'global';\n\n\t\tconst baseRoute = endpoint\n\t\t\t// Strip out all ids\n\t\t\t.replaceAll(/\\d{17,19}/g, ':id')\n\t\t\t// Strip out reaction as they fall under the same bucket\n\t\t\t.replace(/\\/reactions\\/(.*)/, '/reactions/:reaction');\n\n\t\tlet exceptions = '';\n\n\t\t// Hard-Code Old Message Deletion Exception (2 week+ old messages are a different bucket)\n\t\t// https://github.com/discord/discord-api-docs/issues/1295\n\t\tif (method === RequestMethod.Delete && baseRoute === '/channels/:id/messages/:id') {\n\t\t\tconst id = /\\d{17,19}$/.exec(endpoint)![0]!;\n\t\t\tconst timestamp = DiscordSnowflake.timestampFrom(id);\n\t\t\tif (Date.now() - timestamp > 1_000 * 60 * 60 * 24 * 14) {\n\t\t\t\texceptions += '/Delete Old Message';\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmajorParameter: majorId,\n\t\t\tbucketRoute: baseRoute + exceptions,\n\t\t\toriginal: endpoint,\n\t\t};\n\t}\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport type { Dispatcher } from 'undici';\nimport type { RequestOptions } from '../REST.js';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport { onRateLimit, parseHeader } from '../utils/utils.js';\nimport type { IHandler } from './IHandler.js';\nimport { handleErrors, incrementInvalidCount, makeNetworkRequest } from './Shared.js';\n\n/**\n * The structure used to handle burst requests for a given bucket.\n * Burst requests have no ratelimit handling but allow for pre- and post-processing\n * of data in the same manner as sequentially queued requests.\n *\n * @remarks\n * This queue may still emit a rate limit error if an unexpected 429 is hit\n */\nexport class BurstHandler implements IHandler {\n\t/**\n\t * {@inheritdoc IHandler.id}\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * {@inheritDoc IHandler.inactive}\n\t */\n\tpublic inactive = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: RequestManager,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.queueRequest}\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t): Promise<Dispatcher.ResponseData> {\n\t\treturn this.runRequest(routeId, url, options, requestData);\n\t}\n\n\t/**\n\t * The method that actually makes the request to the API, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized API route with literal ids for major parameters\n\t * @param url - The fully resolved URL to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<Dispatcher.ResponseData> {\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n\n\t\t// Retry requested\n\t\tif (res === null) {\n\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t}\n\n\t\tconst status = res.statusCode;\n\t\tlet retryAfter = 0;\n\t\tconst retry = parseHeader(res.headers['retry-after']);\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1_000 + this.manager.options.offset;\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tincrementInvalidCount(this.manager);\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// Unexpected ratelimit\n\t\t\tconst isGlobal = res.headers['x-ratelimit-global'] !== undefined;\n\t\t\tawait onRateLimit(this.manager, {\n\t\t\t\ttimeToReset: retryAfter,\n\t\t\t\tlimit: Number.POSITIVE_INFINITY,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${Number.POSITIVE_INFINITY}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : None`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\n\t\t\t// We are bypassing all other limits, but an encountered limit should be respected (it's probably a non-punished rate limit anyways)\n\t\t\tawait sleep(retryAfter);\n\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else {\n\t\t\tconst handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n\t\t\tif (handled === null) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\treturn handled;\n\t\t}\n\t}\n}\n","import { Blob, Buffer } from 'node:buffer';\nimport { URLSearchParams } from 'node:url';\nimport { types } from 'node:util';\nimport type { RESTPatchAPIChannelJSONBody } from 'discord-api-types/v10';\nimport { FormData, type Dispatcher, type RequestInit } from 'undici';\nimport type { RateLimitData, RequestOptions } from '../REST.js';\nimport { type RequestManager, RequestMethod } from '../RequestManager.js';\nimport { RateLimitError } from '../errors/RateLimitError.js';\n\nexport function parseHeader(header: string[] | string | undefined): string | undefined {\n\tif (header === undefined || typeof header === 'string') {\n\t\treturn header;\n\t}\n\n\treturn header.join(';');\n}\n\nfunction serializeSearchParam(value: unknown): string | null {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\treturn value;\n\t\tcase 'number':\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\t\treturn value.toString();\n\t\tcase 'object':\n\t\t\tif (value === null) return null;\n\t\t\tif (value instanceof Date) {\n\t\t\t\treturn Number.isNaN(value.getTime()) ? null : value.toISOString();\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) return value.toString();\n\t\t\treturn null;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Creates and populates an URLSearchParams instance from an object, stripping\n * out null and undefined values, while also coercing non-strings to strings.\n *\n * @param options - The options to use\n * @returns A populated URLSearchParams instance\n */\nexport function makeURLSearchParams<T extends object>(options?: Readonly<T>) {\n\tconst params = new URLSearchParams();\n\tif (!options) return params;\n\n\tfor (const [key, value] of Object.entries(options)) {\n\t\tconst serialized = serializeSearchParam(value);\n\t\tif (serialized !== null) params.append(key, serialized);\n\t}\n\n\treturn params;\n}\n\n/**\n * Converts the response to usable data\n *\n * @param res - The fetch response\n */\nexport async function parseResponse(res: Dispatcher.ResponseData): Promise<unknown> {\n\tconst header = parseHeader(res.headers['content-type']);\n\tif (header?.startsWith('application/json')) {\n\t\treturn res.body.json();\n\t}\n\n\treturn res.body.arrayBuffer();\n}\n\n/**\n * Check whether a request falls under a sublimit\n *\n * @param bucketRoute - The buckets route identifier\n * @param body - The options provided as JSON data\n * @param method - The HTTP method that will be used to make the request\n * @returns Whether the request falls under a sublimit\n */\nexport function hasSublimit(bucketRoute: string, body?: unknown, method?: string): boolean {\n\t// TODO: Update for new sublimits\n\t// Currently known sublimits:\n\t// Editing channel `name` or `topic`\n\tif (bucketRoute === '/channels/:id') {\n\t\tif (typeof body !== 'object' || body === null) return false;\n\t\t// This should never be a POST body, but just in case\n\t\tif (method !== RequestMethod.Patch) return false;\n\t\tconst castedBody = body as RESTPatchAPIChannelJSONBody;\n\t\treturn ['name', 'topic'].some((key) => Reflect.has(castedBody, key));\n\t}\n\n\t// If we are checking if a request has a sublimit on a route not checked above, sublimit all requests to avoid a flood of 429s\n\treturn true;\n}\n\nexport async function resolveBody(body: RequestInit['body']): Promise<RequestOptions['body']> {\n\t// eslint-disable-next-line no-eq-null, eqeqeq\n\tif (body == null) {\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\treturn body;\n\t} else if (types.isUint8Array(body)) {\n\t\treturn body;\n\t} else if (types.isArrayBuffer(body)) {\n\t\treturn new Uint8Array(body);\n\t} else if (body instanceof URLSearchParams) {\n\t\treturn body.toString();\n\t} else if (body instanceof DataView) {\n\t\treturn new Uint8Array(body.buffer);\n\t} else if (body instanceof Blob) {\n\t\treturn new Uint8Array(await body.arrayBuffer());\n\t} else if (body instanceof FormData) {\n\t\treturn body;\n\t} else if ((body as Iterable<Uint8Array>)[Symbol.iterator]) {\n\t\tconst chunks = [...(body as Iterable<Uint8Array>)];\n\t\tconst length = chunks.reduce((a, b) => a + b.length, 0);\n\n\t\tconst uint8 = new Uint8Array(length);\n\t\tlet lengthUsed = 0;\n\n\t\treturn chunks.reduce((a, b) => {\n\t\t\ta.set(b, lengthUsed);\n\t\t\tlengthUsed += b.length;\n\t\t\treturn a;\n\t\t}, uint8);\n\t} else if ((body as AsyncIterable<Uint8Array>)[Symbol.asyncIterator]) {\n\t\tconst chunks: Uint8Array[] = [];\n\n\t\tfor await (const chunk of body as AsyncIterable<Uint8Array>) {\n\t\t\tchunks.push(chunk);\n\t\t}\n\n\t\treturn Buffer.concat(chunks);\n\t}\n\n\tthrow new TypeError(`Unable to resolve body.`);\n}\n\n/**\n * Check whether an error indicates that a retry can be attempted\n *\n * @param error - The error thrown by the network request\n * @returns Whether the error indicates a retry should be attempted\n */\nexport function shouldRetry(error: Error | NodeJS.ErrnoException) {\n\t// Retry for possible timed out requests\n\tif (error.name === 'AbortError') return true;\n\t// Downlevel ECONNRESET to retry as it may be recoverable\n\treturn ('code' in error && error.code === 'ECONNRESET') || error.message.includes('ECONNRESET');\n}\n\n/**\n * Determines whether the request should be queued or whether a RateLimitError should be thrown\n *\n * @internal\n */\nexport async function onRateLimit(manager: RequestManager, rateLimitData: RateLimitData) {\n\tconst { options } = manager;\n\tif (!options.rejectOnRateLimit) return;\n\n\tconst shouldThrow =\n\t\ttypeof options.rejectOnRateLimit === 'function'\n\t\t\t? await options.rejectOnRateLimit(rateLimitData)\n\t\t\t: options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));\n\tif (shouldThrow) {\n\t\tthrow new RateLimitError(rateLimitData);\n\t}\n}\n","import { setTimeout, clearTimeout } from 'node:timers';\nimport { request, type Dispatcher } from 'undici';\nimport type { RequestOptions } from '../REST.js';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager.js';\nimport type { DiscordErrorData, OAuthErrorData } from '../errors/DiscordAPIError.js';\nimport { DiscordAPIError } from '../errors/DiscordAPIError.js';\nimport { HTTPError } from '../errors/HTTPError.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport { parseResponse, shouldRetry } from '../utils/utils.js';\nimport type { PolyFillAbortSignal } from './IHandler.js';\n\n/**\n * Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime: number | null = null;\n\n/**\n * Increment the invalid request count and emit warning if necessary\n *\n * @internal\n */\nexport function incrementInvalidCount(manager: RequestManager) {\n\tif (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n\t\tinvalidCountResetTime = Date.now() + 1_000 * 60 * 10;\n\t\tinvalidCount = 0;\n\t}\n\n\tinvalidCount++;\n\n\tconst emitInvalid =\n\t\tmanager.options.invalidRequestWarningInterval > 0 &&\n\t\tinvalidCount % manager.options.invalidRequestWarningInterval === 0;\n\tif (emitInvalid) {\n\t\t// Let library users know periodically about invalid requests\n\t\tmanager.emit(RESTEvents.InvalidRequestWarning, {\n\t\t\tcount: invalidCount,\n\t\t\tremainingTime: invalidCountResetTime - Date.now(),\n\t\t});\n\t}\n}\n\n/**\n * Performs the actual network request for a request handler\n *\n * @param manager - The manager that holds options and emits informational events\n * @param routeId - The generalized api route with literal ids for major parameters\n * @param url - The fully resolved url to make the request to\n * @param options - The fetch options needed to make the request\n * @param requestData - Extra data from the user's request needed for errors and additional processing\n * @param retries - The number of retries this request has already attempted (recursion occurs on the handler)\n * @returns The respond from the network or `null` when the request should be retried\n * @internal\n */\nexport async function makeNetworkRequest(\n\tmanager: RequestManager,\n\trouteId: RouteData,\n\turl: string,\n\toptions: RequestOptions,\n\trequestData: HandlerRequestData,\n\tretries: number,\n) {\n\tconst controller = new AbortController();\n\tconst timeout = setTimeout(() => controller.abort(), manager.options.timeout).unref();\n\tif (requestData.signal) {\n\t\t// The type polyfill is required because Node.js's types are incomplete.\n\t\tconst signal = requestData.signal as unknown as PolyFillAbortSignal;\n\t\t// If the user signal was aborted, abort the controller, else abort the local signal.\n\t\t// The reason why we don't re-use the user's signal, is because users may use the same signal for multiple\n\t\t// requests, and we do not want to cause unexpected side-effects.\n\t\tif (signal.aborted) controller.abort();\n\t\telse signal.addEventListener('abort', () => controller.abort());\n\t}\n\n\tlet res: Dispatcher.ResponseData;\n\ttry {\n\t\tres = await request(url, { ...options, signal: controller.signal });\n\t} catch (error: unknown) {\n\t\tif (!(error instanceof Error)) throw error;\n\t\t// Retry the specified number of times if needed\n\t\tif (shouldRetry(error) && retries !== manager.options.retries) {\n\t\t\t// Retry is handled by the handler upon receiving null\n\t\t\treturn null;\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tclearTimeout(timeout);\n\t}\n\n\tif (manager.listenerCount(RESTEvents.Response)) {\n\t\tmanager.emit(\n\t\t\tRESTEvents.Response,\n\t\t\t{\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\tpath: routeId.original,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\toptions,\n\t\t\t\tdata: requestData,\n\t\t\t\tretries,\n\t\t\t},\n\t\t\t{ ...res },\n\t\t);\n\t}\n\n\treturn res;\n}\n\n/**\n * Handles 5xx and 4xx errors (not 429's) conventionally. 429's should be handled before calling this function\n *\n * @param manager - The manager that holds options and emits informational events\n * @param res - The response received from {@link makeNetworkRequest}\n * @param method - The method used to make the request\n * @param url - The fully resolved url to make the request to\n * @param requestData - Extra data from the user's request needed for errors and additional processing\n * @param retries - The number of retries this request has already attempted (recursion occurs on the handler)\n * @returns - The response if the status code is not handled or null to request a retry\n */\nexport async function handleErrors(\n\tmanager: RequestManager,\n\tres: Dispatcher.ResponseData,\n\tmethod: string,\n\turl: string,\n\trequestData: HandlerRequestData,\n\tretries: number,\n) {\n\tconst status = res.statusCode;\n\tif (status >= 500 && status < 600) {\n\t\t// Retry the specified number of times for possible server side issues\n\t\tif (retries !== manager.options.retries) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// We are out of retries, throw an error\n\t\tthrow new HTTPError(status, method, url, requestData);\n\t} else {\n\t\t// Handle possible malformed requests\n\t\tif (status >= 400 && status < 500) {\n\t\t\t// If we receive this status code, it means the token we had is no longer valid.\n\t\t\tif (status === 401 && requestData.auth) {\n\t\t\t\tmanager.setToken(null!);\n\t\t\t}\n\n\t\t\t// The request will not succeed for some reason, parse the error returned from the api\n\t\t\tconst data = (await parseResponse(res)) as DiscordErrorData | OAuthErrorData;\n\t\t\t// throw the API error\n\t\t\tthrow new DiscordAPIError(data, 'code' in data ? data.code : data.error, status, method, url, requestData);\n\t\t}\n\n\t\treturn res;\n\t}\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport type { Dispatcher } from 'undici';\nimport type { RateLimitData, RequestOptions } from '../REST.js';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport { hasSublimit, onRateLimit, parseHeader } from '../utils/utils.js';\nimport type { IHandler } from './IHandler.js';\nimport { handleErrors, incrementInvalidCount, makeNetworkRequest } from './Shared.js';\n\nconst enum QueueType {\n\tStandard,\n\tSublimit,\n}\n\n/**\n * The structure used to handle sequential requests for a given bucket\n */\nexport class SequentialHandler implements IHandler {\n\t/**\n\t * {@inheritDoc IHandler.id}\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * The time this rate limit bucket will reset\n\t */\n\tprivate reset = -1;\n\n\t/**\n\t * The remaining requests that can be made before we are rate limited\n\t */\n\tprivate remaining = 1;\n\n\t/**\n\t * The total number of requests that can be made before we are rate limited\n\t */\n\tprivate limit = Number.POSITIVE_INFINITY;\n\n\t/**\n\t * The interface used to sequence async requests sequentially\n\t */\n\t#asyncQueue = new AsyncQueue();\n\n\t/**\n\t * The interface used to sequence sublimited async requests sequentially\n\t */\n\t#sublimitedQueue: AsyncQueue | null = null;\n\n\t/**\n\t * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n\t */\n\t#sublimitPromise: { promise: Promise<void>; resolve(): void } | null = null;\n\n\t/**\n\t * Whether the sublimit queue needs to be shifted in the finally block\n\t */\n\t#shiftSublimit = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: RequestManager,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.inactive}\n\t */\n\tpublic get inactive(): boolean {\n\t\treturn (\n\t\t\tthis.#asyncQueue.remaining === 0 &&\n\t\t\t(this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) &&\n\t\t\t!this.limited\n\t\t);\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by the global limit\n\t */\n\tprivate get globalLimited(): boolean {\n\t\treturn this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by its limit\n\t */\n\tprivate get localLimited(): boolean {\n\t\treturn this.remaining <= 0 && Date.now() < this.reset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited\n\t */\n\tprivate get limited(): boolean {\n\t\treturn this.globalLimited || this.localLimited;\n\t}\n\n\t/**\n\t * The time until queued requests can continue\n\t */\n\tprivate get timeToReset(): number {\n\t\treturn this.reset + this.manager.options.offset - Date.now();\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * Delay all requests for the specified amount of time, handling global rate limits\n\t *\n\t * @param time - The amount of time to delay all requests for\n\t */\n\tprivate async globalDelayFor(time: number): Promise<void> {\n\t\tawait sleep(time);\n\t\tthis.manager.globalDelay = null;\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.queueRequest}\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t): Promise<Dispatcher.ResponseData> {\n\t\tlet queue = this.#asyncQueue;\n\t\tlet queueType = QueueType.Standard;\n\t\t// Separate sublimited requests when already sublimited\n\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\tqueueType = QueueType.Sublimit;\n\t\t}\n\n\t\t// Wait for any previous requests to be completed before this one is run\n\t\tawait queue.wait({ signal: requestData.signal });\n\t\t// This set handles retroactively sublimiting requests\n\t\tif (queueType === QueueType.Standard) {\n\t\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\t\t/**\n\t\t\t\t * Remove the request from the standard queue, it should never be possible to get here while processing the\n\t\t\t\t * sublimit queue so there is no need to worry about shifting the wrong request\n\t\t\t\t */\n\t\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\t\tconst wait = queue.wait();\n\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\tawait wait;\n\t\t\t} else if (this.#sublimitPromise) {\n\t\t\t\t// Stall requests while the sublimit queue gets processed\n\t\t\t\tawait this.#sublimitPromise.promise;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Make the request, and return the results\n\t\t\treturn await this.runRequest(routeId, url, options, requestData);\n\t\t} finally {\n\t\t\t// Allow the next request to fire\n\t\t\tqueue.shift();\n\t\t\tif (this.#shiftSublimit) {\n\t\t\t\tthis.#shiftSublimit = false;\n\t\t\t\tthis.#sublimitedQueue?.shift();\n\t\t\t}\n\n\t\t\t// If this request is the last request in a sublimit\n\t\t\tif (this.#sublimitedQueue?.remaining === 0) {\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitedQueue = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The method that actually makes the request to the api, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized api route with literal ids for major parameters\n\t * @param url - The fully resolved url to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<Dispatcher.ResponseData> {\n\t\t/*\n\t\t * After calculations have been done, pre-emptively stop further requests\n\t\t * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n\t\t */\n\t\twhile (this.limited) {\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\t\t\tlet delay: Promise<void>;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t\t// If this is the first task to reach the global timeout, set the global delay\n\t\t\t\tif (!this.manager.globalDelay) {\n\t\t\t\t\t// The global delay function clears the global delay state when it is resolved\n\t\t\t\t\tthis.manager.globalDelay = this.globalDelayFor(timeout);\n\t\t\t\t}\n\n\t\t\t\tdelay = this.manager.globalDelay;\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t\tdelay = sleep(timeout);\n\t\t\t}\n\n\t\t\tconst rateLimitData: RateLimitData = {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t};\n\t\t\t// Let library users know they have hit a rate limit\n\t\t\tthis.manager.emit(RESTEvents.RateLimited, rateLimitData);\n\t\t\t// Determine whether a RateLimitError should be thrown\n\t\t\tawait onRateLimit(this.manager, rateLimitData);\n\t\t\t// When not erroring, emit debug for what is happening\n\t\t\tif (isGlobal) {\n\t\t\t\tthis.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Waiting ${timeout}ms for rate limit to pass`);\n\t\t\t}\n\n\t\t\t// Wait the remaining time left before the rate limit resets\n\t\t\tawait delay;\n\t\t}\n\n\t\t// As the request goes out, update the global usage information\n\t\tif (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n\t\t\tthis.manager.globalReset = Date.now() + 1_000;\n\t\t\tthis.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n\t\t}\n\n\t\tthis.manager.globalRemaining--;\n\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n\n\t\t// Retry requested\n\t\tif (res === null) {\n\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t}\n\n\t\tconst status = res.statusCode;\n\t\tlet retryAfter = 0;\n\n\t\tconst limit = parseHeader(res.headers['x-ratelimit-limit']);\n\t\tconst remaining = parseHeader(res.headers['x-ratelimit-remaining']);\n\t\tconst reset = parseHeader(res.headers['x-ratelimit-reset-after']);\n\t\tconst hash = parseHeader(res.headers['x-ratelimit-bucket']);\n\t\tconst retry = parseHeader(res.headers['retry-after']);\n\n\t\t// Update the total number of requests that can be made before the rate limit resets\n\t\tthis.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n\t\t// Update the number of remaining requests that can be made before the rate limit resets\n\t\tthis.remaining = remaining ? Number(remaining) : 1;\n\t\t// Update the time when this rate limit resets (reset-after is in seconds)\n\t\tthis.reset = reset ? Number(reset) * 1_000 + Date.now() + this.manager.options.offset : Date.now();\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1_000 + this.manager.options.offset;\n\n\t\t// Handle buckets via the hash header retroactively\n\t\tif (hash && hash !== this.hash) {\n\t\t\t// Let library users know when rate limit buckets have been updated\n\t\t\tthis.debug(['Received bucket hash update', `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join('\\n'));\n\t\t\t// This queue will eventually be eliminated via attrition\n\t\t\tthis.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });\n\t\t} else if (hash) {\n\t\t\t// Handle the case where hash value doesn't change\n\t\t\t// Fetch the hash data from the manager\n\t\t\tconst hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n\n\t\t\t// When fetched, update the last access of the hash\n\t\t\tif (hashData) {\n\t\t\t\thashData.lastAccess = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t// Handle retryAfter, which means we have actually hit a rate limit\n\t\tlet sublimitTimeout: number | null = null;\n\t\tif (retryAfter > 0) {\n\t\t\tif (res.headers['x-ratelimit-global'] !== undefined) {\n\t\t\t\tthis.manager.globalRemaining = 0;\n\t\t\t\tthis.manager.globalReset = Date.now() + retryAfter;\n\t\t\t} else if (!this.localLimited) {\n\t\t\t\t/*\n\t\t\t\t * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n\t\t\t\t * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n\t\t\t\t * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n\t\t\t\t */\n\t\t\t\tsublimitTimeout = retryAfter;\n\t\t\t}\n\t\t}\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tincrementInvalidCount(this.manager);\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// A rate limit was hit - this may happen if the route isn't associated with an official bucket hash yet, or when first globally rate limited\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t}\n\n\t\t\tawait onRateLimit(this.manager, {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal.toString()}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${limit}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\t\t\t// If caused by a sublimit, wait it out here so other requests on the route can be handled\n\t\t\tif (sublimitTimeout) {\n\t\t\t\t// Normally the sublimit queue will not exist, however, if a sublimit is hit while in the sublimit queue, it will\n\t\t\t\tconst firstSublimit = !this.#sublimitedQueue;\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\tthis.#sublimitedQueue = new AsyncQueue();\n\t\t\t\t\tvoid this.#sublimitedQueue.wait();\n\t\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\t}\n\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitPromise = null;\n\t\t\t\tawait sleep(sublimitTimeout);\n\t\t\t\tlet resolve: () => void;\n\t\t\t\t// eslint-disable-next-line promise/param-names, no-promise-executor-return\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis.#sublimitPromise = { promise, resolve: resolve! };\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\t// Re-queue this request so it can be shifted by the finally\n\t\t\t\t\tawait this.#asyncQueue.wait();\n\t\t\t\t\tthis.#shiftSublimit = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else {\n\t\t\tconst handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n\t\t\tif (handled === null) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\treturn handled;\n\t\t}\n\t}\n}\n","import { EventEmitter } from 'node:events';\nimport type { Collection } from '@discordjs/collection';\nimport type { request, Dispatcher } from 'undici';\nimport { CDN } from './CDN.js';\nimport {\n\tRequestManager,\n\tRequestMethod,\n\ttype HashData,\n\ttype HandlerRequestData,\n\ttype InternalRequest,\n\ttype RequestData,\n\ttype RouteLike,\n} from './RequestManager.js';\nimport type { IHandler } from './handlers/IHandler.js';\nimport { DefaultRestOptions, RESTEvents } from './utils/constants.js';\nimport { parseResponse } from './utils/utils.js';\n\n/**\n * Options to be passed when creating the REST instance\n */\nexport interface RESTOptions {\n\t/**\n\t * The agent to set globally\n\t */\n\tagent: Dispatcher;\n\t/**\n\t * The base api path, without version\n\t *\n\t * @defaultValue `'https://discord.com/api'`\n\t */\n\tapi: string;\n\t/**\n\t * The authorization prefix to use for requests, useful if you want to use\n\t * bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix: 'Bearer' | 'Bot';\n\t/**\n\t * The cdn path\n\t *\n\t * @defaultValue 'https://cdn.discordapp.com'\n\t */\n\tcdn: string;\n\t/**\n\t * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)\n\t *\n\t * @defaultValue `50`\n\t */\n\tglobalRequestsPerSecond: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)\n\t *\n\t * @defaultValue `3_600_000`\n\t */\n\thandlerSweepInterval: number;\n\t/**\n\t * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)\n\t *\n\t * @defaultValue `86_400_000`\n\t */\n\thashLifetime: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)\n\t *\n\t * @defaultValue `14_400_000`\n\t */\n\thashSweepInterval: number;\n\t/**\n\t * Additional headers to send for all API requests\n\t *\n\t * @defaultValue `{}`\n\t */\n\theaders: Record<string, string>;\n\t/**\n\t * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).\n\t * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.\n\t *\n\t * @defaultValue `0`\n\t */\n\tinvalidRequestWarningInterval: number;\n\t/**\n\t * The extra offset to add to rate limits in milliseconds\n\t *\n\t * @defaultValue `50`\n\t */\n\toffset: number;\n\t/**\n\t * Determines how rate limiting and pre-emptive throttling should be handled.\n\t * When an array of strings, each element is treated as a prefix for the request route\n\t * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)\n\t * for which to throw {@link RateLimitError}s. All other request routes will be queued normally\n\t *\n\t * @defaultValue `null`\n\t */\n\trejectOnRateLimit: RateLimitQueueFilter | string[] | null;\n\t/**\n\t * The number of retries for errors with the 500 code, or errors\n\t * that timeout\n\t *\n\t * @defaultValue `3`\n\t */\n\tretries: number;\n\t/**\n\t * The time to wait in milliseconds before a request is aborted\n\t *\n\t * @defaultValue `15_000`\n\t */\n\ttimeout: number;\n\t/**\n\t * Extra information to add to the user agent\n\t *\n\t * @defaultValue DefaultUserAgentAppendix\n\t */\n\tuserAgentAppendix: string;\n\t/**\n\t * The version of the API to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\n/**\n * Data emitted on `RESTEvents.RateLimited`\n */\nexport interface RateLimitData {\n\t/**\n\t * Whether the rate limit that was reached was the global limit\n\t */\n\tglobal: boolean;\n\t/**\n\t * The bucket hash for this request\n\t */\n\thash: string;\n\t/**\n\t * The amount of requests we can perform before locking requests\n\t */\n\tlimit: number;\n\t/**\n\t * The major parameter of the route\n\t *\n\t * For example, in `/channels/x`, this will be `x`.\n\t * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.\n\t */\n\tmajorParameter: string;\n\t/**\n\t * The HTTP method being performed\n\t */\n\tmethod: string;\n\t/**\n\t * The route being hit in this request\n\t */\n\troute: string;\n\t/**\n\t * The time, in milliseconds, until the request-lock is reset\n\t */\n\ttimeToReset: number;\n\t/**\n\t * The full URL for this request\n\t */\n\turl: string;\n}\n\n/**\n * A function that determines whether the rate limit hit should throw an Error\n */\nexport type RateLimitQueueFilter = (rateLimitData: RateLimitData) => Promise<boolean> | boolean;\n\nexport interface APIRequest {\n\t/**\n\t * The data that was used to form the body of this request\n\t */\n\tdata: HandlerRequestData;\n\t/**\n\t * The HTTP method used in this request\n\t */\n\tmethod: string;\n\t/**\n\t * Additional HTTP options for this request\n\t */\n\toptions: RequestOptions;\n\t/**\n\t * The full path used to make the request\n\t */\n\tpath: RouteLike;\n\t/**\n\t * The number of times this request has been attempted\n\t */\n\tretries: number;\n\t/**\n\t * The API route identifying the ratelimit for this request\n\t */\n\troute: string;\n}\n\nexport interface InvalidRequestWarningData {\n\t/**\n\t * Number of invalid requests that have been made in the window\n\t */\n\tcount: number;\n\t/**\n\t * Time in milliseconds remaining before the count resets\n\t */\n\tremainingTime: number;\n}\n\nexport interface RestEvents {\n\thandlerSweep: [sweptHandlers: Collection<string, IHandler>];\n\thashSweep: [sweptHashes: Collection<string, HashData>];\n\tinvalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];\n\tnewListener: [name: string, listener: (...args: any) => void];\n\trateLimited: [rateLimitInfo: RateLimitData];\n\tremoveListener: [name: string, listener: (...args: any) => void];\n\tresponse: [request: APIRequest, response: Dispatcher.ResponseData];\n\trestDebug: [info: string];\n}\n\nexport interface REST {\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\nexport type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;\n\nexport class REST extends EventEmitter {\n\tpublic readonly cdn: CDN;\n\n\tpublic readonly requestManager: RequestManager;\n\n\tpublic constructor(options: Partial<RESTOptions> = {}) {\n\t\tsuper();\n\t\tthis.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n\t\tthis.requestManager = new RequestManager(options)\n\t\t\t.on(RESTEvents.Debug, this.emit.bind(this, RESTEvents.Debug))\n\t\t\t.on(RESTEvents.RateLimited, this.emit.bind(this, RESTEvents.RateLimited))\n\t\t\t.on(RESTEvents.InvalidRequestWarning, this.emit.bind(this, RESTEvents.InvalidRequestWarning))\n\t\t\t.on(RESTEvents.HashSweep, this.emit.bind(this, RESTEvents.HashSweep));\n\n\t\tthis.on('newListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.on(name, listener);\n\t\t});\n\t\tthis.on('removeListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.off(name, listener);\n\t\t});\n\t}\n\n\t/**\n\t * Gets the agent set for this instance\n\t */\n\tpublic getAgent() {\n\t\treturn this.requestManager.agent;\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this instance\n\t *\n\t * @param agent - Sets the agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.requestManager.setAgent(agent);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.requestManager.setToken(token);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs a get request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async get(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Get });\n\t}\n\n\t/**\n\t * Runs a delete request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async delete(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Delete });\n\t}\n\n\t/**\n\t * Runs a post request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async post(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Post });\n\t}\n\n\t/**\n\t * Runs a put request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async put(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Put });\n\t}\n\n\t/**\n\t * Runs a patch request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async patch(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Patch });\n\t}\n\n\t/**\n\t * Runs a request from the api\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async request(options: InternalRequest) {\n\t\tconst response = await this.raw(options);\n\t\treturn parseResponse(response);\n\t}\n\n\t/**\n\t * Runs a request from the API, yielding the raw Response object\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async raw(options: InternalRequest) {\n\t\treturn this.requestManager.queueRequest(options);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}