{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\n\n/**\n * Manages API methods for thread-based channels and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {TextChannel|NewsChannel|ForumChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]\n   * The type of thread to create.\n   * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}\n   * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * {@link ChannelType.AnnouncementThread}</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * Options for fetching multiple threads.\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] Options used to fetch archived threads\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads|FetchedThreadsMore)>}\n   * {@link FetchedThreads} if active & {@link FetchedThreadsMore} if archived.\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    let {\n      cache,\n      force\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, {\n      cache,\n      force\n    });\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`\n   * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date\n   * or Snowflake\n   * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * Data returned from fetching multiple threads.\n   * @typedef {FetchedThreads} FetchedThreadsMore\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreadsMore>}\n   */\n  async fetchArchived() {\n    let {\n      type = 'public',\n      fetchAll = false,\n      before,\n      limit\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let path = Routes.channelThreads(this.channel.id, type);\n    if (type === 'private' && !fetchAll) {\n      path = Routes.channelJoinedArchivedThreads(this.channel.id);\n    }\n    let timestamp;\n    let id;\n    const query = makeURLSearchParams({\n      limit\n    });\n    if (before !== undefined) {\n      if (before instanceof ThreadChannel || /^\\d{17,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n        const toUse = type === 'private' && !fetchAll ? id : timestamp;\n        if (toUse) {\n          query.set('before', toUse);\n        }\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n          if (type === 'public' || fetchAll) {\n            query.set('before', timestamp);\n          }\n        } catch {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n    const raw = await this.client.rest.get(path, {\n      query\n    });\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n\n  /**\n   * Obtains all active thread channels in the guild.\n   * This internally calls {@link GuildChannelManager#fetchActiveThreads}.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   */\n  fetchActive() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.channel.guild.channels.fetchActiveThreads(cache);\n  }\n  static _mapThreads(rawThreads, client, _ref) {\n    let {\n      parent,\n      guild,\n      cache\n    } = _ref;\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, {\n        cache\n      });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n\n    // Discord sends the thread id as id in this object\n    const threadMembers = rawThreads.members.reduce((coll, raw) => coll.set(raw.user_id, threads.get(raw.id).members._add(raw)), new Collection());\n    const response = {\n      threads,\n      members: threadMembers\n    };\n\n    // The GET `/guilds/{guild.id}/threads/active` route does not return `has_more`.\n    if ('has_more' in rawThreads) response.hasMore = rawThreads.has_more;\n    return response;\n  }\n}\nmodule.exports = ThreadManager;","map":{"version":3,"names":["Collection","require","makeURLSearchParams","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","ThreadChannel","ThreadManager","constructor","channel","iterable","client","_add","thread","existing","cache","get","id","set","fetch","options","force","arguments","length","undefined","fetchActive","channels","resolveId","archived","fetchArchived","type","fetchAll","before","limit","path","channelThreads","channelJoinedArchivedThreads","timestamp","query","test","String","resolve","archivedAt","toISOString","toUse","Date","InvalidType","raw","rest","_mapThreads","parent","guild","fetchActiveThreads","rawThreads","_ref","threads","reduce","coll","parentId","threadMembers","members","user_id","response","hasMore","has_more","module","exports"],"sources":["/Users/williedejongh/Downloads/ark3-main4/node_modules/discord.js/src/managers/ThreadManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\n\n/**\n * Manages API methods for thread-based channels and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {TextChannel|NewsChannel|ForumChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]\n   * The type of thread to create.\n   * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}\n   * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * {@link ChannelType.AnnouncementThread}</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * Options for fetching multiple threads.\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] Options used to fetch archived threads\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads|FetchedThreadsMore)>}\n   * {@link FetchedThreads} if active & {@link FetchedThreadsMore} if archived.\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options, { cache, force } = {}) {\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, { cache, force });\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`\n   * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date\n   * or Snowflake\n   * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * Data returned from fetching multiple threads.\n   * @typedef {FetchedThreads} FetchedThreadsMore\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreadsMore>}\n   */\n  async fetchArchived({ type = 'public', fetchAll = false, before, limit } = {}, cache = true) {\n    let path = Routes.channelThreads(this.channel.id, type);\n    if (type === 'private' && !fetchAll) {\n      path = Routes.channelJoinedArchivedThreads(this.channel.id);\n    }\n    let timestamp;\n    let id;\n    const query = makeURLSearchParams({ limit });\n    if (before !== undefined) {\n      if (before instanceof ThreadChannel || /^\\d{17,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n        const toUse = type === 'private' && !fetchAll ? id : timestamp;\n        if (toUse) {\n          query.set('before', toUse);\n        }\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n          if (type === 'public' || fetchAll) {\n            query.set('before', timestamp);\n          }\n        } catch {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n\n    const raw = await this.client.rest.get(path, { query });\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  /**\n   * Obtains all active thread channels in the guild.\n   * This internally calls {@link GuildChannelManager#fetchActiveThreads}.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   */\n  fetchActive(cache = true) {\n    return this.channel.guild.channels.fetchActiveThreads(cache);\n  }\n\n  static _mapThreads(rawThreads, client, { parent, guild, cache }) {\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n\n    // Discord sends the thread id as id in this object\n    const threadMembers = rawThreads.members.reduce(\n      (coll, raw) => coll.set(raw.user_id, threads.get(raw.id).members._add(raw)),\n      new Collection(),\n    );\n\n    const response = { threads, members: threadMembers };\n\n    // The GET `/guilds/{guild.id}/threads/active` route does not return `has_more`.\n    if ('has_more' in rawThreads) response.hasMore = rawThreads.has_more;\n    return response;\n  }\n}\n\nmodule.exports = ThreadManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}